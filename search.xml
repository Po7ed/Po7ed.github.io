<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>长行级分享</title>
    <url>/2025-6-30/</url>
    <content><![CDATA[各位领导老师、星瀚级和长行级的学弟、学妹们：
下午好！
我是 2025 届弘毅级 9 班张敬东。

比起身边的两位巨佬，我今天的分享必定相形见绌，现在我如坐针毡，不知道教室里的你此刻是什么样的心情？也是坐立不安？因为期末考不够理想而失落，惆怅？想想还要奋斗一年而感到痛苦吗？是的，学习的确很辛苦。
那么，我们为什么要辛苦学习呢？让自己快乐一点，不好吗？现实是，文化课学习如果不够好，很多自己想做的事便无法实现。在当前的社会背景下，文化课是绝大多数同学的唯一出路。更直白一些，只有学好文化课，才有自由地做自己想做的事的资本。
既然文化课的学习无法避免，不妨顺其自然。
此时，你可能会说，我还是更喜欢玩游戏、刷短视频。它们让我快乐！它们的诱惑太大了！我感同深受。在平时的竞赛学习中，我时不时就会溜到 b 站去，不知不觉时间也溜走了。我也经常和父母发生争执，因为我游戏玩得不够尽兴。它们的正反馈的确极其快，游戏战绩如何一目了然，短视频快乐源源不断。相比之下，学习在让人快乐这件事上的表现就太糟糕了！它的正反馈慢到足够让你不想学。你努力了好几个月，最终却不见明显的进步。
前几天我的同学们填报中招志愿，有的同学因为中考估分不高，只能选择天价学费的私立高中，而有的同学则拥有自由选择顶级学府的绝对高分。如果你有幸考入一中、附中、三中等等这样的好高中，你将拥有优秀的同学、顶级的师资、三层豪华大食堂，想吃麻辣烫？有！牛排？有！汉堡，寿司，牛肉面，应有尽有！而且还不贵。总之，不论学习、生活，性价比极高，你值得拥有！我相信对于绝大多数同学，进入一三附这样的顶级高中一定是你们的最高理想。但是有的同学可能会说，这样的理想离我太遥远了，我认为我做不到，怎么办呢？
怎么办呢？我的解决方案是：适当缩减目标，将目标切细。
还记得七年级上册的课文《走一步，再走一步》吗？请允许我朗读其中一段：

“不要想着有多远，有多困难，你需要想的是迈一小步。这个你能做到。看着手电光指的地方。看到那块石头没有?”光柱游走，指着岩脊下面的一块突出的石头。“看到了吗?”他大声问道。
我慢慢地挪动了一下。“看到了。”我回答。
“好的，现在转过身去，然后用左脚踩住那块石头。这就是你要做的。它就在你下面一点儿。你能做到。不要担心接下来的事情，也不要往下看，先走好第一步。相信我。”

这是小主人公在爸爸的引导下一步步爬下悬崖的片段。
同学们，我们努力前进的过程，必然是艰难而曲折，看看身边那些高举着火炬帮我们指路的老师们吧，十六中的老师们个个敬业专业，我们只要紧跟着老师们的指引，给自己定下一些小目标，坚实地走好脚下的每一步，就必定能一点一点地进步，一点一点地向你既定的目标走去，并最终实现它。当然，对绝大多数同学而言，不要一开始就立志“我要冲进年段前 20，我要考一中”，结果天天被吊在 100 名开外打，然后很容易就自卑了，放弃了。不同状态的同学可以定不同的目标，来定义专属自己的进步。
每当获得一点点小小的进步时，你可以及时地给自己正反馈，恰如游戏所给的那样，也可以主动从朋友、老师、家长那里获取正向鼓励。一份甜品、一个礼物、一句肯定的话，等等，让你感到“我的努力付出”有回报。
课堂是学习进步的主战场，课堂上一定要努力全程和老师互动。比如，老师提问的时候，就算心里没底，也要勇敢发言，万一蒙对了，成就感爆棚；要是答错了，也没关系，就当给大家表演个 “反面教材”，调节下课堂气氛。总之一定要紧跟老师的课堂。
最后，心态调整也很重要。我们要学着做自己的 “心灵导师”。
有时考砸了，可能会感觉天都要塌下来了。我也经历过：有一场很重要的比赛，我发挥失常，以至于都怀疑自己是否适合继续走竞赛这条路了。但我不想这么早就放弃，一次失利不代表什么，只要听从内心的声音，努力尝试，总会走到自己想要去的地方。我喜欢在日记本上写下自己对学习的看法，调整心态，重拾信心。
另外，千万别和别人盲目攀比成绩。每个人的学习节奏不一样，有的人就像 “短跑选手”，平时成绩很好，但大型考试可能发挥失常；有的人是 “长跑选手”，厚积薄发，越到最后越厉害。你要做的就是找到自己的节奏，每天进步一点点，就是胜利！
在这里，要特别感谢三年来所有教过、没教过我的老师们，因为你们的无私付出，我们才有了健康成长的土壤！谢谢您！您辛苦了！
最后感谢各位同学的耐心聆听。
]]></content>
  </entry>
  <entry>
    <title>创班自招面试自我介绍</title>
    <url>/ahsfnu-rd-self-intro/</url>
    <content><![CDATA[
  40fff3a5cf27b77ac08956115c07132948247ffaab5d8e84347027a8feaf07344c79d75248c533d82da67f06b18b733284c41012181d50d4ad3df0f74ef90f2f7ec1bd7554ac1ed26fb5834dafc21d003ce52d0cee589eae3f80e499ae5a769b8add7e9dee2099268717a15683ae1fc2715d5209f816f591a501b0d6097681f0116913f10d1df3df0db4cbca46f4fbd3c46485ba31490209546d63333ceb786ace21ad8b8700ca82b0734c58d3c15e5cb3caf0b58d54640993a952ca29099c108f7708b4a29ba732c54654b2338650968871127db23a0047ca6669ea7b9921b933e40d3bfeae8f00cc56d21981ce0aff21f4243a86fe70da173ae20e16405316f957b67e0cb3f524bd05712f5765d5793e90b042f1d1db873ff729692e87e97d965f26d568ca047f871a75a3ce60cb9db2545e8343f368ec2e7ac0fa6513d33fefd9398506a030acdfe0c89cefd8b9eef3f8eab8028577483fbdb4954eb57354c6b210cc849b28f7abc8e9facaae355e6547954088a60ddfc424fb744366312848b1aa0427fa0bd39fdb0c62811192b22209cd6052e51c8ef147a722b3d5a5b0f8f991ae685057514286a534546b8ca40bd30dfe59ced95612dadca89fb6a072557ead7b22b97028b6196ba8a18a94f577ea0015f11153b92abafb1f5bb75786695ad3a58bcfe7636700ba3fb2b562a857fc63ac6ef0e0c51813c4e043b793895c82e2dd41fd889b1bf9771903b0cab3953131326d223da2b7b98fe063a60f3cfb0436bd38705ad2718c4e262a8793c5e6f20784023e0e06cb542ee3887b8fe31cbfd925ae04a9bf5298a462339ef2f14cdff2fe4286a599cad0bd87b465ca57245205d7915d3e0a2f85c220fc46730793507116238f9ce3005573cd936ac1ea7881a48f7051a1e3857b5fa0a39be3b0ed09ed13a85e10039ad6377c5fad045276948e56b71869563273c434216bb04f3a430b64e635f23c81d2033406ffbbbbed2b1ca91988ebb3c3cf1f903682b7d6b9322828707eab14f66a1b5c42dcd4f888866031a93870da310bd763f402845e7fb15d634e1d0d229deb6ec6674cfe0a677d94d92e07df26e807528b9a68f285d1ccebdbaaf1b98e40c17a283fb2a7e45a53f0dfec00000d65d5efb924d13ea66a9d4f85c3c497946161cc4d61729916e8bbad7e4740fb2ebc455970befe29d837b7f716015eec5bd1ffb961be0e28e13ffb76fe8ee5707ecbd9dd11417705ed5841ef0d175abafc249419c0736b5daad06a476e7c0083276f9b8dfc12f2f192b611f755319465381aad27db6ffa8633d6e1135c4c737d67edb5739274b3818747c3acec560af6f07e1ac2afc6902cff484e46bc2f0afc4a605cc7ec505dfd84573ba6ab7059ad3d211f3eb7ec3ed011c649884b062e4d70a843157831f35561ffcc809787a050eb658a0e61e7eb970d2faebc6a1ffe2edf16af966b16a0442e3c00e3ea9060bea080ef53b17a5184adb0814ca7042591e1920f89c2d8ee4e4c0137793173bde1a2de54314de8cec18e824576e5c6470173f4ed45b36ad36d0d5a3ede23b2dbd12a0e2fa2ea3fb66774e3b342897fb7bee78b3c5b73edda915eb79389db920083af901cc547f079c0be80c007203a1ac70838acd091d682c0eb331f71149fc5d78099beed4bcbbb88339ff04a89ad291a6a3403a426cd836b7fbe1f9a5a950500d3c32903d8bd8376bc315b207077540ee6ea85ca728ffbbbeff76c4e10a587e7b581232ae5d5c8b17f6ea15871072e5a4fd8ad7f2f28cdcfb3ecf7a30cc2f8e35433de54a6602c404a311f2a89d94925a372822ed565da34af04425c9cd2e568593b3822f28a10c0b8e7730188146d261c747e25ca960bcff6
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学</title>
    <url>/combinatorics/</url>
    <content><![CDATA[设 0!=00=10!=0^0=10!=00=1。
施工中。有部分空缺。

加法 &amp; 乘法原理
加法原理
完成一个任务有 nnn 类办法，第 iii 类办法有 aia_iai​ 个方法，则完成该任务共有 ∑i=1nai\sum_{i=1}^{n}a_i∑i=1n​ai​ 种不同的方法。
乘法原理
完成一个任务有 nnn 个步骤，第 iii 个步骤有 aia_iai​ 个方法，则完成该任务共有 ∏i=1nai\prod_{i=1}^{n}a_i∏i=1n​ai​ 种不同的方法。
排列 &amp; 组合数
排列数
从 nnn 个互不相同的元素中取出 mmm（m≤nm\le nm≤n，m,n∈Nm,n\in\Bbb{N}m,n∈N）个并按照一定的顺序排列，所得到的排列称为 nnn 中取 mmm 的一个排列。设完成这个任务的方案数（也是所得排列的个数）为 Anm\mathrm{A}_n^mAnm​，有计算 Anm\mathrm{A}_n^mAnm​ 的公式
Anm=n×(n−1)×⋯×(n−(m−1))=∏i=1m(n−(i−1))=n!(n−m)!(1)\mathrm{A}_n^m=n\times (n-1)\times\cdots\times (n-(m-1))=\prod_{i=1}^{m}(n-(i-1))=\cfrac{n!}{(n-m)!}\tag{1}
Anm​=n×(n−1)×⋯×(n−(m−1))=i=1∏m​(n−(i−1))=(n−m)!n!​(1)
(1)(1)(1) 可以用乘法原理解释。上述任务共分 mmm 步，其中第 iii 步执行“从剩余 (n−(i−1))(n-(i-1))(n−(i−1)) 个元素中取出 111 个”，显然第 iii 步有 (n−i+1)(n-i+1)(n−i+1) 个方案，于是累乘。
组合数
从 nnn 个互不相同的元素中取出 mmm（m≤nm\le nm≤n，m,n∈Nm,n\in\Bbb{N}m,n∈N）个组成集合，所得到的集合称为 nnn 中取 mmm 的一个组合，设所得的组合个数（重复的不计）为 Cnm=(nm)\mathrm{C}_n^m=\dbinom{n}{m}Cnm​=(mn​)。
显然的，对于每个组合 CCC，都可以得出 m!m!m! 个以 CCC 内元素组成的排列。（只需将 CCC 内 mmm 个元素全排列即可。）于是，
m!(nm)=Anmm!\dbinom{n}{m}=\mathrm{A}_n^m
m!(mn​)=Anm​
于是有计算 (nm)\dbinom{n}{m}(mn​) 的公式
(nm)=Anmm!=n!(n−m)!m!(2)\dbinom{n}{m}=\cfrac{\mathrm{A}_n^m}{m!}=\cfrac{n!}{(n-m)!m!}\tag{2}
(mn​)=m!Anm​​=(n−m)!m!n!​(2)
在 OI 中，由于 m&gt;nm&gt;nm&gt;n 的情况对于定义无意义，故设此时 Anm=(nm)=0\mathrm{A}_n^m=\dbinom{n}{m}=0Anm​=(mn​)=0，代表无方案。（一般地，无意义的情况组合、排列数均默认为 000。）
圆排列
多重组合数
杨辉三角
容易通过下面将要介绍的 (3)(3)(3) 式得到杨辉三角   ⟺  \iff⟺ 组合数。
这里给出一个表格
The table of (nm)n\m0123456789011112121313314146415151010516161520156171721353521718182856705628819193684126126843691\text{The table of }\dbinom{n}{m}\\
\begin{array}{|r|c|c|c|c|c|c|c|c|c|c|}\hline
	n\backslash m&amp;\boldsymbol{0}&amp;\boldsymbol{1}&amp;\boldsymbol{2}&amp;\boldsymbol{3}&amp;\boldsymbol{4}&amp;\boldsymbol{5}&amp;\boldsymbol{6}&amp;\boldsymbol{7}&amp;\boldsymbol{8}&amp;\boldsymbol{9}\\\hline
	\boldsymbol{0}&amp;1\\\hline
	\boldsymbol{1}&amp;1&amp;1\\\hline
	\boldsymbol{2}&amp;1&amp;2&amp;1\\\hline
	\boldsymbol{3}&amp;1&amp;3&amp;3&amp;1\\\hline
	\boldsymbol{4}&amp;1&amp;4&amp;6&amp;4&amp;1\\\hline
	\boldsymbol{5}&amp;1&amp;5&amp;10&amp;10&amp;5&amp;1\\\hline
	\boldsymbol{6}&amp;1&amp;6&amp;15&amp;20&amp;15&amp;6&amp;1\\\hline
	\boldsymbol{7}&amp;1&amp;7&amp;21&amp;35&amp;35&amp;21&amp;7&amp;1\\\hline
	\boldsymbol{8}&amp;1&amp;8&amp;28&amp;56&amp;70&amp;56&amp;28&amp;8&amp;1\\\hline
	\boldsymbol{9}&amp;1&amp;9&amp;36&amp;84&amp;126&amp;126&amp;84&amp;36&amp;9&amp;1\\\hline
\end{array}
The table of (mn​)n\m0123456789​01111111111​1123456789​21361015212836​3141020355684​415153570126​5162156126​6172884​71836​819​91​​
将组合数操作转化到为杨辉三角上研究是一个常用方法。下面的性质也可以结合杨辉三角理解（下面的部分可能偏形式化）。
组合数常见性质（公式）
对称公式
(nk)=(nn−k)(3)\dbinom{n}{k}=\dbinom{n}{n-k}\tag{3}
(kn​)=(n−kn​)(3)
即对换取与不取（C⇆∁{1,⋯ ,n}CC\leftrightarrows \complement_{\{1,\cdots,n\}} CC⇆∁{1,⋯,n}​C）。
加法公式（递推式）
(nk)=(n−1k)+(n−1k−1)(4)\dbinom{n}{k}=\dbinom{n-1}{k}+\dbinom{n-1}{k-1}\tag{4}
(kn​)=(kn−1​)+(k−1n−1​)(4)
可视为最后一个元素取与不取之和。不取则从 n−1n-1n−1 中选 kkk，取则从 n−1n-1n−1 中选 k−1k-1k−1。
吸收公式
(nk)=nk(n−1k−1)(5)\dbinom{n}{k}=\cfrac{n}{k}\dbinom{n-1}{k-1}\tag{5}
(kn​)=kn​(k−1n−1​)(5)
由通项公式 (2)(2)(2) 可得：
(nk)=n!(n−k)!k!=n×(n−1)!k×(n−k)!(k−1)!=nk(n−1k−1)\dbinom{n}{k}=\cfrac{n!}{(n-k)!k!}=\cfrac{n\times(n-1)!}{k\times(n-k)!(k-1)!}=\cfrac{n}{k}\dbinom{n-1}{k-1}
(kn​)=(n−k)!k!n!​=k×(n−k)!(k−1)!n×(n−1)!​=kn​(k−1n−1​)
二次选择
(nm)(mk)=(nk)(n−km−k)(6)\dbinom{n}{m}\dbinom{m}{k}=\dbinom{n}{k}\dbinom{n-k}{m-k}\tag{6}
(mn​)(km​)=(kn​)(m−kn−k​)(6)
设 ∣A∣=n,∣B∣=m,∣C∣=k,C⊆B⊆A|A|=n,|B|=m,|C|=k,C\subseteq B\subseteq A∣A∣=n,∣B∣=m,∣C∣=k,C⊆B⊆A，则
从 AAA 中选出 BBB，再从 BBB 中选出 CCC 的方案数 等于 先从 AAA 中选出 CCC，然后从 ∁AC\complement_A C∁A​C 中选出 B′B&#x27;B′，则 B=B′∪CB=B&#x27;\cup CB=B′∪C 的方案数。
换个角度，使用定义，
(nm)(mk)=n!(n−m)!m!×m!(m−k)!k!=n!(n−m)!×1(m−k)!k!=n!k!×1(m−k)!(n−m)!=n!(n−k)!k!×(n−k)!(m−k)!(n−m)!=(nk)(n−km−k)\begin{aligned}
	\dbinom{n}{m}\dbinom{m}{k}&amp;=\cfrac{n!}{(n-m)!m!}\times\cfrac{m!}{(m-k)!k!}\\
	&amp;=\cfrac{n!}{(n-m)!}\times\cfrac{1}{(m-k)!k!}\\
	&amp;=\cfrac{n!}{k!}\times\cfrac{1}{(m-k)!(n-m)!}\\
	&amp;=\cfrac{n!}{(n-k)!k!}\times\cfrac{(n-k)!}{(m-k)!(n-m)!}\\
	&amp;=\dbinom{n}{k}\dbinom{n-k}{m-k}
\end{aligned}
(mn​)(km​)​=(n−m)!m!n!​×(m−k)!k!m!​=(n−m)!n!​×(m−k)!k!1​=k!n!​×(m−k)!(n−m)!1​=(n−k)!k!n!​×(m−k)!(n−m)!(n−k)!​=(kn​)(m−kn−k​)​
行求和
∑i=0n(ni)=2n(7)\sum_{i=0}^{n}\dbinom{n}{i}=2^n\tag{7}
i=0∑n​(in​)=2n(7)
即所有选择的方案数等于所有长度为 iii 的方案数之和（0≤i≤n0\le i\le n0≤i≤n）。
换个角度，由 (4)(4)(4) 得
∑i=0n(ni)=∑i=0n[(n−1i−1)+(n−1i)]=∑i=−1n−1(n−1i)+∑i=0n(n−1i)=2∑i=0n−1(n−1i)\sum_{i=0}^{n}\dbinom{n}{i}=\sum_{i=0}^{n}\left[\dbinom{n-1}{i-1}+\dbinom{n-1}{i}\right]=\sum_{i=-1}^{n-1}\dbinom{n-1}{i}+\sum_{i=0}^{n}\dbinom{n-1}{i}=2\sum_{i=0}^{n-1}\dbinom{n-1}{i}
i=0∑n​(in​)=i=0∑n​[(i−1n−1​)+(in−1​)]=i=−1∑n−1​(in−1​)+i=0∑n​(in−1​)=2i=0∑n−1​(in−1​)
即行求和等于上一行求和的两倍。n=0n=0n=0 时，
∑i=0n(ni)=(00)=1=20=2n\sum_{i=0}^{n}\dbinom{n}{i}=\dbinom{0}{0}=1=2^0=2^n
i=0∑n​(in​)=(00​)=1=20=2n
故运用数学归纳法可得式 (7)(7)(7)。
其实 (7)(7)(7) 式可由二项式定理代入 a=1,b=1a=1,b=1a=1,b=1 得到。下文会介绍。
带符号行求和
∑i=0n(−1)i(ni)=[n=0](8)\sum_{i=0}^{n}(-1)^i\dbinom{n}{i}=[n=0]\tag{8}
i=0∑n​(−1)i(in​)=[n=0](8)
同样由 (4)(4)(4) 得（n≠0n\ne 0n​=0 时）
∑i=0n(−1)i(ni)=∑i=0n(−1)i[(n−1i−1)+(n−1i)]=(n−1−1)+(n−1n)=0\sum_{i=0}^{n}(-1)^i\dbinom{n}{i}=\sum_{i=0}^{n}(-1)^i\left[\dbinom{n-1}{i-1}+\dbinom{n-1}{i}\right]=\dbinom{n-1}{-1}+\dbinom{n-1}{n}=0
i=0∑n​(−1)i(in​)=i=0∑n​(−1)i[(i−1n−1​)+(in−1​)]=(−1n−1​)+(nn−1​)=0
上面的推导运用了类似裂项的技巧，前后两项可以消去，只剩头尾。当 n=0n=0n=0 时，
∑i=0n(−1)i(ni)=(−1)0×(00)=1\sum_{i=0}^{n}(-1)^i\dbinom{n}{i}=(-1)^0\times\dbinom{0}{0}=1
i=0∑n​(−1)i(in​)=(−1)0×(00​)=1
综上可得 (8)(8)(8)。同样，其可由二项式定理代入 a=1,b=−1a=1,b=-1a=1,b=−1 得到。
带权行求和
∑i=0ni(ni)=n2n−1(9)\sum_{i=0}^{n}i\dbinom{n}{i}=n2^{n-1}\tag{9}
i=0∑n​i(in​)=n2n−1(9)
∑i=0ni2(ni)=n(n+1)2n−1(10)\sum_{i=0}^{n}i^2\dbinom{n}{i}=n(n+1)2^{n-1}\tag{10}
i=0∑n​i2(in​)=n(n+1)2n−1(10)
列求和
∑i=kn(ik)=(n+1k+1)(11)\sum_{i=k}^{n}\dbinom{i}{k}=\dbinom{n+1}{k+1}\tag{11}
i=k∑n​(ki​)=(k+1n+1​)(11)
考虑 (kk)=(k+1k+1)=1\dbinom{k}{k}=\dbinom{k+1}{k+1}=1(kk​)=(k+1k+1​)=1，
∑i=kn(ik)=(kk)+∑i=k+1n(ik)=(k+1k+1)+∑i=k+1n(ik)=(k+1k+1)+(k+1k)+∑i=k+2n(ik)=(k+2k+1)+∑i=k+2n(ik)⋮=(k+j−1k+1)+∑i=k+j−1n(ik)=(k+j−1k+1)+(k+j−1k)+∑i=k+jn(ik)=(k+jk+1)+∑i=k+jn(ik)⋮=(k+(n−k+1)k+1)+∑i=k+(n−k+1)n(ik)=(n+1k+1)\begin{aligned}
	\sum_{i=k}^{n}\dbinom{i}{k}&amp;=\dbinom{k}{k}+\sum_{i=k+1}^{n}\dbinom{i}{k}\\
	&amp;=\dbinom{k+1}{k+1}+\sum_{i=k+1}^{n}\dbinom{i}{k}\\
	&amp;=\dbinom{k+1}{k+1}+\dbinom{k+1}{k}+\sum_{i=k+2}^{n}\dbinom{i}{k}\\
	&amp;=\dbinom{k+2}{k+1}+\sum_{i=k+2}^{n}\dbinom{i}{k}\\
	&amp;\quad\vdots\\
	&amp;=\dbinom{k+j-1}{k+1}+\sum_{i=k+j-1}^{n}\dbinom{i}{k}\\
	&amp;=\dbinom{k+j-1}{k+1}+\dbinom{k+j-1}{k}+\sum_{i=k+j}^{n}\dbinom{i}{k}\\
	&amp;=\dbinom{k+j}{k+1}+\sum_{i=k+j}^{n}\dbinom{i}{k}\\
	&amp;\quad\vdots\\
	&amp;=\dbinom{k+(n-k+1)}{k+1}+\sum_{\mathclap{i=k+(n-k+1)}}^{n}\dbinom{i}{k}\\
	&amp;=\dbinom{n+1}{k+1}
\end{aligned}
i=k∑n​(ki​)​=(kk​)+i=k+1∑n​(ki​)=(k+1k+1​)+i=k+1∑n​(ki​)=(k+1k+1​)+(kk+1​)+i=k+2∑n​(ki​)=(k+1k+2​)+i=k+2∑n​(ki​)⋮=(k+1k+j−1​)+i=k+j−1∑n​(ki​)=(k+1k+j−1​)+(kk+j−1​)+i=k+j∑n​(ki​)=(k+1k+j​)+i=k+j∑n​(ki​)⋮=(k+1k+(n−k+1)​)+i=k+(n−k+1)​∑n​(ki​)=(k+1n+1​)​
很吓人？其实就是一行行地向下迭代。
主对角线（方向）求和
∑i=0k(n+ii)=(n+k+1k)(12)\sum_{i=0}^{k}\dbinom{n+i}{i}=\dbinom{n+k+1}{k}\tag{12}
i=0∑k​(in+i​)=(kn+k+1​)(12)
考虑 (n0)=(n+10)=1\dbinom{n}{0}=\dbinom{n+1}{0}=1(0n​)=(0n+1​)=1，
∑i=0k(n+ii)=(n0)+∑i=1k(n+ii)=(n+10)+∑i=1k(n+ii)=(n+10)+(n+11)+∑i=2k(n+ii)=(n+21)+∑i=2k(n+ii)⋮=(n+jj−1)+∑i=jk(n+ii)⋮=(n+(k+1)(k+1)−1)+∑i=k+1k(n+ii)=(n+k+1k)\begin{aligned}
	\sum_{i=0}^{k}\dbinom{n+i}{i}&amp;=\dbinom{n}{0}+\sum_{i=1}^{k}\dbinom{n+i}{i}\\
	&amp;=\dbinom{n+1}{0}+\sum_{i=1}^{k}\dbinom{n+i}{i}\\
	&amp;=\dbinom{n+1}{0}+\dbinom{n+1}{1}+\sum_{i=2}^{k}\dbinom{n+i}{i}\\
	&amp;=\dbinom{n+2}{1}+\sum_{i=2}^{k}\dbinom{n+i}{i}\\
	&amp;\quad\vdots\\
	&amp;=\dbinom{n+j}{j-1}+\sum_{i=j}^{k}\dbinom{n+i}{i}\\
	&amp;\quad\vdots\\
	&amp;=\dbinom{n+(k+1)}{(k+1)-1}+\sum_{i=k+1}^{k}\dbinom{n+i}{i}\\
	&amp;=\dbinom{n+k+1}{k}
\end{aligned}
i=0∑k​(in+i​)​=(0n​)+i=1∑k​(in+i​)=(0n+1​)+i=1∑k​(in+i​)=(0n+1​)+(1n+1​)+i=2∑k​(in+i​)=(1n+2​)+i=2∑k​(in+i​)⋮=(j−1n+j​)+i=j∑k​(in+i​)⋮=((k+1)−1n+(k+1)​)+i=k+1∑k​(in+i​)=(kn+k+1​)​
辅对角线（方向）求和
∑i=0⌊n2⌋(n−ii)=Fn+1(13)\sum_{i=0}^{\left\lfloor\frac{n}{2}\right\rfloor}\dbinom{n-i}{i}=F_{n+1}\tag{13}
i=0∑⌊2n​⌋​(in−i​)=Fn+1​(13)
其实累加上界并不重要，即上界是比较松的，因为 i&gt;⌊n2⌋i&gt;\left\lfloor\dfrac{n}{2}\right\rfloori&gt;⌊2n​⌋ 时 n−i&lt;in-i&lt;in−i&lt;i，无意义。这里可以放大，视为 nnn，
∑i=0n(n−ii)=∑i=0n[(n−i−1i)+(n−i−1i−1)]=∑i=0n(n−i−1i)+∑i=0n(n−i−1i−1)=∑i=0n((n−1)−ii)+∑i=0n((n−2)−(i−1)i−1)=∑i=0n−1((n−1)−ii)+∑i=0n−2((n−2)−ii)\begin{aligned}
	\sum_{i=0}^{n}\dbinom{n-i}{i}&amp;=\sum_{i=0}^{n}\left[\dbinom{n-i-1}{i}+\dbinom{n-i-1}{i-1}\right]\\
	&amp;=\sum_{i=0}^{n}\dbinom{n-i-1}{i}+\sum_{i=0}^{n}\dbinom{n-i-1}{i-1}\\
	&amp;=\sum_{i=0}^{n}\dbinom{(n-1)-i}{i}+\sum_{i=0}^{n}\dbinom{(n-2)-(i-1)}{i-1}\\
	&amp;=\sum_{i=0}^{n-1}\dbinom{(n-1)-i}{i}+\sum_{i=0}^{n-2}\dbinom{(n-2)-i}{i}\\
\end{aligned}
i=0∑n​(in−i​)​=i=0∑n​[(in−i−1​)+(i−1n−i−1​)]=i=0∑n​(in−i−1​)+i=0∑n​(i−1n−i−1​)=i=0∑n​(i(n−1)−i​)+i=0∑n​(i−1(n−2)−(i−1)​)=i=0∑n−1​(i(n−1)−i​)+i=0∑n−2​(i(n−2)−i​)​
注意到上式满足斐波那契数列的递推式，同时 n=0n=0n=0 时式 (11)(11)(11) 等于 111，n=1n=1n=1 时式 (13)(13)(13) 也等于 111，故式 (13)(13)(13) 得证（数学归纳法）。
范德蒙德卷积
∑i=0k(ni)(mk−i)=(n+mk)(14)\sum_{i=0}^k\binom{n}{i}\binom{m}{k-i}=\binom{n+m}{k}\tag{14}
i=0∑k​(in​)(k−im​)=(kn+m​)(14)
证明使用二项式定理（设 l=i+jl=i+jl=i+j）
∑k=0n+m(n+mk)xk=(x+1)n+m=(x+1)n(x+1)m=[∑i=0n(ni)xi][∑j=0m(mj)xj]=∑i=0n∑j=0m(ni)(mj)xl=∑l=0n+m∑i=0l(ni)(mk−i)xl∑k=0n+m(n+mk)xk=∑l=0n+m∑i=0l(ni)(mk−i)xl(n+mk)=∑i=0l(ni)(mk−i)\begin{aligned}
	\sum_{k=0}^{n+m}\binom{n+m}{k}x^k&amp;=(x+1)^{n+m}\\
	&amp;=(x+1)^n(x+1)^m\\
	&amp;=\left[\sum_{i=0}^n\binom{n}{i}x^i\right]\left[\sum_{j=0}^m\binom{m}{j}x^j\right]\\
	&amp;=\sum_{i=0}^n\sum_{j=0}^m\binom{n}{i}\binom{m}{j}x^l\\
	&amp;=\sum_{l=0}^{n+m}\sum_{i=0}^l\binom{n}{i}\binom{m}{k-i}x^l\\
	\sum_{k=0}^{n+m}{\color{blue}\binom{n+m}{k}}x^k&amp;=\sum_{l=0}^{n+m}{\color{red}\sum_{i=0}^l\binom{n}{i}\binom{m}{k-i}}x^l\\
	\binom{n+m}{k}&amp;=\sum_{i=0}^l\binom{n}{i}\binom{m}{k-i}\\
\end{aligned}
k=0∑n+m​(kn+m​)xkk=0∑n+m​(kn+m​)xk(kn+m​)​=(x+1)n+m=(x+1)n(x+1)m=[i=0∑n​(in​)xi][j=0∑m​(jm​)xj]=i=0∑n​j=0∑m​(in​)(jm​)xl=l=0∑n+m​i=0∑l​(in​)(k−im​)xl=l=0∑n+m​i=0∑l​(in​)(k−im​)xl=i=0∑l​(in​)(k−im​)​
换个角度，考虑其组合意义。设 ∣S∣=n,∣T∣=m|S|=n,|T|=m∣S∣=n,∣T∣=m，S,TS,TS,T 中的元素每个都相同。在大小 n+mn+mn+m 的集合 S∪TS\cup TS∪T 中取出 kkk 个元素，等价于从 SSS 中取 iii 个，TTT 中取 k−ik-ik−i 个，合并。取法二中，枚举 iii 累加所有方案数，即与取法一方案数相等。
而上述意义是更利于记忆的。
推论 111
∑i=−ab(na+i)(mb−i)=(n+ma+b)(15)\sum_{i=-a}^{b}\dbinom{n}{a+i}\dbinom{m}{b-i}=\dbinom{n+m}{a+b}\tag{15}
i=−a∑b​(a+in​)(b−im​)=(a+bn+m​)(15)
证明类似。同样可以用形式化证明或组合意义。
推论 222
∑i=1n(ni)(ni−1)=(2nn−1)(16)\sum_{i=1}^{n}\dbinom{n}{i}\dbinom{n}{i-1}=\dbinom{2n}{n-1}\tag{16}
i=1∑n​(in​)(i−1n​)=(n−12n​)(16)
考虑转化为 (14)(14)(14)，
∑i=1n(ni)(ni−1)=∑i=1n(nn−i)(ni−1)=∑i=0n−1(nn−1−i)(ni)=(2nn−1)\sum_{i=1}^{n}\dbinom{n}{i}\dbinom{n}{i-1}=\sum_{i=1}^{n}\dbinom{n}{n-i}\dbinom{n}{i-1}=\sum_{i=0}^{n-1}\dbinom{n}{n-1-i}\dbinom{n}{i}=\dbinom{2n}{n-1}
i=1∑n​(in​)(i−1n​)=i=1∑n​(n−in​)(i−1n​)=i=0∑n−1​(n−1−in​)(in​)=(n−12n​)
推论 333
∑i=0n(ni)2=(2nn)(17)\sum_{i=0}^{n}\dbinom{n}{i}^2=\dbinom{2n}{n}\tag{17}
i=0∑n​(in​)2=(n2n​)(17)
依然转化，
∑i=0n(ni)2=∑i=0n(ni)(nn−i)=(2nn)\sum_{i=0}^{n}\dbinom{n}{i}^2=\sum_{i=0}^{n}\dbinom{n}{i}\dbinom{n}{n-i}=\dbinom{2n}{n}
i=0∑n​(in​)2=i=0∑n​(in​)(n−in​)=(n2n​)
推论 444
∑i=0m(ni)(mi)=(n+mm)(18)\sum_{i=0}^{m}\dbinom{n}{i}\dbinom{m}{i}=\dbinom{n+m}{m}\tag{18}
i=0∑m​(in​)(im​)=(mn+m​)(18)
还是转化
∑i=0m(ni)(mi)=∑i=0m(ni)(mm−i)=(n+mm)\sum_{i=0}^{m}\dbinom{n}{i}\dbinom{m}{i}=\sum_{i=0}^{m}\dbinom{n}{i}\dbinom{m}{m-i}=\dbinom{n+m}{m}
i=0∑m​(in​)(im​)=i=0∑m​(in​)(m−im​)=(mn+m​)
其中 (n+mm)\dbinom{n+m}{m}(mn+m​) 是网格图计数。设 (x,y)(x,y)(x,y) 表示 xxx 行 yyy 列，则从 (0,0)(0,0)(0,0) 走到 (n,m)(n,m)(n,m)，共需向下 nnn 步、向右 mmm 步，总步数为 n+mn+mn+m，从中选出 mmm 步向右即为方案数 (n+mm)\dbinom{n+m}{m}(mn+m​)。
若先走 nnn 步，其中 iii 步向右，则剩下 mmm 步需 m−im-im−i 步向左，为 (ni)(mm−i)\dbinom{n}{i}\dbinom{m}{m-i}(in​)(m−im​)，枚举 iii 累加也是答案。故左右相等。
插板法
问题
有 nnn 个完全相同的元素，将其分成 kkk 份，设第 iii 份有 xix_ixi​ 个（∑i=1kxi=n\sum_{i=1}^{k}x_i=n∑i=1k​xi​=n），求方案数。
正整数
限制条件：∀1≤i≤k,xi&gt;0\forall 1\le i\le k,x_i&gt;0∀1≤i≤k,xi​&gt;0。
考虑将 k−1k-1k−1 个板子插到 n−1n-1n−1 个空中，表示将 nnn 个元素分成 kkk 份，由于 nnn 个元素又是完全相同的，于是答案即为 (n−1k−1)=(n−1n−k)\dbinom{n-1}{k-1}=\dbinom{n-1}{n-k}(k−1n−1​)=(n−kn−1​)。
非负整数
限制条件：∀1≤i≤k,xi≥0\forall 1\le i\le k,x_i\ge 0∀1≤i≤k,xi​≥0。
考虑加入 kkk 个同样的元素，均分给 kkk 份（每份都有 111 个）。设现在第 iii 份有 xi′x&#x27;_ixi′​ 个，于是有 xi′=xi+1≥1&gt;0x&#x27;_i=x_i+1\ge 1&gt;0xi′​=xi​+1≥1&gt;0，转化成了正整数情况。于是我们算出 x′x&#x27;x′ 的取值个数后，xi=xi′−1x_i=x&#x27;_i-1xi​=xi′​−1，即可得到 xxx 相对应的非负整数情况。显然对于每个 x,x′x,x&#x27;x,x′，二者是一一对应的。
于是，有答案 (n+k−1k−1)=(n+k−1n)\dbinom{n+k-1}{k-1}=\dbinom{n+k-1}{n}(k−1n+k−1​)=(nn+k−1​)。
更一般的限制情况
限制条件：∀1≤i≤k,xi≥ai≥0\forall 1\le i\le k,x_i\ge a_i\ge 0∀1≤i≤k,xi​≥ai​≥0，其中设 ∑a=∑i=1kai≤n\sum a=\sum_{i=1}^{k}a_i\le n∑a=∑i=1k​ai​≤n。
考虑转化成非负整数限制，我们从第 iii 份中偷走 aia_iai​ 个。设现在第 iii 份有 xi′x&#x27;_ixi′​ 个，有 xi′=xi−aix&#x27;_i=x_i-a_ixi′​=xi​−ai​。
设
n′=∑i=1kxi′=∑i=1kxi−∑i=1kai=n−∑an&#x27;=\sum_{i=1}^{k}x&#x27;_i=\sum_{i=1}^{k}x_i-\sum_{i=1}^{k}a_i=n-\sum a
n′=i=1∑k​xi′​=i=1∑k​xi​−i=1∑k​ai​=n−∑a
故 x′x&#x27;x′ 取值个数为
(n′+k−1n′)=(n−∑a+k−1n−∑a)\dbinom{n&#x27;+k-1}{n&#x27;}=\dbinom{n-\sum a+k-1}{n-\sum a}
(n′n′+k−1​)=(n−∑an−∑a+k−1​)
求出 x′x&#x27;x′ 取值个数后，将偷走的元素还回去，即可一一对应得到相同取值个数的 xxx，故答案即为上式。
不相邻组合个数
从 nnn 中选 kkk 的组合 CCC，要求 ∀i,j∈C,i≠j+1\forall i,j\in C,i\ne j+1∀i,j∈C,i​=j+1，求满足这样条件的 CCC 的个数。
考虑将选的 kkk 个数视为板，将未选的 n−kn-kn−k 个数视为相同的元素，将 kkk 个板插进 n−k+1n-k+1n−k+1 个空中（空包括两侧），满足了板两两不相邻，即问题的要求，于是答案即为 (n−k+1k)\dbinom{n-k+1}{k}(kn−k+1​)。
容斥原理
对于集合 UUU 中的元素，有 nnn 个互不相同的属性。拥有第 iii 种属性的元素构成集合 SiS_iSi​。注意一个元素可能有多个属性。
我们有
∣⋃i=1nSi∣=∑j=1n(−1)j−1∑1≤a(k)&lt;a(k+1)≤n∣⋂i=1jSa(i)∣(19)\left|\bigcup_{i=1}^{n}S_i\right|=\sum_{j=1}^{n}(-1)^{j-1}\sum_{\mathclap{1\le a(k)&lt;a(k+1)\le n}}\qquad\left|\bigcap_{i=1}^{j}S_{a(i)}\right|\tag{19}
∣∣∣∣∣∣​i=1⋃n​Si​∣∣∣∣∣∣​=j=1∑n​(−1)j−11≤a(k)&lt;a(k+1)≤n​∑​∣∣∣∣∣∣​i=1⋂j​Sa(i)​∣∣∣∣∣∣​(19)
可以通过统计每个元素贡献得证。
同时若求全集 UUU 下的集合并，可得
∣⋂i=1nSi∣=∣⋃i=1nSi‾‾∣=∣U∣−∣⋃i=1nSi‾∣=∣U∣−∑j=1n(−1)j−1∑1≤a(k)&lt;a(k+1)≤n∣⋂i=1jSa(i)‾∣=∣U∣+∑j=1n(−1)j∑1≤a(k)&lt;a(k+1)≤n∣⋂i=1jSa(i)‾∣(20)\begin{aligned}
	\left|\bigcap_{i=1}^{n}S_i\right|&amp;=\left|\overline{\bigcup_{i=1}^{n}\overline{S_i}}\right|\\
	&amp;=|U|-\left|\bigcup_{i=1}^{n}\overline{S_i}\right|\\
	&amp;=|U|-\sum_{j=1}^{n}(-1)^{j-1}\sum_{\mathclap{1\le a(k)&lt;a(k+1)\le n}}\qquad\left|\bigcap_{i=1}^{j}\overline{S_{a(i)}}\right|\\
	&amp;=|U|+\sum_{j=1}^{n}(-1)^{j}\sum_{\mathclap{1\le a(k)&lt;a(k+1)\le n}}\qquad\left|\bigcap_{i=1}^{j}\overline{S_{a(i)}}\right|\tag{20}
\end{aligned}
∣∣∣∣∣∣​i=1⋂n​Si​∣∣∣∣∣∣​​=∣∣∣∣∣∣​i=1⋃n​Si​​​∣∣∣∣∣∣​=∣U∣−∣∣∣∣∣∣​i=1⋃n​Si​​∣∣∣∣∣∣​=∣U∣−j=1∑n​(−1)j−11≤a(k)&lt;a(k+1)≤n​∑​∣∣∣∣∣∣​i=1⋂j​Sa(i)​​∣∣∣∣∣∣​=∣U∣+j=1∑n​(−1)j1≤a(k)&lt;a(k+1)≤n​∑​∣∣∣∣∣∣​i=1⋂j​Sa(i)​​∣∣∣∣∣∣​​(20)
用容斥，不过用完容斥不是又要求并了吗？
二项式定理
二项式定理阐明了一个二项多项式展开后的系数与组合数的关系
(a+b)n=∑i=0n(ni)aibn−i(21)(a+b)^n=\sum_{i=0}^{n}\dbinom{n}{i}a^ib^{n-i}\tag{21}
(a+b)n=i=0∑n​(in​)aibn−i(21)
可以用组合意义证明，比较显然。
二项式反演

二项式反演为一种反演形式，常用于通过 “指定某若干个” 求 “恰好若干个” 的问题。——GXZlegend

第 000 形式
∣⋂i=1nSi‾∣=∣U∣−∣⋃i=1nSi∣=∣U∣+∑j=1n(−1)j∑1≤a(k)&lt;a(k+1)≤n∣⋂i=1jSa(i)∣∣⋂i=1nSi∣=∣U∣−∣⋃i=1nSi‾∣=∣U∣+∑j=1n(−1)j∑1≤a(k)&lt;a(k+1)≤n∣⋂i=1jSa(i)‾∣\left|\bigcap_{i=1}^{n}\overline{S_i}\right|=|U|-\left|\bigcup_{i=1}^{n}S_i\right|=|U|+\sum_{j=1}^{n}(-1)^{j}\sum_{\mathclap{1\le a(k)&lt;a(k+1)\le n}}\qquad\left|\bigcap_{i=1}^{j}S_{a(i)}\right|\\
\left|\bigcap_{i=1}^{n}S_i\right|=|U|-\left|\bigcup_{i=1}^{n}\overline{S_i}\right|=|U|+\sum_{j=1}^{n}(-1)^{j}\sum_{\mathclap{1\le a(k)&lt;a(k+1)\le n}}\qquad\left|\bigcap_{i=1}^{j}\overline{S_{a(i)}}\right|
∣∣∣∣∣∣​i=1⋂n​Si​​∣∣∣∣∣∣​=∣U∣−∣∣∣∣∣∣​i=1⋃n​Si​∣∣∣∣∣∣​=∣U∣+j=1∑n​(−1)j1≤a(k)&lt;a(k+1)≤n​∑​∣∣∣∣∣∣​i=1⋂j​Sa(i)​∣∣∣∣∣∣​∣∣∣∣∣∣​i=1⋂n​Si​∣∣∣∣∣∣​=∣U∣−∣∣∣∣∣∣​i=1⋃n​Si​​∣∣∣∣∣∣​=∣U∣+j=1∑n​(−1)j1≤a(k)&lt;a(k+1)≤n​∑​∣∣∣∣∣∣​i=1⋂j​Sa(i)​​∣∣∣∣∣∣​
当集合的交集大小只与所交的集合的数量有关时，若设 f(j)f(j)f(j) 表示任意 jjj 个集合的补集的交集大小，g(j)g(j)g(j) 表示任意 jjj 个集合的交集大小，即
f(j)≡∣⋂i=1jSa(i)‾∣(∀1≤ak&lt;ak+1≤n)g(j)≡∣⋂i=1jSa(i)∣(∀1≤ak&lt;ak+1≤n)f(j)\equiv\left|\bigcap_{i=1}^{j}\overline{S_{a(i)}}\right|\qquad(\forall 1\le a_k&lt;a_{k+1}\le n)\\
g(j)\equiv\left|\bigcap_{i=1}^{j}S_{a(i)}\right|\qquad(\forall 1\le a_k&lt;a_{k+1}\le n)
f(j)≡∣∣∣∣∣∣​i=1⋂j​Sa(i)​​∣∣∣∣∣∣​(∀1≤ak​&lt;ak+1​≤n)g(j)≡∣∣∣∣∣∣​i=1⋂j​Sa(i)​∣∣∣∣∣∣​(∀1≤ak​&lt;ak+1​≤n)
代入，
f(n)=∣U∣+∑j=1n(−1)j∑1≤a(k)&lt;a(k+1)≤ng(j)=∑j=0n(−1)j(nj)g(j)g(n)=∣U∣+∑j=1n(−1)j∑1≤a(k)&lt;a(k+1)≤nf(j)=∑j=0n(−1)j(nj)f(j)f(n)=|U|+\sum_{j=1}^{n}(-1)^{j}\sum_{\mathclap{1\le a(k)&lt;a(k+1)\le n}}g(j)=\sum_{j=0}^{n}(-1)^{j}\dbinom{n}{j}g(j)\\
g(n)=|U|+\sum_{j=1}^{n}(-1)^{j}\sum_{\mathclap{1\le a(k)&lt;a(k+1)\le n}}f(j)=\sum_{j=0}^{n}(-1)^{j}\dbinom{n}{j}f(j)
f(n)=∣U∣+j=1∑n​(−1)j1≤a(k)&lt;a(k+1)≤n​∑​g(j)=j=0∑n​(−1)j(jn​)g(j)g(n)=∣U∣+j=1∑n​(−1)j1≤a(k)&lt;a(k+1)≤n​∑​f(j)=j=0∑n​(−1)j(jn​)f(j)
这里之所以 ∣U∣|U|∣U∣ 能被吸收进 sigma 中是因为 ∩\cap∩ 的单位元是全集 UUU。当 j=0j=0j=0 时，(−1)j(nj)g(j)=1×1×g(0)=∣U∣(-1)^{j}\dbinom{n}{j}g(j)=1\times 1\times g(0)=|U|(−1)j(jn​)g(j)=1×1×g(0)=∣U∣。
于是我们得到了二项式反演的第 000 形式：
f(n)=∑j=0n(−1)j(nj)g(j)  ⟺  g(n)=∑j=0n(−1)j(nj)f(j)(22)f(n)=\sum_{j=0}^{n}(-1)^{j}\dbinom{n}{j}g(j)
\iff
g(n)=\sum_{j=0}^{n}(-1)^{j}\dbinom{n}{j}f(j)\tag{22}
f(n)=j=0∑n​(−1)j(jn​)g(j)⟺g(n)=j=0∑n​(−1)j(jn​)f(j)(22)
第 111 形式
考虑设 h(j)=(−1)jg(j)h(j)=(-1)^jg(j)h(j)=(−1)jg(j)，代入，
f(n)=∑j=0n(nj)h(j)  ⟺  h(n)(−1)n=∑j=0n(−1)j(nj)f(j)  ⟺  h(n)=∑j=0n(−1)n+j(nj)f(j)  ⟺  h(n)=∑j=0n(−1)n−j(nj)f(j)\begin{aligned}
	f(n)=\sum_{j=0}^{n}\dbinom{n}{j}h(j)
	&amp;\iff\cfrac{h(n)}{(-1)^{n}}=\sum_{j=0}^{n}(-1)^{j}\dbinom{n}{j}f(j)\\
	&amp;\iff h(n)=\sum_{j=0}^{n}(-1)^{n+j}\dbinom{n}{j}f(j)\\
	&amp;\iff h(n)=\sum_{j=0}^{n}(-1)^{n-j}\dbinom{n}{j}f(j)\\
\end{aligned}
f(n)=j=0∑n​(jn​)h(j)​⟺(−1)nh(n)​=j=0∑n​(−1)j(jn​)f(j)⟺h(n)=j=0∑n​(−1)n+j(jn​)f(j)⟺h(n)=j=0∑n​(−1)n−j(jn​)f(j)​
于是我们得到了二项式反演的第 111 形式：
f(n)=∑j=0n(nj)h(j)  ⟺  h(n)=∑j=0n(−1)n−j(nj)f(j)(23)f(n)=\sum_{j=0}^{n}\dbinom{n}{j}h(j)
\iff
h(n)=\sum_{j=0}^{n}(-1)^{n-j}\dbinom{n}{j}f(j)\tag{23}
f(n)=j=0∑n​(jn​)h(j)⟺h(n)=j=0∑n​(−1)n−j(jn​)f(j)(23)
第 1.51.51.5 形式
第 111 形式更加一般的情况，
f(n)=∑j=mn(nj)h(j)  ⟺  h(n)=∑j=mn(−1)n−j(nj)f(j)(24)f(n)=\sum_{j=m}^{n}\dbinom{n}{j}h(j)
\iff
h(n)=\sum_{j=m}^{n}(-1)^{n-j}\dbinom{n}{j}f(j)\tag{24}
f(n)=j=m∑n​(jn​)h(j)⟺h(n)=j=m∑n​(−1)n−j(jn​)f(j)(24)
考虑证明：
代入（记 k=j−ik=j-ik=j−i）
f(n)=∑j=mn(nj)∑i=mj(−1)j−i(ji)f(i)=∑j=mn∑i=mj(−1)j−i(nj)(ji)f(i)=∑j=mn∑i=mj(−1)j−i(ni)(n−ij−i)f(i)=∑i=mn∑j=in(−1)j−i(ni)(n−ij−i)f(i)=∑i=mn(ni)f(i)∑j=in(−1)j−i(n−ij−i)=∑i=mn(ni)f(i)∑k=0n−i(−1)k(n−ik)=∑i=mn(ni)f(i)[n−i=0]=(nn)f(n)=f(n)□\begin{aligned}
	f(n)&amp;=\sum_{j=m}^{n}\dbinom{n}{j}\sum_{i=m}^{j}(-1)^{j-i}\dbinom{j}{i}f(i)\\
	&amp;=\sum_{j=m}^{n}\sum_{i=m}^{j}(-1)^{j-i}\dbinom{n}{j}\dbinom{j}{i}f(i)\\
	&amp;=\sum_{j=m}^{n}\sum_{i=m}^{j}(-1)^{j-i}\dbinom{n}{i}\dbinom{n-i}{j-i}f(i)\\
	&amp;=\sum_{i=m}^{n}\sum_{j=i}^{n}(-1)^{j-i}\dbinom{n}{i}\dbinom{n-i}{j-i}f(i)\\
	&amp;=\sum_{i=m}^{n}\dbinom{n}{i}f(i)\sum_{j=i}^{n}(-1)^{j-i}\dbinom{n-i}{j-i}\\
	&amp;=\sum_{i=m}^{n}\dbinom{n}{i}f(i)\sum_{k=0}^{n-i}(-1)^{k}\dbinom{n-i}{k}\\
	&amp;=\sum_{i=m}^{n}\dbinom{n}{i}f(i)[n-i=0]\\
	&amp;=\dbinom{n}{n}f(n)\\
	&amp;=f(n)&amp;\square\\
\end{aligned}
f(n)​=j=m∑n​(jn​)i=m∑j​(−1)j−i(ij​)f(i)=j=m∑n​i=m∑j​(−1)j−i(jn​)(ij​)f(i)=j=m∑n​i=m∑j​(−1)j−i(in​)(j−in−i​)f(i)=i=m∑n​j=i∑n​(−1)j−i(in​)(j−in−i​)f(i)=i=m∑n​(in​)f(i)j=i∑n​(−1)j−i(j−in−i​)=i=m∑n​(in​)f(i)k=0∑n−i​(−1)k(kn−i​)=i=m∑n​(in​)f(i)[n−i=0]=(nn​)f(n)=f(n)​□​
第 222 形式
f(n)=∑j=nm(jn)g(j)  ⟺  g(n)=∑j=nm(−1)j−n(jn)f(j)(25)f(n)=\sum_{j=n}^{m}\dbinom{j}{n}g(j)
\iff
g(n)=\sum_{j=n}^{m}(-1)^{j-n}\dbinom{j}{n}f(j)\tag{25}
f(n)=j=n∑m​(nj​)g(j)⟺g(n)=j=n∑m​(−1)j−n(nj​)f(j)(25)
证明与第 1.51.51.5 形式类似，略。简称懒得写了（。
康托展开
一些定义
有一个长度为 nnn 的排列 PPP。
定义排列通过字典序比大小，即若长度为 nnn 的排列 A,BA,BA,B 有

任意 1≤j&lt;i≤n,Aj=Bj1\le j&lt;i\le n,A_j=B_j1≤j&lt;i≤n,Aj​=Bj​；
Ai&lt;BiA_i&lt;B_iAi​&lt;Bi​，

则有排列 A&lt;BA&lt;BA&lt;B。这里不考虑长度不一样的情况。
定义一个排列 PPP 的排名 rnk(P)rnk(P)rnk(P) 为比它小的排列数量 +1+1+1。
康托展开
给定 PPP，求 rnk(P)rnk(P)rnk(P)。
等价于：求长度为 nnn 的排列 QQQ，满足 Q&lt;PQ&lt;PQ&lt;P 的数量（+1+1+1）。
考虑枚举定义中的 iii。于是 ∀1≤j&lt;i≤n,Qj=Pj\forall 1\le j&lt;i\le n,Q_j=P_j∀1≤j&lt;i≤n,Qj​=Pj​。那么 QiQ_iQi​ 可以是哪些数呢？

Qi&lt;Pi  ⟹  Qi≠Pi  ⟹  i≠kQ_i&lt;P_i\implies Q_i\ne P_i\implies i\ne kQi​&lt;Pi​⟹Qi​​=Pi​⟹i​=k。
Qi≠Qj  ⟺  ∃k,i≤k,Qi=PkQ_i\ne Q_j\iff \exists k,i\le k,Q_i=P_kQi​​=Qj​⟺∃k,i≤k,Qi​=Pk​。

  ⟹  ∃k,i&lt;k,Qi=Pk&lt;Pi\implies\exists k,i&lt;k,Q_i=P_k&lt;P_i⟹∃k,i&lt;k,Qi​=Pk​&lt;Pi​，故 QiQ_iQi​ 的取值数量（记为 f(i)f(i)f(i)）即为
f(i)=∑k=i+1n[Pk&lt;Pi]f(i)=\sum_{k=i+1}^{n}[P_k&lt;P_i]
f(i)=k=i+1∑n​[Pk​&lt;Pi​]
其中 [X][X][X] 表示条件 XXX 是真（111）/假（000）。
这是典型的二维偏序问题。可以用树状数组实现。
求出了 QiQ_iQi​ 取值数量，考虑求 Qi+1∼QnQ_{i+1}\sim Q_nQi+1​∼Qn​ 的排列数量。
由于已经满足 Qi&lt;PiQ_i&lt;P_iQi​&lt;Pi​，故后面 (n−i)(n-i)(n−i) 个数可以随便排列，排列数量为 (n−i)!(n-i)!(n−i)!。故在 iii 处小于 PPP 的排列数量为
(n−i)!×f(i)(n-i)!\times f(i)
(n−i)!×f(i)
将所有 iii 的贡献相加，即可得到
rnk(P)=1+∑i=1n(n−i)!×f(i)rnk(P)=1+\sum_{i=1}^{n}(n-i)!\times f(i)
rnk(P)=1+i=1∑n​(n−i)!×f(i)
倒序枚举 iii，f(i)f(i)f(i) 可以使用树状数组在 O(log⁡n)O(\log n)O(logn) 时间计算，故该算法可以在 O(nlog⁡n)O(n\log n)O(nlogn) 时间内计算某个排列的排名，被称为康托展开。
逆康托展开
排名可以逆推得到排列。
但可以发现有 n=20n=20n=20 时，全排列数量 n!=2432902008176640000&gt;1018n!=2432902008176640000&gt;10^{18}n!=2432902008176640000&gt;1018。
所以，若题目给的排名 rnk(P)≤1018rnk(P)\le 10^{18}rnk(P)≤1018（不需要高精），有 n=∣P∣≤20n=|P|\le 20n=∣P∣≤20。
于是，我们可以完成如下 nnn 次操作：

设 r0=rnk(P)−1r_0=rnk(P)-1r0​=rnk(P)−1，集合 S={1,2,⋯ ,n}S=\{1,2,\cdots,n\}S={1,2,⋯,n}。
对于第 jjj 次操作，rj←rj−1 mod (n−j)!r_j\gets r_{j-1}\bmod (n-j)!rj​←rj−1​mod(n−j)!，kj←rj−1−rj(n−j)!k_j\gets\cfrac{r_{j-1}-r_j}{(n-j)!}kj​←(n−j)!rj−1​−rj​​。
从 SSS 中取出第 (kj+1)(k_j+1)(kj​+1) 大的元素 xxx，有 Pj=xP_j=xPj​=x。从 SSS 中删除 xxx。
重复进行上面两步 nnn 次。

解释一下：
每次操作从 rj−1r_{j-1}rj−1​ 中分离出 f(j)f(j)f(j)，以 j=1j=1j=1 为例
r0=∑i=1n(n−i)!×f(i)r1←r0 mod (n−1)!=(∑i=1n(n−i)!×f(i)) mod (n−1)!=∑i=1n((n−i)!×f(i) mod (n−1)!)=((n−1)!×f(1) mod (n−1)!)+∑i=2n((n−i)!×f(i) mod (n−1)!)=∑i=2n((n−i)!×f(i) mod (n−1)!)∵f(i)=∑k=i+1n[Pk&lt;Pi]≤n−i&lt;n−i+1∴(n−i)!×f(i)&lt;(n−i)!×(n−i+1)=(n−i+1)!≤(n−1)!∴(n−i)!×f(i)&lt;(n−1)!∴(n−i)!×f(i) mod (n−1)!=(n−i)!×f(i)∴r1←∑i=2n((n−i)!×f(i) mod (n−1)!)=∑i=2n(n−i)!×f(i)r_0=\sum_{i=1}^{n}(n-i)!\times f(i)\\
\begin{aligned}
	r_1&amp;\gets r_0\bmod (n-1)!\\
	&amp;=\left(\sum_{i=1}^{n}(n-i)!\times f(i)\right)\bmod (n-1)!\\
	&amp;=\sum_{i=1}^{n}\Big((n-i)!\times f(i)\bmod (n-1)!\Big)\\
	&amp;=\Big((n-1)!\times f(1)\bmod (n-1)!\Big)+\sum_{i=2}^{n}\Big((n-i)!\times f(i)\bmod (n-1)!\Big)\\
	&amp;=\sum_{i=2}^{n}\Big((n-i)!\times f(i)\bmod (n-1)!\Big)
\end{aligned}\\
\begin{aligned}
	\because &amp; f(i)=\sum_{k=i+1}^{n}[P_k&lt;P_i]\le n-i&lt;n-i+1\\
	\therefore &amp; (n-i)!\times f(i)&lt;(n-i)!\times (n-i+1)=(n-i+1)!\le (n-1)!\\
	\therefore &amp; (n-i)!\times f(i)&lt;(n-1)!\\
	\therefore &amp; (n-i)!\times f(i)\bmod (n-1)!=(n-i)!\times f(i)\\
	\therefore &amp; r_1\gets \sum_{i=2}^{n}\Big((n-i)!\times f(i)\bmod (n-1)!\Big)=\sum_{i=2}^{n}(n-i)!\times f(i)
\end{aligned}\\
r0​=i=1∑n​(n−i)!×f(i)r1​​←r0​mod(n−1)!=(i=1∑n​(n−i)!×f(i))mod(n−1)!=i=1∑n​((n−i)!×f(i)mod(n−1)!)=((n−1)!×f(1)mod(n−1)!)+i=2∑n​((n−i)!×f(i)mod(n−1)!)=i=2∑n​((n−i)!×f(i)mod(n−1)!)​∵∴∴∴∴​f(i)=k=i+1∑n​[Pk​&lt;Pi​]≤n−i&lt;n−i+1(n−i)!×f(i)&lt;(n−i)!×(n−i+1)=(n−i+1)!≤(n−1)!(n−i)!×f(i)&lt;(n−1)!(n−i)!×f(i)mod(n−1)!=(n−i)!×f(i)r1​←i=2∑n​((n−i)!×f(i)mod(n−1)!)=i=2∑n​(n−i)!×f(i)​
有没有发现 r1r_1r1​ 与 r0r_0r0​ 几乎一致（除了 sigma 下界从 111 变成 222）？
对于 k1k_1k1​，
k1←r0−r1(n−1)!=∑i=1n(n−i)!×f(i)−∑i=2n(n−i)!×f(i)(n−1)!=(n−1)!×f(1)(n−1)!=f(1)\begin{aligned}
	k_1&amp;\gets\cfrac{r_0-r_1}{(n-1)!}\\
	&amp;=\cfrac{\sum_{i=1}^{n}(n-i)!\times f(i)-\sum_{i=2}^{n}(n-i)!\times f(i)}{(n-1)!}\\
	&amp;=\cfrac{(n-1)!\times f(1)}{(n-1)!}\\
	&amp;=f(1)
\end{aligned}
k1​​←(n−1)!r0​−r1​​=(n−1)!∑i=1n​(n−i)!×f(i)−∑i=2n​(n−i)!×f(i)​=(n−1)!(n−1)!×f(1)​=f(1)​
如此这般，我们进行了完美的迭代，每次将 f(j)f(j)f(j) 分离，从 SSS 中找出合适的 xxx。然后将 rj−1r_{j-1}rj−1​ 中 i=ji=ji=j 那项消去（simga 上界加 111）。
形式化地说，我们的处理方式使得有 rj,kjr_j,k_jrj​,kj​ 的通项公式
rj=∑i=j+1n(n−i)!×f(i)kj=f(j)r_j=\sum_{i=j+1}^{n}(n-i)!\times f(i)\\
k_j=f(j)
rj​=i=j+1∑n​(n−i)!×f(i)kj​=f(j)

SSS 可以用 vector 维护，复杂度 O(n2)O(n^2)O(n2)。因为 n≤20n\le 20n≤20，复杂度足够。
若毒瘤出题人让 rnk(P)&gt;1018rnk(P)&gt;10^{18}rnk(P)&gt;1018，也不要紧。上线段树二分维护 SSS 即可。
抽屉原理
简单情况
对于 n+1n+1n+1 个物品分为 nnn 组，必存在某组分到的物品数大于 111 个。
显然的，可以用反证法证明。
一般情况
对于 nnn 个物品分到 kkk 组，必存在某组分到的物品数大于等于 ⌈nk⌉\left\lceil\dfrac{n}{k}\right\rceil⌈kn​⌉ 个。
反证法：若每一组均小于 ⌈nk⌉\left\lceil\dfrac{n}{k}\right\rceil⌈kn​⌉ 个，则由 ⌈nk⌉&lt;nk+1\left\lceil\dfrac{n}{k}\right\rceil&lt;\dfrac{n}{k}+1⌈kn​⌉&lt;kn​+1 可得
n≤(⌈nk⌉−1)×k&lt;(nk+1−1)×k=nn\le\left(\left\lceil\dfrac{n}{k}\right\rceil-1\right)\times k&lt;\left(\dfrac{n}{k}+1-1\right)\times k=n
n≤(⌈kn​⌉−1)×k&lt;(kn​+1−1)×k=n
矛盾。
错位排列
定义
对于长度为 nnn 的排列 PPP，若 ∀1≤i≤n,Pi≠n\forall 1\le i\le n,P_i\ne n∀1≤i≤n,Pi​​=n，则称它是一个错位排列。
设 DnD_nDn​ 为长度为 nnn 的错位排列数，求 DnD_nDn​。
基于容斥原理
考虑容斥解决。我们有全集 UUU 为 nnn 的全排列（∣U∣=n!|U|=n!∣U∣=n!），nnn 个属性，第 iii 个为 Pi≠iP_i\ne iPi​​=i。
我们有（这里去掉了 1≤a(k)&lt;a(k+1)≤n1\le a(k)&lt;a(k+1)\le n1≤a(k)&lt;a(k+1)≤n 方便展示）
Dn=∣⋂i=1nSi∣=∣U∣−∣⋃i=1nSi‾∣=∣U∣+∑j=1n(−1)j∑a(k)∣⋂i=1jSa(i)‾∣(26)\begin{aligned}
	D_n&amp;=\left|\bigcap_{i=1}^{n}S_i\right|\\
	&amp;=|U|-\left|\bigcup_{i=1}^{n}\overline{S_i}\right|\\
	&amp;=|U|+\sum_{j=1}^{n}(-1)^{j}\sum_{a(k)}\left|\bigcap_{i=1}^{j}\overline{S_{a(i)}}\right|\\
\end{aligned}\tag{26}
Dn​​=∣∣∣∣∣∣​i=1⋂n​Si​∣∣∣∣∣∣​=∣U∣−∣∣∣∣∣∣​i=1⋃n​Si​​∣∣∣∣∣∣​=∣U∣+j=1∑n​(−1)ja(k)∑​∣∣∣∣∣∣​i=1⋂j​Sa(i)​​∣∣∣∣∣∣​​(26)
考虑上式的意义。可以发现 ∣⋂i=1jSa(i)‾∣\left|\bigcap_{i=1}^{j}\overline{S_{a(i)}}\right|∣∣∣∣​⋂i=1j​Sa(i)​​∣∣∣∣​ 即为满足 Pa(i)=aiP_{a(i)}=a_iPa(i)​=ai​ 的排列数量，固定的共有 jjj 位，剩下 n−jn-jn−j 为可以随意选择，于是有 (n−j)!(n-j)!(n−j)! 个排列。
同时，选择出 jjj 个 aia_iai​ 方案数为 (nj)\dbinom{n}{j}(jn​)，故
Dn=∣U∣+∑j=1n(−1)j∑a(k)∣⋂i=1jSa(i)‾∣=∣U∣+∑j=1n(−1)j(nj)(n−j)!=(−1)0(n0)n!+∑j=1n(−1)jn!j!(n−j)!×(n−j)!=∑j=0n(−1)jn!j!=n!∑j=0n(−1)jj!(26)\begin{aligned}
	D_n&amp;=|U|+\sum_{j=1}^{n}(-1)^{j}\sum_{a(k)}\left|\bigcap_{i=1}^{j}\overline{S_{a(i)}}\right|\\
	&amp;=|U|+\sum_{j=1}^{n}(-1)^{j}\dbinom{n}{j}(n-j)!\\
	&amp;=(-1)^0\dbinom{n}{0}n!+\sum_{j=1}^{n}(-1)^{j}\cfrac{n!}{j!(n-j)!}\times (n-j)!\\
	&amp;=\sum_{j=0}^{n}(-1)^j\cfrac{n!}{j!}\\
	&amp;=n!\sum_{j=0}^{n}\cfrac{(-1)^j}{j!}\\
\end{aligned}\tag{26}
Dn​​=∣U∣+j=1∑n​(−1)ja(k)∑​∣∣∣∣∣∣​i=1⋂j​Sa(i)​​∣∣∣∣∣∣​=∣U∣+j=1∑n​(−1)j(jn​)(n−j)!=(−1)0(0n​)n!+j=1∑n​(−1)jj!(n−j)!n!​×(n−j)!=j=0∑n​(−1)jj!n!​=n!j=0∑n​j!(−1)j​​(26)
另外，观察到式 (26)(26)(26) 的形式与 ex\mathrm{e}^xex 类似
ex=∑i=0∞xii!e−1=∑i=0∞(−1)ii!n!e≈n!∑i=0n(−1)ii!=Dn\begin{aligned}
	\mathrm{e}^x&amp;=\sum_{i=0}^{\infty}\cfrac{x^i}{i!}\\
	\mathrm{e}^{-1}&amp;=\sum_{i=0}^{\infty}\cfrac{(-1)^i}{i!}\\
	\cfrac{n!}{\mathrm{e}}&amp;\approx n!\sum_{i=0}^{n}\cfrac{(-1)^i}{i!}=D_n
\end{aligned}
exe−1en!​​=i=0∑∞​i!xi​=i=0∑∞​i!(−1)i​≈n!i=0∑n​i!(−1)i​=Dn​​
我们有 Dn≈n!eD_n\approx\cfrac{n!}{\mathrm{e}}Dn​≈en!​。除了美观，没什么用。
基于递推
对于 nnn 的错排，暂且假设 Pn=nP_n=nPn​=n，有以下两种方式可以一步将 PPP 改成错排

若 P1∼Pn−1P_1\sim P_{n-1}P1​∼Pn−1​ 是错排，那么任意 1≤i&lt;n1\le i&lt;n1≤i&lt;n，交换 Pi,PnP_i,P_nPi​,Pn​ 即可。iii 有 n−1n-1n−1 个可能的取值，P1∼Pn−1P_1\sim P_{n-1}P1​∼Pn−1​ 错排方案数为 Dn−1D_{n-1}Dn−1​。
若 P1∼Pn−1P_1\sim P_{n-1}P1​∼Pn−1​ 不是错排，有且只有一个位置 iii，满足 Pi=iP_i=iPi​=i，那么依然交换 Pi,PnP_i,P_nPi​,Pn​。同样的，iii 有 n−1n-1n−1 个可能的取值，而除 iii 外的其他部分为错排，方案数为 Dn−2D_{n-2}Dn−2​。

于是得到
Dn=(n−1)Dn−1+(n−1)Dn−2=(n−1)(Dn−1+Dn−2)(27)D_n=(n-1)D_{n-1}+(n-1)D_{n-2}=(n-1)(D_{n-1}+D_{n-2})\tag{27}
Dn​=(n−1)Dn−1​+(n−1)Dn−2​=(n−1)(Dn−1​+Dn−2​)(27)
另有
Dn=nDn−1+(−1)nD_n=nD_{n-1}+(-1)^{n}
Dn​=nDn−1​+(−1)n
常见数（列）
斐波那契数列
定义
斐波那契数列的定义如下：
Fi={0i=01i=1Fi−1+Fi−2otherwise(28)F_i=\begin{cases}
	0 &amp; i=0\\
	1 &amp; i=1\\
	F_{i-1}+F_{i-2} &amp; \text{otherwise}
\end{cases}\tag{28}
Fi​=⎩⎪⎪⎨⎪⎪⎧​01Fi−1​+Fi−2​​i=0i=1otherwise​(28)
同时我们有卢卡斯数列：
Li={2i=01i=1Li−1+Li−2otherwise(29)L_i=\begin{cases}
	2 &amp; i=0\\
	1 &amp; i=1\\
	L_{i-1}+L_{i-2} &amp; \text{otherwise}
\end{cases}\tag{29}
Li​=⎩⎪⎪⎨⎪⎪⎧​21Li−1​+Li−2​​i=0i=1otherwise​(29)
计算
斐波那契数列可以 O(n)O(n)O(n) 递推计算，但还有更快的计算方法。
我们有斐波那契数列的通项公式：
Fn=(1+52)n−(1−52)n5(30)F_n=\cfrac{\left(\frac{1+\sqrt{5}}{2}\right)^n-\left(\frac{1-\sqrt{5}}{2}\right)^n}{\sqrt{5}}\tag{30}
Fn​=5​(21+5​​)n−(21−5​​)n​(30)
在模意义下有意义。平常用不到。
对于卢卡斯数列：
Fn=(1+52)n+(1−52)n(31)F_n=\left(\frac{1+\sqrt{5}}{2}\right)^n+\left(\frac{1-\sqrt{5}}{2}\right)^n\tag{31}
Fn​=(21+5​​)n+(21−5​​)n(31)
当然，可以使用矩阵加速递推
[FnFn+1]=[Fn−1Fn][0111]=[F0F1][0111]n(32)\begin{bmatrix}
	F_n &amp; F_{n+1}
\end{bmatrix}
=
\begin{bmatrix}
	F_{n-1} &amp; F_{n}
\end{bmatrix}
\begin{bmatrix}
	0 &amp; 1\\
	1 &amp; 1
\end{bmatrix}
=
\begin{bmatrix}
	F_0 &amp; F_1
\end{bmatrix}
\begin{bmatrix}
	0 &amp; 1\\
	1 &amp; 1
\end{bmatrix}^n
\tag{32}
[Fn​​Fn+1​​]=[Fn−1​​Fn​​][01​11​]=[F0​​F1​​][01​11​]n(32)
于是运用矩阵快速幂，我们可以 O(log⁡n)O(\log n)O(logn) 时间内计算斐波那契数列。
也可以使用倍增的技巧。考虑斐波那契数列的递推式，对它进行拓展
Fi+1=Fi+Fi−1Fi+2=Fi+1+Fi=2Fi+Fi−1Fi+3=Fi+2+Fi+1=3Fi+2Fi−1Fi+4=Fi+3+Fi+2=5Fi+3Fi−1Fi+5=Fi+4+Fi+3=8Fi+5Fi−1\begin{aligned}
	F_{i+1}&amp;=F_{i}+F_{i-1}\\
	F_{i+2}=F_{i+1}+F_{i}&amp;=2F_{i}+F_{i-1}\\
	F_{i+3}=F_{i+2}+F_{i+1}&amp;=3F_{i}+2F_{i-1}\\
	F_{i+4}=F_{i+3}+F_{i+2}&amp;=5F_{i}+3F_{i-1}\\
	F_{i+5}=F_{i+4}+F_{i+3}&amp;=8F_{i}+5F_{i-1}\\
\end{aligned}
Fi+1​Fi+2​=Fi+1​+Fi​Fi+3​=Fi+2​+Fi+1​Fi+4​=Fi+3​+Fi+2​Fi+5​=Fi+4​+Fi+3​​=Fi​+Fi−1​=2Fi​+Fi−1​=3Fi​+2Fi−1​=5Fi​+3Fi−1​=8Fi​+5Fi−1​​
可得：
Fi+j=Fj+1Fi+FjFi−1F2k=Fk+1Fk+FkFk−1=FkFk+1+Fk(Fk+1−Fk)=Fk(2Fk+1−Fk)F2k+1=Fk+1Fk+1+FkFk−1+1=Fk+12+Fk2(33)\begin{aligned}
	F_{i+j}&amp;=F_{j+1}F_{i}+F_{j}F_{i-1}\\
	F_{2k}&amp;=F_{k+1}F_{k}+F_{k}F_{k-1}=F_{k}F_{k+1}+F_{k}(F_{k+1}-F_{k})=F_{k}(2F_{k+1}-F_{k})\\
	F_{2k+1}&amp;=F_{k+1}F_{k+1}+F_{k}F_{k-1+1}=F_{k+1}^2+F_{k}^2
\end{aligned}\tag{33}
Fi+j​F2k​F2k+1​​=Fj+1​Fi​+Fj​Fi−1​=Fk+1​Fk​+Fk​Fk−1​=Fk​Fk+1​+Fk​(Fk+1​−Fk​)=Fk​(2Fk+1​−Fk​)=Fk+1​Fk+1​+Fk​Fk−1+1​=Fk+12​+Fk2​​(33)
std::pair&lt;int,int&gt; fib(int n)&#123;    if(!n)return &#123;0,1&#125;;    auto r=fib(n&gt;&gt;1);    int c=p.first*(2*p.second-p.first),        d=p.first*p.first+p.second*p.second;    return (n&amp;1)?&#123;d,c+d&#125;:&#123;c+d&#125;;&#125;
性质

Fn−1Fn+1−Fn2=(−1)nF_{n-1}F_{n+1}-F_n^2=(-1)^nFn−1​Fn+1​−Fn2​=(−1)n；
(33)(33)(33) 式；
∀k∈N,Fn∣Fnk\forall k\in\Bbb{N},F_n|F_{nk}∀k∈N,Fn​∣Fnk​；
∀Fa∣Fb,a∣b\forall F_a|F_b,a|b∀Fa​∣Fb​,a∣b；
gcd⁡(Fa,Fb)=Fgcd⁡(a,b)\gcd(F_a,F_b)=F_{\gcd(a,b)}gcd(Fa​,Fb​)=Fgcd(a,b)​；
以斐波那契数列相邻两项作为输入会使欧几里德算法达到最坏复杂度。

卡特兰数
相关问题（应用）
卡特兰数列 HnH_nHn​ 一般应用于以下基本问题：

将大小为 nnn 的问题分解为规模之和为 n−1n-1n−1 的两个子问题。比如二叉树的构造方案数、不相交弦本质不同方案数、凸包三角形划分方案数等。

对于另一种看似也很基本的问题，其实可以转化为上述基本问题：

可以抽象为平面直角坐标系上行走的问题。具体的，从 (0,0)(0,0)(0,0) 走到 (2n,0)(2n,0)(2n,0)，每次从 (x,y)(x,y)(x,y) 向右上 (x+1,y+1)(x+1,y+1)(x+1,y+1) 或右下 (x+1,y−1)(x+1,y-1)(x+1,y−1) 走，且不走到 xxx 轴下方，的路径方案数。如出栈序列数、买票找零等。以出栈序列数为例，可以证明出栈序列与操作序列是一一对应的，而操作序列中入栈操作可以视为向右上走，出栈可以视为向右下走，横坐标对应时间，纵坐标对应栈的大小，触碰 xxx 轴对应栈空。

如何将这种问题（2）转化为基本问题（1）呢？



对于这种问题，我们假设路径在 (2i,0)(2i,0)(2i,0) 处第一次触碰 xxx 轴（除起点外，可以是终点）。为了保证第一次，从 (0,0)(0,0)(0,0) 到 (2i,0)(2i,0)(2i,0) 的路径不能触碰 xxx 轴。怎样保证呢？考虑先从 (0,0)(0,0)(0,0) 走到 (1,1)(1,1)(1,1)，然后保证路径不在 y=1y=1y=1 下方，即不会触碰 xxx 轴，走到 (2i−1,1)(2i-1,1)(2i−1,1)。然后在从 (2i−1,1)(2i-1,1)(2i−1,1) 走到 (2i,0)(2i,0)(2i,0)，完成第一次触碰。接下来可以只需不走到 xxx 轴下方，从 (2i,0)(2i,0)(2i,0) 走到 (2n,0)(2n,0)(2n,0) 即可。
于是我们得到第一部分路径方案数为 Hi−1H_{i-1}Hi−1​，第二部分则为 Hn−iH_{n-i}Hn−i​。根据乘法原理和加法原理，我们枚举每个 iii 即可得到
Hn={1n=0,1∑i=1nHi−1Hn−iotherwise(34)H_n=\begin{cases}
	1&amp;n=0,1\\
	\sum\limits_{i=1}^{n}H_{i-1}H_{n-i}&amp;\text{otherwise}
\end{cases}\tag{34}
Hn​=⎩⎪⎨⎪⎧​1i=1∑n​Hi−1​Hn−i​​n=0,1otherwise​(34)
而基本问题（1）的方案数显然也是上式。于是我们就得到了二问题等价。(34)(34)(34) 式为卡特兰数的一个递推式。
注：对于问题（2），其他资料中常有等价描述：设非降路径是指只能向上或向右走的路径，求不走到对角线 y=xy=xy=x 上方（但可以触碰）的情况下从 (0,0)(0,0)(0,0) 到达 (n,n)(n,n)(n,n) 的可能路径数。可以通过旋转、轴对称发现二描述等价。本文为了方便思考、与出栈序列问题相对应，采用了不同的描述方式。
公式
我们考虑问题（2）的组合意义。若不考虑“不走到 xxx 轴下方”这一限制条件，我们有答案 (2nn)\dbinom{2n}{n}(n2n​)，即在 2n2n2n 步中，选出 nnn 步向右上，另外 nnn 步向右下。
考虑如何处理走到 xxx 轴下方的情况。对于所有不合法路径（即走到 xxx 轴下方的路径），我们将第一次走到 xxx 轴下方之后的路径，即第一次触碰 y=−1y=-1y=−1 之后的路径，以 y=−1y=-1y=−1 为对称轴翻转。之前的路径不变。可以证明，翻转后的路径均可以和原路径一一对应。



如图，虚线为翻转前的不合法路径，点线为翻转后的路径，点划线则为二者公共部分。
经过观察，发现翻转后的路径从 (0,0)(0,0)(0,0) 走到 (2n,−2)(2n,-2)(2n,−2)。即在 2n2n2n 步中选出 n−1n-1n−1 步向右上，其他向右下的路径。方案数为 (2nn−1)\dbinom{2n}{n-1}(n−12n​)。将全部方案减去不合法方案，即得到全部合法方案数为：
Hn=(2nn)−(2nn−1)(35)H_n=\dbinom{2n}{n}-\dbinom{2n}{n-1}\tag{35}
Hn​=(n2n​)−(n−12n​)(35)
进一步地，
Hn=(2nn)−(2nn−1)=(2n)!n!n!−(2n!)(n−1)!(n+1)!Let t=(n−1)!=(2n)![1n2t2−1n(n+1)t2]=(2n)!t2n(1n−1n+1)=(2n)!t2n×n+1−nn(n+1)=(2n)!t2n2(n+1)=(2n)!n!n!(n+1)Hn=(2nn)n+1(36)\begin{aligned}
	H_n&amp;=\dbinom{2n}{n}-\dbinom{2n}{n-1}\\
	&amp;=\cfrac{(2n)!}{n!n!}-\cfrac{(2n!)}{(n-1)!(n+1)!}\\
	&amp;\text{Let $t=(n-1)!$}\\
	&amp;=(2n)!\left[\cfrac{1}{n^2t^2}-\cfrac{1}{n(n+1)t^2}\right]\\
	&amp;=\cfrac{(2n)!}{t^2n}\left(\cfrac{1}{n}-\cfrac{1}{n+1}\right)\\
	&amp;=\cfrac{(2n)!}{t^2n}\times\cfrac{n+1-n}{n(n+1)}\\
	&amp;=\cfrac{(2n)!}{t^2n^2(n+1)}\\
	&amp;=\cfrac{(2n)!}{n!n!(n+1)}\\
	H_n&amp;=\cfrac{\dbinom{2n}{n}}{n+1}
\end{aligned}\tag{36}
Hn​Hn​​=(n2n​)−(n−12n​)=n!n!(2n)!​−(n−1)!(n+1)!(2n!)​Let t=(n−1)!=(2n)![n2t21​−n(n+1)t21​]=t2n(2n)!​(n1​−n+11​)=t2n(2n)!​×n(n+1)n+1−n​=t2n2(n+1)(2n)!​=n!n!(n+1)(2n)!​=n+1(n2n​)​​(36)
更进一步，
Hn=(2n)!t2n2(n+1)=(2n−2)!(2n)(2n−1)(n−1)!(n−1)!n2(n+1)=(2n−2n−1)n×2n(2n−1)n(n+1)Hn=Hn−1(4n−2)n+1(37)\begin{aligned}
	H_n&amp;=\cfrac{(2n)!}{t^2n^2(n+1)}\\
	&amp;=\cfrac{(2n-2)!(2n)(2n-1)}{(n-1)!(n-1)!n^2(n+1)}\\
	&amp;=\cfrac{\dbinom{2n-2}{n-1}}{n}\times\cfrac{2n(2n-1)}{n(n+1)}\\
	H_n&amp;=\cfrac{H_{n-1}(4n-2)}{n+1}
\end{aligned}\tag{37}
Hn​Hn​​=t2n2(n+1)(2n)!​=(n−1)!(n−1)!n2(n+1)(2n−2)!(2n)(2n−1)​=n(n−12n−2​)​×n(n+1)2n(2n−1)​=n+1Hn−1​(4n−2)​​(37)
这便是最简单的递推式。至此，所有卡特兰数的公式证毕。
第二类斯特林数
第二类斯特林数，也称斯特林子集数，记做 {nk}\begin{Bmatrix}n\\ k\end{Bmatrix}{nk​}，表示将 nnn 个互不相同的元素，划分为 kkk 个相同的非空子集的方案数。
递推式
{[n=0]k=0{nk}={n−1k−1}+k{n−1k}otherwise(38)\begin{cases}
	[n=0]&amp;k=0\\
	\begin{Bmatrix}n\\ k\end{Bmatrix}=\begin{Bmatrix}n-1\\ k-1\end{Bmatrix}+k\begin{Bmatrix}n-1\\ k\end{Bmatrix}&amp;\text{otherwise}
\end{cases}\tag{38}
⎩⎪⎨⎪⎧​[n=0]{nk​}={n−1k−1​}+k{n−1k​}​k=0otherwise​(38)
可以使用组合意义证明。对于第 nnn 个物品，

若新开一个集合，则方案数为 {n−1k−1}\begin{Bmatrix}n-1\\ k-1\end{Bmatrix}{n−1k−1​}；
若将其放入现有的 kkk 个集合（中的任意一个），方案数为 k{n−1k}k\begin{Bmatrix}n-1\\ k\end{Bmatrix}k{n−1k​}。

通项公式
第一类斯特林数
参考

https://oi-wiki.org/math/combinatorics/combination/
https://www.cnblogs.com/GXZlegend/p/11407185.html

]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>忏悔录</title>
    <url>/confessions/</url>
    <content><![CDATA[
  40fff3a5cf27b77ac08956115c0713292362f196ad6752227a761f63c2d08a793009c47c139cf0c527f103801c47c6abfc8b04739520c8d78887e150a582dce5a865bd08cbd1db57a396741d55bbd123944383cd5e8564cbfcf9f34ae0d954bb95ce7cf11e959daee261f87a9897a96a90184b49f87634cd89e042b33f881705037d725d61324738690e291c3830f66bb1d9625724f3906eaeef0394d0a3c61d496c5841da85e84f417fe6e4db51744b376c4b7346d09fb51a2afd0cb0f6b8370203bc593361f51fe690a06ad7f572e8b9c39c6393e79c808e53be4e440aece0bcc7e9eb6b78c4c04f48e97171fbcbc102aede42ee1c34019521108cc43aae8194c3a9e7a508c165297700d0b8a2790c
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.

Quick Start
Create a new post
$ hexo new &quot;My New Post&quot;
More info: Writing
Run server
$ hexo server
More info: Server
Generate static files
$ hexo generate
More info: Generating
Deploy to remote sites
$ hexo deploy
More info: Deployment
]]></content>
  </entry>
  <entry>
    <title>高中数学</title>
    <url>/hs-math/</url>
    <content><![CDATA[对数
对数是乘方的逆运算，与除是乘的逆运算类似。所以，所有对数的性质及推导过程都可以类比除法。

具体而言：
a+a+⋯+a⏞ba=a×ba=b,a×a×⋯×a⏞log⁡ab=alog⁡ab=b\begin{array}{cc}
	\overbrace{a+a+\cdots+a}^{\frac{b}{a}}=a\times\dfrac{b}{a}=b, &amp; \overbrace{a\times a\times\cdots\times a}^{\log_ab}=a^{\log_ab}=b
\end{array}
a+a+⋯+a​ab​​=a×ab​=b,​a×a×⋯×a​loga​b​=aloga​b=b​
1a(M+N)=1a(a×1aM+a×1aN)log⁡a(M×N)=log⁡a(alog⁡aM×alog⁡aN)=1a(a×(1aM+1aN))=log⁡a(a(log⁡aM+log⁡aN))=1aM+1aN=log⁡aM+log⁡aN\begin{aligned}
	\dfrac{1}{a}(M+N)&amp;=\dfrac{1}{a}\left(a\times\dfrac{1}{a}M+a\times\dfrac{1}{a}N\right)&amp;\log_a(M\times N)&amp;=\log_a{\left(a^{\log_aM}\times a^{\log_aN}\right)}\\
	&amp;=\dfrac{1}{a}\left(a\times\left(\dfrac{1}{a}M+\dfrac{1}{a}N\right)\right)&amp;&amp;=\log_a{\left(a^{\left(\log_aM+\log_aN\right)}\right)}\\
	&amp;=\dfrac{1}{a}M+\dfrac{1}{a}N&amp;&amp;=\log_aM+\log_aN
\end{aligned}
a1​(M+N)​=a1​(a×a1​M+a×a1​N)=a1​(a×(a1​M+a1​N))=a1​M+a1​N​loga​(M×N)​=loga​(aloga​M×aloga​N)=loga​(a(loga​M+loga​N))=loga​M+loga​N​
这里的类比没有那么完美，是因为乘法和乘方的分配律不同：
a×(b+c)=a×b+a×c,ab+c=ab×ac\begin{array}{cc}
	a\times(b+c)=a\times b+a\times c, &amp; a^{b+c}=a^b\times a^c
\end{array}
a×(b+c)=a×b+a×c,​ab+c=ab×ac​
同时注意，乘方不满足交换律，故对数同样不满足交换律。
向量数量积
我们希望定义一个向量之间的运算，使得其只与相对位置有关，且满足分配律。
该运算的引用场景例如计算力做的功。显然通过合力做功或分段做功可以得出分配律。因为空间是均匀的，故无论如何旋转，做的功大小相同，只与相对位置有关。
不妨称其为向量的数量积，记作 a⋅b\boldsymbol{a}\cdot\boldsymbol{b}a⋅b。
先说明其一个重要性质：若 a⊥b\boldsymbol{a}\perp\boldsymbol{b}a⊥b，那么 a⋅b=0\boldsymbol{a}\cdot\boldsymbol{b}=0a⋅b=0。
a⊥b  ⟹  a⊥−b\boldsymbol{a}\perp\boldsymbol{b}\implies\boldsymbol{a}\perp-\boldsymbol{b}a⊥b⟹a⊥−b 故 a⋅b=a⋅−b  ⟹  −(a⋅b)=a⋅b=0\boldsymbol{a}\cdot\boldsymbol{b}=\boldsymbol{a}\cdot-\boldsymbol{b}\implies-(\boldsymbol{a}\cdot\boldsymbol{b})=\boldsymbol{a}\cdot\boldsymbol{b}=0a⋅b=a⋅−b⟹−(a⋅b)=a⋅b=0。
计算 a⋅b\boldsymbol{a}\cdot\boldsymbol{b}a⋅b 时将 a,b\boldsymbol{a},\boldsymbol{b}a,b 正交分解，
a⋅b=(a∥+a⊥)⋅(b∥+b⊥)=a∥b∥+a∥b⊥+a⊥b∥+a⊥b⊥=a∥b∥+a⊥b⊥\begin{aligned}
	\boldsymbol{a}\cdot\boldsymbol{b}&amp;=(\boldsymbol{a}_\parallel+\boldsymbol{a}_\perp)\cdot(\boldsymbol{b}_\parallel+\boldsymbol{b}_\perp)\\
	&amp;=\boldsymbol{a}_\parallel\boldsymbol{b}_\parallel+\boldsymbol{a}_\parallel\boldsymbol{b}_\perp+\boldsymbol{a}_\perp\boldsymbol{b}_\parallel+\boldsymbol{a}_\perp\boldsymbol{b}_\perp\\
	&amp;=\boldsymbol{a}_\parallel\boldsymbol{b}_\parallel+\boldsymbol{a}_\perp\boldsymbol{b}_\perp\\
\end{aligned}
a⋅b​=(a∥​+a⊥​)⋅(b∥​+b⊥​)=a∥​b∥​+a∥​b⊥​+a⊥​b∥​+a⊥​b⊥​=a∥​b∥​+a⊥​b⊥​​
若 a=(xa,ya),b=(xb,yb)\boldsymbol{a}=(x_a,y_a),\boldsymbol{b}=(x_b,y_b)a=(xa​,ya​),b=(xb​,yb​)，则 a⋅b=xaxb+yayb\boldsymbol{a}\cdot\boldsymbol{b}=x_ax_b+y_ay_ba⋅b=xa​xb​+ya​yb​。
同时若以 aaa 为基分解 b=b∥+b⊥b=b_\parallel+b_\perpb=b∥​+b⊥​，则可以得到 a⋅b=∣a∣∣b∣cos⁡⟨a,b⟩\boldsymbol{a}\cdot\boldsymbol{b}=|\boldsymbol{a}||\boldsymbol{b}|\cos\lang\boldsymbol{a},\boldsymbol{b}\ranga⋅b=∣a∣∣b∣cos⟨a,b⟩。
余弦定理
A&lt;------B^   c   ^ \     / b\  a/   \ /    C
c2=(b−a)2c2=b2−2ba+a2∣c∣2=∣a∣2+∣b∣2−2∣a∣∣b∣cos⁡⟨a,b⟩\begin{aligned}
	\boldsymbol{c}^2&amp;=(\boldsymbol{b}-\boldsymbol{a})^2\\
	\boldsymbol{c}^2&amp;=\boldsymbol{b}^2-2\boldsymbol{b}\boldsymbol{a}+\boldsymbol{a}^2\\
	|\boldsymbol{c}|^2&amp;=|\boldsymbol{a}|^2+|\boldsymbol{b}|^2-2|\boldsymbol{a}||\boldsymbol{b}|\cos\lang\boldsymbol{a},\boldsymbol{b}\rang
\end{aligned}
c2c2∣c∣2​=(b−a)2=b2−2ba+a2=∣a∣2+∣b∣2−2∣a∣∣b∣cos⟨a,b⟩​
]]></content>
      <tags>
        <tag>whk</tag>
      </tags>
  </entry>
  <entry>
    <title>高中物理</title>
    <url>/hs-phy/</url>
    <content><![CDATA[运动学
概念
参考系 描述物体运动的参照物。可取任意物体，假定其不动。不同参考系结果可能不同。
质点 代替物体的具有质量的点。理想化物理模型。问题与形状大小有关时不可视为质点。

时间 一段时间。常见表达：第 nnn 秒内、前 nnn 秒。
时刻 一个瞬间。常见表达：第 nnn 秒初 / 末。
位移 物体位置变化，矢量。
路程 物体运动轨迹长度，标量。
标量 只有大小的量。
矢量 有大小和方向的量。
平均速度 物体一段时间内位移与时间长度之比，矢量。
瞬时速度 物体某时刻的速度，矢量。
瞬时速率 瞬时速度的大小，标量。
注意平均速率不是平均速度的大小。
加速度 物体一段时间内速度变化与时间长度之比，矢量。
a=vt−v0t(1)a=\dfrac{v_t-v_0}{t}\tag{1}
a=tvt​−v0​​(1)
上式为平均加速度。
匀变速直线运动
由 (1)(1)(1) 得
vt=v0+at(2)v_t=v_0+at\tag{2}
vt​=v0​+at(2)


根据梯形面积可得
s=12(v0+vt)t(3)s=\dfrac{1}{2}(v_0+v_t)t\tag{3}
s=21​(v0​+vt​)t(3)
将 (2)(2)(2) 带入 (3)(3)(3) 可得
s=vtt+12at2(4)s=v_tt+\dfrac{1}{2}at^2\tag{4}
s=vt​t+21​at2(4)
上式几何意义如下图。


(2),(3)(2),(3)(2),(3) 变形，相乘
(vt−v0)(vt+v0)=at×2st2as=vt2−v02(5)(v_t-v_0)(v_t+v_0)=at\times\dfrac{2s}{t}\\
2as=v_t^2-v_0^2\tag{5}
(vt​−v0​)(vt​+v0​)=at×t2s​2as=vt2​−v02​(5)
匀速圆周运动
线速度
v=stv=\dfrac{s}{t}
v=ts​
角速度
ω=φtv=rω\omega=\dfrac{\varphi}{t}\\
v=r\omega
ω=tφ​v=rω
功能
（机械）功
W=F⋅s=∣F∣∣s∣cos⁡⟨F,s⟩=Fscos⁡αW=\boldsymbol{F}\cdot\boldsymbol{s}=|\boldsymbol{F}||\boldsymbol{s}|\cos\lang\boldsymbol{F},\boldsymbol{s}\rang=Fs\cos\alpha
W=F⋅s=∣F∣∣s∣cos⟨F,s⟩=Fscosα
功率
P=Wt=Fst=FvP=\dfrac{W}{t}=\dfrac{Fs}{t}=Fv
P=tW​=tFs​=Fv
动能
Ek=12mv2E_\mathrm{k}=\dfrac{1}{2}mv^2
Ek​=21​mv2
动能定理
W=Fs=ma×v22−v122a=12mv22−12mv12=Ek2−Ek1W=Fs=ma\times\dfrac{v_2^2-v_1^2}{2a}=\dfrac{1}{2}mv_2^2-\dfrac{1}{2}mv_1^2=E_{\mathrm{k}2}-E_{\mathrm{k}1}
W=Fs=ma×2av22​−v12​​=21​mv22​−21​mv12​=Ek2​−Ek1​
重力势能
Ep=mghE_\mathrm{p}=mgh
Ep​=mgh
机械能守恒定律
E=Ep+EkE=E_\mathrm{p}+E_\mathrm{k}
E=Ep​+Ek​
]]></content>
      <tags>
        <tag>whk</tag>
      </tags>
  </entry>
  <entry>
    <title>最大流与最小割</title>
    <url>/max_flow-min_cut/</url>
    <content><![CDATA[前言
笔者为网络流初学者，可能文章有诸多不足，请指出。
亮点在于 vector 存图、反边作用的解释、代码的注释。
初学者可暂时跳过下面这段“关于 vector 存图”，学完算法在回来看。

关于 vector 存图
很多网上的资料（视频、题解）的最大流算法为了方便找反边，都使用了链式前向星。
但是！
vector 党表示不服！
于是在进行学习后，笔者归纳出了两种 vector 存图并快速找反边的方法。
代码。
存储反边编号
一般 vector 实现邻接表是形如这样的：（在最大流相关算法中）
struct edge&#123;    int v,w;&#125;;vector&lt;edge&gt; e[N];inline void addedge(int u,int v,int w)&#123;    e[u].push_back(&#123;v,w&#125;);    e[v].push_back(&#123;u,0&#125;);&#125;
但是这种存储方法无法快速找到反边。
考虑在结构体 edge 中添加一个信息 x：
struct edge&#123;    int v,w,x;&#125;;
表示反边为 e[v][x]。那么加边时也相应的需要修改：
inline void addedge(int u,int v,int w)&#123;    e[u].push_back(&#123;v,w,int(e[v].size())&#125;);    e[v].push_back(&#123;u,0,int(e[u].size()-1)&#125;);&#125;
这样就可以快速实现找反边操作了。（关于为什么是 int(e[v].size())、int(e[u].size()-1) 请自行思考。）
注意，EK 算法中 int pre[N] 数组则需要改成 pair&lt;int,int&gt; pre[N]，分别表示来自 first 号点和它的 second 号边。
将边存入池子并保存编号
我们可以使用两个 vector 实现更方便的存边方式：
vector&lt;edge&gt; es;vector&lt;int&gt; e[N];
其中 es 存了所有边，e[u] 中存 u 的所有出边在 es 中的编号。
于是，如果我们需要知道边 e[u][i] 的信息，只需要访问 es[e[u][i]]。
而 e[u][i] 的反边即为 e[u][i]^1，与传统链式前向星的访问反边方式类似。
存边时：
e[u].push_back(es.size());es.push_back(&#123;v,ll(w)&#125;);e[v].push_back(es.size());es.push_back(&#123;u,0ll&#125;);

正文开始。
网络流基础知识
以下记 ∣V∣=n,∣E∣=m|V|=n,|E|=m∣V∣=n,∣E∣=m。
网络（network，GGG），即一种特殊的带权有向图 G=(V,E)G=(V,E)G=(V,E)，特别的是，其有特殊的源（source）sss、汇（target）ttt 二点。一般认为 s,ts,ts,t 是固定的两点。
流（flow，fff），为 E→RE\to\Bbb{R}E→R 的函数，其满足 ∀u≠s∧u≠t,∑wf(w,u)=∑vf(u,v)\forall u\ne s\land u\ne t,\sum_{w}f(w,u)=\sum_{v}f(u,v)∀u​=s∧u​=t,∑w​f(w,u)=∑v​f(u,v)，即除 s,ts,ts,t 外的点满足进入 uuu 的流等于出 uuu 的流。如果 (u,v)∉E(u,v)\notin E(u,v)∈/​E 即边 (u,v)(u,v)(u,v) 不存在，我们默认 f(u,v)=0f(u,v)=0f(u,v)=0。（如果一定要较真的话你也可以定义其为 V×V→RV\times V\to\Bbb{R}V×V→R 的函数，然后分类讨论。）
净流量（fff），这里使用了与流同样的记号，为 V→RV\to\Bbb{R}V→R 的函数，定义为 f(u)=∑vf(u,v)−∑wf(w,u)f(u)=\sum_{v}f(u,v)-\sum_{w}f(w,u)f(u)=∑v​f(u,v)−∑w​f(w,u)。容易发现，由于流的性质，除 s,ts,ts,t 外的点的净流量均为 000。由于 sss 流出的量最终必须流向 ttt，故有 f(s)=−f(t)f(s)=-f(t)f(s)=−f(t)
一个流的流量（value，∣f∣|f|∣f∣），定义为 sss 的净流量，即 ∣f∣=f(s)=−f(t)|f|=f(s)=-f(t)∣f∣=f(s)=−f(t)。
容量（capacity，ccc），即普通带权有向图的边权，为 E→R≥0E\to\Bbb{R}_{\ge 0}E→R≥0​ 的函数，一般由题目给出。我们说一个流是合法的当前仅当 ∀e∈E,0≤f(e)≤c(e)\forall e\in E,0\le f(e)\le c(e)∀e∈E,0≤f(e)≤c(e)。若 e∈Ee\in Ee∈E 满足 f(e)=c(e)f(e)=c(e)f(e)=c(e)，我们说它是满流的。同样的，若 e∈Ee\in Ee∈E 满足 f(e)=0f(e)=0f(e)=0，我们说它是空流的。如果 (u,v)∉E(u,v)\notin E(u,v)∈/​E 即边 (u,v)(u,v)(u,v) 不存在，我们定义 c(u,v)=0c(u,v)=0c(u,v)=0。
最大流问题（maximum flow problem），即对于任意合法的流 fff，求出 max⁡∣f∣\max|f|max∣f∣，此时 fff 称为 GGG 的最大流。
割（cut，(S,T)(S,T)(S,T)），是一种点集 VVV 的划分，即 S∪T=V,S∩T=∅S\cup T=V,S\cap T=\varnothingS∪T=V,S∩T=∅ 且满足 s∈S,t∈Ts\in S,t\in Ts∈S,t∈T。
一个割的容量（capacity，∣∣S,T∣∣||S,T||∣∣S,T∣∣），定义为
∣∣S,T∣∣=∑u∈S,v∈Tc(u,v)||S,T||=\sum_{\mathclap{u\in S,v\in T}}c(u,v)
∣∣S,T∣∣=u∈S,v∈T​∑​c(u,v)
即从 S→TS\to TS→T 的连边的容量的和。注意没有 T→ST\to ST→S 的连边！这里我们再次用了“容量（capacity）”这个词，故需区分其与边的容量。
最小割问题（minimum cut problem），即对于任意割 (S,T)(S,T)(S,T)，求出 min⁡∣∣S,T∣∣\min||S,T||min∣∣S,T∣∣，此时 (S,T)(S,T)(S,T) 称为 GGG 的最小割。

以上是冷冰冰的定义，可以直接生硬地理解，也可以用现实中的例子如水流来理解。看上去很长，但这里需要强调定义的重要性。笔者发现，网上资料的许多定义是不正确的。结合证明时，读者往往会不知所措。
如有资料称 fff 为 E→RE\to\Bbb{R}E→R 的函数，却又说“对于每条边 (u,v)(u,v)(u,v)，我们都新建一条反向边 (v,u)(v,u)(v,u)。我们约定 f(u,v)=−f(v,u)f(u,v)=-f(v,u)f(u,v)=−f(v,u)”。明明 (v,u)∉E(v,u)\notin E(v,u)∈/​E，却将 (v,u)(v,u)(v,u) 代入了 fff。那么 (v,u)(v,u)(v,u) 到底在不在 EEE 中？甚至说 “f(v,u)f(v,u)f(v,u) 的绝对值是无关紧要的”，简直胡扯！这样搪塞其词，只会使读者感到困惑。
很多资料并没有考虑 (u,v)(u,v)(u,v)、(v,u)(v,u)(v,u) 均存在于 GGG 中的情况（即 (u,v)∈E∧(v,u)∈E(u,v)\in E\land (v,u)\in E(u,v)∈E∧(v,u)∈E）。这种情况下，再按照上面的“约定”，f(v,u)f(v,u)f(v,u) 的值到底应该是多少？本文中，我们假定没有这种情况，如果有，这种情况也很好处理——建立中继点即可。事实上，代码实现中我们甚至不需要管这种情况，因为对于每条 GGG 上的边，我们都有其专属的反向边。换句话说，实现时可能有两条 (v,u)(v,u)(v,u)，就不存在形式化表达中“到底是那条 (v,u)(v,u)(v,u)”的问题。
Ford–Fulkerson 增广
Ford–Fulkerson 增广是一种计算最大流的策略。该方法运用了带反悔的贪心，通过寻找增广路来更新并求解最大流。对于此策略的正确性，将在下一节“最大流最小割定理”中讲解。
定义
剩余容量（residual capacity，cf(u,v)c_f(u,v)cf​(u,v)），为一个 V×V→RV\times V\to\Bbb{R}V×V→R 的函数，定义为
cf(u,v)={c(u,v)−f(u,v)if (u,v)∈Ef(v,u)if (v,u)∈E0otherwisec_f(u,v)=
\begin{cases}
	c(u,v)-f(u,v)&amp;\text{if $(u,v)\in E$}\\
	f(v,u)&amp;\text{if $(v,u)\in E$}\\
	0&amp;\text{otherwise}
\end{cases}
cf​(u,v)=⎩⎪⎪⎨⎪⎪⎧​c(u,v)−f(u,v)f(v,u)0​if (u,v)∈Eif (v,u)∈Eotherwise​
残量网络（residual graph，GfG_fGf​），定义为 Gf=(V,Ef),Ef={(u,v)∣cf(u,v)&gt;0}G_f=(V,E_f),E_f=\{(u,v)|c_f(u,v)&gt;0\}Gf​=(V,Ef​),Ef​={(u,v)∣cf​(u,v)&gt;0}。即原网络中的点和剩余容量 &gt;0&gt;0&gt;0 的边构成的图。由于反向边的存在，故不满足 Ef⊆EE_f\subseteq EEf​⊆E。
增广路（augmenting path，PPP），为 GfG_fGf​ 上一条 s→ts\to ts→t 的路径，由于该路径上所有边 (u,v)(u,v)(u,v) 的剩余容量 cf(u,v)&gt;0c_f(u,v)&gt;0cf​(u,v)&gt;0，所以这些边都可以增加流量（或退去反向边的流量），即可以进行增广：设 Δ=min⁡(u,v)∈Pcf(u,v)\Delta=\min_{(u,v)\in P}c_f(u,v)Δ=min(u,v)∈P​cf​(u,v)，增广后的流为 f′f&#x27;f′，有
f′(u,v)={f(u,v)+Δif (u,v)∈Pf(u,v)−Δif (v,u)∈P0otherwisef&#x27;(u,v)=
\begin{cases}
	f(u,v)+\Delta&amp;\text{if $(u,v)\in P$}\\
	f(u,v)-\Delta&amp;\text{if $(v,u)\in P$}\\
	0&amp;\text{otherwise}
\end{cases}
f′(u,v)=⎩⎪⎪⎨⎪⎪⎧​f(u,v)+Δf(u,v)−Δ0​if (u,v)∈Pif (v,u)∈Potherwise​
可以证明增广后 f′f&#x27;f′ 也是合法的。同时 ∣f′∣=∣f∣+F&gt;∣f∣|f&#x27;|=|f|+F&gt;|f|∣f′∣=∣f∣+F&gt;∣f∣，故 f′f&#x27;f′ 更优。可以得到，如果在 GfG_fGf​ 上存在 s→ts\to ts→t 的路径，那么 fff 不是最大流。
为什么要使 EfE_fEf​ 中存在反向边？
注意到 Ford–Fulkerson 增广属于贪心，但反向边支持反悔（如果增广 (v,u)(v,u)(v,u)，即减少了 f(u,v)f(u,v)f(u,v)，于是可以做到反悔）。
可以通过以下例子理解：

其中 s=1,t=6s=1,t=6s=1,t=6，所有边的容量均为 111。
假如第一次 bfs 选择了增广路 1→2→4→61\to 2\to 4\to 61→2→4→6，那么如果没有反边，残量网络中 s,ts,ts,t 就不连通了，算法结束，求出的最大流量为 111。
但显然如果增广 1→2→5→6,1→3→4→61\to 2\to 5\to 6,1\to 3\to 4\to 61→2→5→6,1→3→4→6 这两条路，那么最大流量为 222，优于 111。
如果将反边进行操作，增广完 1→2→4→61\to 2\to 4\to 61→2→4→6，cf(2,4)=1−1=0,cf(4,2)=1c_f(2,4)=1-1=0,c_f(4,2)=1cf​(2,4)=1−1=0,cf​(4,2)=1，也就是说，边 (2,4)(2,4)(2,4) 虽然不再在残量网络中，但 (4,2)(4,2)(4,2) 被添加进了残量网络。下一次 bfs 时，就可以通过 1→3→4→2→5→61\to 3\to 4\to 2\to 5\to 61→3→4→2→5→6 进行增广了。这样，(2,4),(4,2)(2,4),(4,2)(2,4),(4,2) 的加流相互抵消，等价于增广 1→2→5→6,1→3→4→61\to 2\to 5\to 6,1\to 3\to 4\to 61→2→5→6,1→3→4→6。
这时可能你心里会想：增广（A）1→2→4→6,1→3→4→2→5→61\to 2\to 4\to 6,1\to 3\to 4\to 2\to 5\to 61→2→4→6,1→3→4→2→5→6 为什么一定等价于增广（B）1→2→5→6,1→3→4→61\to 2\to 5\to 6,1\to 3\to 4\to 61→2→5→6,1→3→4→6？如果边权不一样怎么办？比如如果其他所有边的容量都是 114514114514114514，而 cf(2,4)=1c_f(2,4)=1cf​(2,4)=1，A 的最大流只有 1+1=21+1=21+1=2，而 B 有 114514+114514=229028114514+114514=229028114514+114514=229028 呢！实际上对于这个情况，A 增广后并没有结束，因为 s,ts,ts,t 还连通着。算法会接着增广 B，以达到最大流。
这样就实现了反悔。于是，我们可以一直增广，直到 GfG_fGf​ 中 s,ts,ts,t 不再连通，即没有增广路可以增加流量了，此时 fff 即为该网络的最大流，它是由众多增广出的流叠加而成。
比较抽象，接下来看看算法实现。
EK 算法
EK 算法的本质就是通过在残量网络 GfG_fGf​ 上 bfs 找增广路，进行增广。
算法流程


初始化。
注意，反向边也要存，存图时虽存的是原网络，但边权表示的是 cfc_fcf​ 而非 ccc 或 fff。


bfs 在 GfG_fGf​ 上找增广路。如果 GfG_fGf​ 上存在 s→ts\to ts→t 的路径，则找到了新的增广路。


增广。


重复 bfs、增广，直到 GfG_fGf​ 中 s,ts,ts,t 不再连通，即不存在增广路，此时 EK 算法结束。


可以发现，由于使用的是 bfs，每次增广的增广路都是最短的。
为什么说存的是原网络而非残量网络？
如果要存残量网络，每次增广后需要将 cf(u,v)=0c_f(u,v)=0cf​(u,v)=0 的边 (u,v)(u,v)(u,v) 删掉，太过麻烦。而直接存原网络，bfs 时直接判断 cf(u,v)c_f(u,v)cf​(u,v) 是否 &gt;0&gt;0&gt;0，就知道该边是否在 GfG_fGf​ 中，所以边权维护 cfc_fcf​。
还是不懂可以看代码理解。
代码
题目：P3376 【模板】网络最大流
#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;constexpr int N=214;constexpr ll INF=0x3f3f3f3f3f3f3f3f;struct edge&#123;    int v;// 边 (u,v)    ll c;// 准确来说，c_f&#125;;vector&lt;edge&gt; es;// 边集vector&lt;int&gt; e[N];// 存出边int n,m,s,t;namespace EK&#123;    bitset&lt;N&gt; vis;    int pre[N];// 存增广路上的前驱    ll flow[N];// flow[u]：能流到 u 的最大流量    bool bfs()    &#123;        queue&lt;int&gt; q;        vis.reset();        vis[s]=true;        q.push(s);        flow[s]=INF;// 从源点流出的“水量”应是无穷大的，但由于水管不够大，被阻塞        int u,l,v;        ll c;        while(!q.empty())// bfs        &#123;            u=q.front();            q.pop();            l=e[u].size();            for(int i=0;i&lt;l;i++)// 遍历出边            &#123;                v=es[e[u][i]].v;                c=es[e[u][i]].c;                if(!vis[v]&amp;&amp;c&gt;0)// 未遍历过且存在于残量网络中                &#123;                    vis[v]=true;// 标记                    flow[v]=min(flow[u],c);// 取 min                    pre[v]=e[u][i];// 标记前驱                    if(v==t)return true;// 如果搜到 t，则找到增广路，返回                    q.push(v);                &#125;            &#125;        &#125;        return false;// 无增广路    &#125;    ll EK()    &#123;        ll r=0ll;// 初始流量        while(bfs())// 找增广路        &#123;// 如果有增广路            r+=flow[t];// 增加网络流量            for(int i=t;i!=s;i=es[pre[i]^1].v)// 增广路上的每条边            &#123; // 更新 c_f                es[pre[i]].c-=flow[t];// 正边                es[pre[i]^1].c+=flow[t];// 反边            &#125;        &#125;        return r;// 无增广路，算法结束    &#125;&#125;//^ namespace EKint main()&#123;    scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;s,&amp;t);    for(int i=1,u,v,w;i&lt;=m;i++)    &#123;        scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);        e[u].push_back(es.size());// 采用类似链式前向星的存边法        es.push_back(&#123;v,ll(w)&#125;);        e[v].push_back(es.size());        es.push_back(&#123;u,0ll&#125;);    &#125;    printf(&quot;%lld&quot;,EK::EK());    return 0;&#125;
时间复杂度
单轮 bfs 增广的时间复杂度是 O(m)O(m)O(m)。
增广总轮数的上界是 O(nm)O(nm)O(nm)。但笔者不会证，干脆不要乱证。OIer 不需要证明。
于是最终时间复杂度为 O(nm2)O(nm^2)O(nm2)。为 O(n5)O(n^5)O(n5) 量级。实际上跑不满，但容易被卡。
Dinic 算法
由于 EK 经常被卡，引出 Dinic 算法。
如何优化 EK
考虑 EK 到底慢在哪。
EK 本质上是一次一次的 bfs 增广，每次只能增广一条最短的增广路。Dinic 使用分层图后，不仅满足增广最短增广路，同时可一次性增广多条增广路。
定义
设 uuu 到 sss 的距离为 d(u)d(u)d(u)，它可以用 bfs 求得。注意这里距离的定义为从 sss 到 uuu 所需要经过的最少边数。
层次图（Level Graph，GLG_LGL​），是在 Gf=(V,Ef)G_f=(V,E_f)Gf​=(V,Ef​) 的基础上，设 EL={(u,v)∣(u,v)∈Ef,d(u)+1=d(v)}E_L=\{(u,v)|(u,v)\in E_f,d(u)+1=d(v)\}EL​={(u,v)∣(u,v)∈Ef​,d(u)+1=d(v)}，那么 GL=(V,EL)G_L=(V,E_L)GL​=(V,EL​)。也就是说，我们从 EfE_fEf​ 中删除了一些边，使经过 uuu 的流量只能流向下一层的结点 vvv。
阻塞流（Blocking Flow，fbf_bfb​），是在当前 GLG_LGL​ 上找到的一个极大的流 fbf_bfb​。
算法流程

在 GfG_fGf​ 上 bfs 出层次图 GLG_LGL​。
在 GLG_LGL​ 上 dfs 出阻塞流 fbf_bfb​。
将 fbf_bfb​ 并到原先的流 fff 中，即 f←f+fbf\gets f+f_bf←f+fb​。
重复以上过程直到不存在从 sss 到 ttt 的路径。

具体如何实现 dfs？
我们可以每次 dfs，一找到一条阻塞流的增广流，就立马回溯，进行增广。同时多次 dfs。
但不必如此。常数优化：只需一次 dfs，找到多个增广路一次性增广阻塞流——多路增广优化。
给出 dfs 实现流程：

从源点开始 dfs，保存当前点编号 uuu、当前流到 uuu 的流大小 flowflowflow。
如果 u=tu=tu=t，即这股阻塞流已经到达了汇点 ttt，返回 flowflowflow。
对于每条出边指向的点 vvv，如果在层次图上存在边 (u,v)(u,v)(u,v)，dfs 出 vvv 的阻塞流 nownownow。
如果 now=0now=0now=0，说明 vvv 无法增广，将 d(v)←0d(v)\gets 0d(v)←0，弃置——无用点优化。
现场增广，更新当前点 uuu 的最大流 res←res+now,flow←flow−nowres\gets res+now,flow\gets flow-nowres←res+now,flow←flow−now，更新 cf(u,v)←cf(u,v)−now,cf(v,u)←cf(v,u)+nowc_f(u,v)\gets c_f(u,v)-now,c_f(v,u)\gets c_f(v,u)+nowcf​(u,v)←cf​(u,v)−now,cf​(v,u)←cf​(v,u)+now。
返回 resresres。

由于不是 DAG，dfs 可能多次遍历某个点 uuu，每次由入边流入流量时 uuu 都需要遍历每个出边进行流量的传递，这一过程可能达到 O(m2)O(m^2)O(m2)。
所以，如果某条出边已无法接受更多流量（(u,v)(u,v)(u,v) 无剩余容量或 vvv 的后侧已阻塞），那么我们下一次遍历 uuu 时就可以跳过 (u,v)(u,v)(u,v)。
于是对于每个点 uuu，维护其出边中第一条可尝试的出边。这条边叫当前弧，该做法叫当前弧优化。（其实和欧拉回路很像。）
以上可能讲得不清楚，可参考代码。
代码
#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;constexpr int N=214;constexpr ll INF=0x3f3f3f3f3f3f3f3f;struct edge&#123;    int v;    ll c;&#125;;vector&lt;edge&gt; es;// 存图方式同 EKvector&lt;int&gt; e[N];int n,m,s,t;namespace Dinic&#123;    int dis[N],fir[N];// dis[u]：s-&gt;u 最短距离，fir[u]：u 的出边中第一个有意义的点，即当前弧    bool bfs()    &#123;        fill(fir,fir+N,0);// 清空        fill(dis,dis+N,0);        dis[s]=1;        queue&lt;int&gt; q;        q.push(s);        int u,l,v;        while(!q.empty())// bfs        &#123;            u=q.front();            q.pop();            l=e[u].size();            for(int i=0;i&lt;l;i++)            &#123;                v=es[e[u][i]].v;                if(!dis[v]&amp;&amp;es[e[u][i]].c&gt;0ll)// 若未遍历过且有剩余容量                &#123;                    dis[v]=dis[u]+1;// 标记                    q.push(v);                    if(v==t)return true;// 若找到 t，返回                &#125;            &#125;        &#125;        return false;// 若无阻塞流，返回    &#125;    ll dfs(int u=s,ll flow=INF)// flow：可以流进当前点的流量    &#123;// 注意，这里的 dfs 不像其他 dfs，可能重复访问一个点        if(u==t)return flow;// 找到 t，返回流到 t 的流量        int l=e[u].size(),v;        ll res=0ll,now,c;        for(int i=fir[u];i&lt;l;i++)// 从第一个有必要尝试的点开始        &#123;            fir[u]=i;// 当前弧优化：维护当前弧指针，注意它只对本轮 dfs 有效，bfs 会清除 fir 数组            v=es[e[u][i]].v;            c=es[e[u][i]].c;            if(dis[v]==dis[u]+1&amp;&amp;c&gt;0ll)// 如果在 G_L 上且有剩余容量            &#123;                now=dfs(v,min(flow,c));// dfs 出 v 能流到 t 的阻塞流                if(now==0ll)dis[v]=0;// 无用点优化：如果已经不能增广 v，则丢弃 v，这样下一次访问 u 并遍历出边时就会忽略 v                es[e[u][i]].c-=now;// 现场增流                es[e[u][i]^1].c+=now;                res+=now;// 更新当前点能流出的最大阻塞流                flow-=now;// 任务减轻                if(flow==0ll)return res;// 当前弧优化：如果任务完成，直接 return，非常重要！！！                // 如果没有上面这一句，Dinic 的复杂度将无法保证，甚至在洛谷模板题上比 EK 跑得还慢！！！                // 因为不 return 会继续遍历所有出边，但参数 flow=0，没有任何用处，浪费时间。            &#125;        &#125;        return res;    &#125;    ll Dinic()    &#123;        ll r=0ll;        while(bfs())r+=dfs();        return r;    &#125;&#125;//^ namespace Dinicint main()&#123;    scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;s,&amp;t);    for(int i=1,u,v,w;i&lt;=m;i++)    &#123;        scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);        e[u].push_back(es.size());        es.push_back(&#123;v,ll(w)&#125;);        e[v].push_back(es.size());        es.push_back(&#123;u,0ll&#125;);    &#125;    printf(&quot;%lld&quot;,Dinic::Dinic());    return 0;&#125;
时间复杂度
单轮 dfs 增广的时间复杂度是 O(nm)O(nm)O(nm)，增广总轮数的上界是 O(n)O(n)O(n)，于是最终时间复杂度为 O(n2m)O(n^2m)O(n2m)。
为 O(n4)O(n^4)O(n4) 量级。实际上也跑不满，但据说不卡 Dinic 是所有出题人的共识（惯例）。
称边权为 0,10,10,1 的图为单位容量的。

在单位容量的网络中，Dinic 算法的单轮增广的时间复杂度为 O(m)O(m)O(m)。
在单位容量的网络中，Dinic 算法的增广轮数是 O(m)O(\sqrt{m})O(m​) 的。
在单位容量的网络中，Dinic 算法的增广轮数是 O(n2/3)O(n^{2/3})O(n2/3) 的。

于是单位容量的网中网络流的复杂度为：O(mmin⁡(m,n2/3))O(m\min(\sqrt{m}, n^{2/3}))O(mmin(m​,n2/3))，二分图匹配就可以做到这个复杂度。
正确性

每次建立层次图后都可以进行多次增广，无法增广时重新建立层次图，此时的层次图不再包含之前进行增广后满载的边。无法建立层次图时，说明源点到汇点的任意一条简单路径中，都至少有一条边满载，这也在直观上验证了最小割最大流定理。

最大流最小割定理
对于网络 G=(V,E)G=(V,E)G=(V,E)，源点 sss，汇点 ttt，有以下三个条件互相等价：

fff 为最大流
残量网络 GfG_fGf​ 上不存在增广路
存在割 (S,T)(S,T)(S,T) 使得 ∣∣S,T∣∣=∣f∣||S,T||=|f|∣∣S,T∣∣=∣f∣

引理
先从一个引理开始：∣f∣≤∣∣S,T∣∣|f|\le||S,T||∣f∣≤∣∣S,T∣∣。
也就是说任意一个流的流量都不会大于任意一个割的容量。进一步地，就是最大流流量不大于最小割容量。
设 u∈S,v∈Tu\in S,v\in Tu∈S,v∈T。因为流从 SSS 中的点流到 TTT 中，必须跨过一条 (u,v)(u,v)(u,v) 边。即使 (u,v)(u,v)(u,v) 均满流，即 f(u,v)=c(u,v)f(u,v)=c(u,v)f(u,v)=c(u,v)，也只有 ∣f∣=∣∣S,T∣∣|f|=||S,T||∣f∣=∣∣S,T∣∣。此时所有从 SSS 到 TTT 的边都已满流，无法再增加流量，所以有 ∣f∣≤∣∣S,T∣∣|f|\le||S,T||∣f∣≤∣∣S,T∣∣。
形式化的证明：
∣f∣=f(s)基本性质=∑u∈Sf(u)所有 u∈S,u≠s 均满足 f(u)=0=∑u∈S(∑v∈Vf(u,v)−∑v∈Vf(v,u))净流量 f(u) 的定义：出量−入量=∑u∈S(∑v∈Tf(u,v)+∑v∈Sf(u,v)−∑v∈Tf(v,u)−∑v∈Sf(v,u))将 v∈V 分类讨论：v∈S,v∈T=∑u∈S(∑v∈Tf(u,v)−∑v∈Tf(v,u))+∑u∈S∑v∈Sf(u,v)−∑u∈S∑v∈Sf(v,u)分离=∑u∈S(∑v∈Tf(u,v)−∑v∈Tf(v,u))抵消的两式是互相等价的≤∑u∈S∑v∈Tf(u,v)f(v,u)≥0≤∑u∈S∑v∈Tc(u,v)f(u,v)≤c(u,v)=∣∣S,T∣∣定义\footnotesize
\begin{aligned}
|f|&amp;=f(s)&amp;\text{基本性质}\\
&amp;=\sum_{u\in S}f(u)&amp;\text{所有 $u\in S,u\ne s$ 均满足 $f(u)$=0}\\
&amp;=\sum_{u\in S}\left(\sum_{v\in V}f(u,v)-\sum_{v\in V}f(v,u)\right)&amp;\text{净流量 $f(u)$ 的定义：出量$-$入量}\\
&amp;=\sum_{u\in S}\left(\sum_{v\in T}f(u,v)+\sum_{v\in S}f(u,v)-\sum_{v\in T}f(v,u)-\sum_{v\in S}f(v,u)\right)&amp;\text{将 $v\in V$ 分类讨论：$v\in S,v\in T$}\\
&amp;=\sum_{u\in S}\left(\sum_{v\in T}f(u,v)-\sum_{v\in T}f(v,u)\right)+\sum_{u\in S}\sum_{v\in S}f(u,v)-\sum_{u\in S}\sum_{v\in S}f(v,u)&amp;\text{分离}\\
&amp;=\sum_{u\in S}\left(\sum_{v\in T}f(u,v)-\sum_{v\in T}f(v,u)\right)&amp;\text{抵消的两式是互相等价的}\\
&amp;\le\sum_{u\in S}\sum_{v\in T}f(u,v)&amp;f(v,u)\ge 0\\
&amp;\le\sum_{u\in S}\sum_{v\in T}c(u,v)&amp;f(u,v)\le c(u,v)\\
&amp;=||S,T||&amp;\text{定义}\\
\end{aligned}
∣f∣​=f(s)=u∈S∑​f(u)=u∈S∑​(v∈V∑​f(u,v)−v∈V∑​f(v,u))=u∈S∑​(v∈T∑​f(u,v)+v∈S∑​f(u,v)−v∈T∑​f(v,u)−v∈S∑​f(v,u))=u∈S∑​(v∈T∑​f(u,v)−v∈T∑​f(v,u))+u∈S∑​v∈S∑​f(u,v)−u∈S∑​v∈S∑​f(v,u)=u∈S∑​(v∈T∑​f(u,v)−v∈T∑​f(v,u))≤u∈S∑​v∈T∑​f(u,v)≤u∈S∑​v∈T∑​c(u,v)=∣∣S,T∣∣​基本性质所有 u∈S,u​=s 均满足 f(u)=0净流量 f(u) 的定义：出量−入量将 v∈V 分类讨论：v∈S,v∈T分离抵消的两式是互相等价的f(v,u)≥0f(u,v)≤c(u,v)定义​
对于第一个不等号，取等需要满足 ∀u∈S,v∈T,f(v,u)=0\forall u\in S,v\in T,f(v,u)=0∀u∈S,v∈T,f(v,u)=0，即 (v,u)(v,u)(v,u) 均空流。
对于第二个不等号，取等需要满足 ∀u∈S,v∈T,f(u,v)=c(u,v)\forall u\in S,v\in T,f(u,v)=c(u,v)∀u∈S,v∈T,f(u,v)=c(u,v)，即 (u,v)(u,v)(u,v) 均满流。
定理证明
1  ⟹  21\implies 21⟹2
因为若残量网络 GfG_fGf​ 上存在增广路，必然可以对其增广，使流量更大，与条件“fff 为最大流”矛盾。
2  ⟹  32\implies 32⟹3
设 SSS 为所有从 sss 出发能到达的点，T=V−ST=V-ST=V−S，则


对于 u∈S,v∈Tu\in S,v\in Tu∈S,v∈T，所有边 (u,v)(u,v)(u,v) 均满流。分类讨论：
否则其剩余容量 cf(u,v)=c(u,v)−f(u,v)&gt;0c_f(u,v)=c(u,v)-f(u,v)&gt;0cf​(u,v)=c(u,v)−f(u,v)&gt;0，有 (u,v)(u,v)(u,v) 在 GfG_fGf​ 上，可以从 s→u→vs\to u\to vs→u→v，与 v∈Tv\in Tv∈T 矛盾。


同样的，对于 u∈S,v∈Tu\in S,v\in Tu∈S,v∈T，所有边 (v,u)(v,u)(v,u) 均空流。
否则其反向边 (u,v)(u,v)(u,v) 的剩余容量 cf(u,v)=f(v,u)&gt;0c_f(u,v)=f(v,u)&gt;0cf​(u,v)=f(v,u)&gt;0，有 (u,v)(u,v)(u,v) 在 GfG_fGf​ 上，可以从 s→u→vs\to u\to vs→u→v，与 v∈Tv\in Tv∈T 矛盾。


以上证明假定 (u,v)∈E(u,v)\in E(u,v)∈E 和 (v,u)∈E(v,u)\in E(v,u)∈E。如果不满足此条件，则由定义默认 f(u,v)=c(u,v)=0f(u,v)=c(u,v)=0f(u,v)=c(u,v)=0、f(v,u)=c(v,u)=0f(v,u)=c(v,u)=0f(v,u)=c(v,u)=0，定理也是对的。而一种更 不 优美的方式是，
cf(u,v)=(c(u,v)−f(u,v))+f(v,u)+0=0c_f(u,v)={\color{red}\Big(c(u,v)-f(u,v)\Big)}+{\color{blue}f(v,u)}+{\color{green}0}=0
cf​(u,v)=(c(u,v)−f(u,v))+f(v,u)+0=0
我们将 cf(u,v)c_f(u,v)cf​(u,v) 定义中的三种可能相加。不管 (u,v)∈E(u,v)\in E(u,v)∈E、(v,u)∈E(v,u)\in E(v,u)∈E、otherwise\text{otherwise}otherwise，可以发现 除了满足的条件所对应的那一项，另外的两项均为 000。也就是说，上式符合定义。又由于 c(u,v)−f(u,v)≥0,f(v,u)≥0c(u,v)-f(u,v)\ge 0,f(v,u)\ge 0c(u,v)−f(u,v)≥0,f(v,u)≥0，故 c(u,v)−f(u,v)=0,f(v,u)=0c(u,v)-f(u,v)=0,f(v,u)=0c(u,v)−f(u,v)=0,f(v,u)=0。
所以不管怎么说，我们证明了引理中的取等条件，有我们构造的割 (S,T)(S,T)(S,T) 满足 ∣f∣=∣∣S,T∣∣|f|=||S,T||∣f∣=∣∣S,T∣∣。
3  ⟹  13\implies 13⟹1
由于对于所有流 fff、割 (S,T)(S,T)(S,T) 都有 ∣f∣≤∣∣S,T∣∣|f|\le ||S,T||∣f∣≤∣∣S,T∣∣，故取等时 fff 为最大流，(S,T)(S,T)(S,T) 为最小割。
换句话说，若存在流 f′f&#x27;f′ 满足比 fff 流量更大，则 ∣f′∣&gt;∣f∣=∣∣S,T∣∣|f&#x27;|&gt;|f|=||S,T||∣f′∣&gt;∣f∣=∣∣S,T∣∣，与引理 ∣f′∣≤∣∣S,T∣∣|f&#x27;|\le ||S,T||∣f′∣≤∣∣S,T∣∣ 矛盾。故不存在 f′f&#x27;f′，即 fff 为最大流。(S,T)(S,T)(S,T) 为最小割同样可以用这种反证法证明。
□\square□
定理应用
那么这个定理有什么用？

Ford-Fulkerson 增广结束时，所得 fff 为最大流，即证明了该算法正确性；
同时，证明了最大流流量等于最小割容量，即 max⁡∣f∣=min⁡∣∣S,T∣∣\max |f|=\min ||S,T||max∣f∣=min∣∣S,T∣∣；
可得，我们同样可以使用 Ford-Fulkerson 求出最小割。

事实上，最大流最小割本质上是线性规划对偶。
费用流
定义
一条边单位流量的 费用（w(u,v)w(u,v)w(u,v)） 为一个 V×V→RV\times V\to\Bbb{R}V×V→R 的函数，表示边 (u,v)(u,v)(u,v) 流过 f(u,v)f(u,v)f(u,v) 的流量需要花费 f(u,v)×w(u,v)f(u,v)\times w(u,v)f(u,v)×w(u,v) 的费用。
最小费用最大流问题，即在最大流的前提下最小化每条边的费用之和 ∑(u,v)∈Ef(u,v)×w(u,v)\sum_{(u,v)\in E}f(u,v)\times w(u,v)∑(u,v)∈E​f(u,v)×w(u,v)。
SSP 算法
SSP 算法（Successive Shortest Path Algorithm），即每次寻找费用和最小的增广路进行增广，也就是将最大流算法中的 bfs 改成了最短路算法。一般使用 EK + 队列优化 Bellman-Ford 实现。使用 Dinic 复杂度没有优化。
费用存在负环时 SSP 算法无法正确求解最小费用最大流问题，这种情况做题时一般也不会出现，这里先不讲，以后有时间再补解决方法。
代码
类似的，我们可以写出 SSP 算法的代码。
#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;bitset&gt;using std::cin;typedef long long ll;constexpr int N=5e3+1145,INF=0x3f3f3f3f;namespace ssp&#123;    int n,s,t;    struct edge&#123;int v,w,c;&#125;;    std::vector&lt;int&gt; e[N];    std::vector&lt;edge&gt; es;    inline void add(int u,int v,int w,int c)    &#123;        e[u].push_back(es.size());        es.push_back(&#123;v,w,c&#125;);        e[v].push_back(es.size());        es.push_back(&#123;u,0,-c&#125;);    &#125;    int dis[N],flow[N],pre[N];    std::bitset&lt;N&gt; inq;    bool exbf() // 队列优化 Bellman-Ford    &#123;        std::fill(dis,dis+n+1,INF);        dis[s]=0;        flow[s]=INF;        flow[t]=0;        std::queue&lt;int&gt; q;        q.push(s);        int u,v,w,c;        while(!q.empty())        &#123;            u=q.front(),q.pop();            inq[u]=false;            for(int i=0;i&lt;int(e[u].size());i++)            &#123;                v=es[e[u][i]].v,w=es[e[u][i]].w,c=es[e[u][i]].c;                if(w&amp;&amp;dis[v]&gt;dis[u]+c)                &#123;                    dis[v]=dis[u]+c;                    flow[v]=std::min(w,flow[u]);                    pre[v]=e[u][i];                    if(!inq[v])q.push(v),inq[v]=true;                &#125;            &#125;        &#125;        return flow[t];    &#125;    int maxflow,mincost;    void main() // EK    &#123;        while(exbf())        &#123;            maxflow+=flow[t];            for(int u=t;u!=s;u=es[pre[u]^1].v)            &#123;                es[pre[u]].w-=flow[t],es[pre[u]^1].w+=flow[t];                mincost+=es[pre[u]].c*flow[t];            &#125;        &#125;    &#125;&#125; // namespace sspint main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(nullptr);    int m;    cin&gt;&gt;ssp::n&gt;&gt;m&gt;&gt;ssp::s&gt;&gt;ssp::t;    for(int i=1,u,v,w,c;i&lt;=m;i++)    &#123;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w&gt;&gt;c;        ssp::add(u,v,w,c);    &#125;    ssp::main();    printf(&quot;%d %d&quot;,ssp::maxflow,ssp::mincost);    return 0;&#125;
应用
二分图
最大匹配
P3386 【模板】二分图最大匹配
考虑建立最大流模型。
建立超级汇点 sss 连向所有左部点 u∈V0u\in V_0u∈V0​，所有右部点 v∈V1v\in V_1v∈V1​ 连向超级汇点 ttt。
上述边和原二分图中的边（只从左部连向右部）的容量均为 111。直接跑 Dinic 即可。
最小点覆盖 &amp; 最大独立集
后记——拓展阅读

[教程]网络流详解: 从入门到放弃
Algorithms by Jeff Erickson

]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>莫队</title>
    <url>/mt/</url>
    <content><![CDATA[前言

这是一篇 LaTeX\LaTeXLATE​X PPT 改 md。

今天的题单：点我。
今天是我第一次上台，PPT 可能不是那么美观， 如果有错误请大胆指出。
例题不会很难，请放心食用。

简介
莫队简介
什么是莫队？
莫队是由莫涛大神提出的一种暴力区间操作算法，它框架简单、板子好写、复杂度优秀。
然而由于莫队算法应用的毒瘤，很多莫队题难度评级都很高（蓝紫黑），令很多初学者望而却步。但如果你真正理解了莫队的算法原理，它用起来还是挺简单的。
前置知识：

分块思想。
sort 的用法（包括重载运算符或 cmp 函数，多关键字排序）。

使用莫队的情境
若 m=O(n)m=O(n)m=O(n)（即 mmm、nnn 同阶），且 [l,r][l,r][l,r] 的答案能 O(1)O(1)O(1) 地转换到 [l−1,r],[l,r+1],[l+1,r],[l,r−1][l-1,r],[l,r+1],[l+1,r],[l,r-1][l−1,r],[l,r+1],[l+1,r],[l,r−1] 区间（即相邻区间）的答案，那么莫队可以在 O(nn)O(n\sqrt{n})O(nn​) 的时间复杂度内离线求出所有询问的答案。
注意：莫队是离线算法。如果题目强制在线，则不以可用莫队。
什么是离线、在线？

如果算法需要知道所有询问才能开始算法，则称此算法为离线算法。
读入一个询问，回答一个询问的算法叫在线算法。
强制在线就是要求你读入一个询问就立马回答。

莫队的基本思想
离线存下所有询问，借助分块按照一定的顺序处理这些询问，使得询问之间可以互相利用（一般情况下为了方便，只会是本次询问利用上次询问的答案），以减小时间复杂度。
普通莫队
算法基础
算法流程

离线存下所有询问。
以二元组 (bel[li],ri)(bel[l_i],r_i)(bel[li​],ri​) 为关键字升序对所有询问排序。
其中 iii 表示当前询问编号，bel[li]bel[l_i]bel[li​]（belong，属于）表示 lil_ili​ 所在的块的编号。
遍历每个询问，维护两个指针 [l,r][l,r][l,r] 表示当前区间，nownownow 表示当前答案。
初始时 l=1,r=0l=1,r=0l=1,r=0（如果 l=0l=0l=0，那么我们还需要删除 a0a_0a0​，导致一些奇怪的错误）。
l,rl,rl,r 需区别于 li,ril_i,r_ili​,ri​，它们一对是我们维护的指针（下标），一对是数据给出的询问。
移动区间 [l,r]→[li,ri][l,r]\to [l_i,r_i][l,r]→[li​,ri​]。途中维护区间 [l,r][l,r][l,r] 的答案 nownownow。
移动结束后，记录区间 [li,ri][l_i,r_i][li​,ri​] 的答案 ansians_iansi​。（ansi←nowans_i\gets nowansi​←now）。

算法代码：洛谷 P3901 数列找不同（模板题）
constexpr int N=114514;int n,m,a[N],S;// S：块长// [1,S] 区间的块编号为 1，[S+1,2S] 区间的块编号为 2，以此类推。inline int bel(int x)&#123;return (x-1)/S+1;&#125;struct query// 询问结构体&#123;    int l,r,id;// 分别为每个询问区间的左端点、右端点、询问的编号。    friend inline bool operator &lt; (query x,query y)    &#123;return (bel(x.l)==bel(y.l)?x.r&lt;y.r:bel(x.l)&lt;bel(y.l));&#125;&#125;;query q[N];// 查询数组bitset&lt;N&gt; ans;// 答案数组// cnt[i]：i 这个数在当前区间 [l,r] 出现次数，cf：重复出现的数的数量。// 如果 cf=0，[l,r] 中没有重复出现的数。int cnt[N],cf=0;// 移动区间inline void add(int pos)// 添加 a[pos]&#123;    cnt[a[pos]]++;// 将 a[pos] 的出现次数 +1。    if(cnt[a[pos]]==2)cf++;// 如果已经出现两次，则重复了，cf++。&#125;inline void del(int pos)// 删除 a[pos]&#123;    cnt[a[pos]]--;// 将 a[pos] 的出现次数 -1。    if(cnt[a[pos]]==1)cf--;// 如果当前只出现一次，则之前一定重复（出现两次），    // 而现在不重复了，cf--。&#125;void mt()&#123;    S=int(ceil(pow(n,0.5)));// S=sqrt(n)，根号分块    sort(q+1,q+m+1);// 结构体排序    for(int i=1,l=1,r=0;i&lt;=m;i++)// 遍历每个询问    &#123;        #define q q[i]// 偷懒        while(q.l&lt;l)add(--l);// 向左扩展 l-1        while(r&lt;q.r)add(++r);// 向右扩展 r+1        while(l&lt;q.l)del(l++);// 向右删除 l        while(q.r&lt;r)del(r--);// 向左删除 r        // 注意上面四句的顺序，需要先扩展在删除。        // 同时注意自减自加运算符是前置还是后置。        ans[q.id]=!cf;// 记录当前答案        #undef q    &#125;&#125;int main()&#123;    // input    mt();// 莫队    for(int i=1;i&lt;=m;i++)puts(ans[i]?&quot;Yes&quot;:&quot;No&quot;);// 输出    return 0;&#125;
算法复杂度
下面的讨论中 m=O(n)m=O(n)m=O(n)。
单次移动 l,rl,rl,r 中的一个复杂度显然 O(1)O(1)O(1)。
考虑 l,rl,rl,r 分别移动的次数。

考虑 lll：设块 iii 内的询问的左端点个数为 xix_ixi​，则块 iii 中移动 lll 的次数顶多 xi×nx_i\times\sqrt{n}xi​×n​。一共 n\sqrt{n}n​ 个块，移动 lll 的总时间复杂度为：

∑i=1n(xi×n)=(n)×∑i=1n(xi)=n×m=O(nn)\begin{aligned}
	&amp;\sum_{i=1}^{\sqrt{n}} \left(x_i\times\sqrt{n}\right)\\
	=&amp;\left(\sqrt{n}\right)\times\sum_{i=1}^{\sqrt{n}} \left(x_i\right)\\
	=&amp;\sqrt{n}\times m\\
	=&amp;O(n\sqrt{n})
\end{aligned}===​i=1∑n​​(xi​×n​)(n​)×i=1∑n​​(xi​)n​×mO(nn​)​

考虑 rrr：每块内的 xix_ixi​ 个 lj(1≤j≤xi)l_j(1\le j\le x_i)lj​(1≤j≤xi​) 肯定一一对应着 xix_ixi​ 个 rjr_jrj​。
显然这 xix_ixi​ 个 rjr_jrj​ 最多会使 rrr 移动 nnn 的长度（ljl_jlj​ 同一块时，按 rjr_jrj​ 升序，故不降）。
一共 n\sqrt{n}n​ 个块，移动 rrr 的总时间复杂度为：n×n=O(nn)\sqrt{n}\times n=O(n\sqrt{n})n​×n=O(nn​)。
则总时间复杂度为 O(1)×[O(nn)+O(nn)]=O(nn)O(1)\times [O(n\sqrt{n})+O(n\sqrt{n})]=O(n\sqrt{n})O(1)×[O(nn​)+O(nn​)]=O(nn​)。

算法优化
奇偶性排序
刚才的复杂度分析中提出了一些极端情况：xix_ixi​ 个 rjr_jrj​ 最多使 rrr 移动 nnn 的长度。
而 n\sqrt{n}n​ 个块都可能使 rrr 移动 nnn 的长度，例如下列询问（n=100,S=10n=100,S=10n=100,S=10）：
1 110 10011 120 100
按原先的排序策略，rrr 需要反复横跳，十分浪费时间。
如果将处理顺序改为以下顺序将大大加速：
1 110 10020 10011 1
怎么修改排序策略？
依然以 bel[li]bel[l_i]bel[li​] 为第一关键字升序排序，若 bel[li]bel[l_i]bel[li​] 为奇数，以 rir_iri​ 为第二关键字升序排序，反之若 bel[li]bel[l_i]bel[li​] 为偶数，以 rir_iri​ 为第二关键字降序排序。

这样我们的 rrr 指针在处理完这个奇数块的问题后，将在返回的途中处理偶数块的问题，再向 nnn 移动处理下一个奇数块的问题，优化了 rrr 指针的移动次数，一般情况下，这种优化能让程序快 30%30\%30% 左右。
——OI-Wiki。

实测：810810810 ms →\to→ 622622622 ms，快约 23.2%23.2\%23.2%。
奇偶性排序：代码
struct query&#123;    int l,r,id;    friend inline bool operator &lt; (query x,query y)    &#123;        if(bel(x.l)!=bel(y.l))return bel(x.l)&lt;bel(y.l);        if(bel(x.l)&amp;1)return x.r&lt;y.r;        else return x.r&gt;y.r;    &#125;&#125;;
坑点：注意重载运算符不能出现 a&lt;b,a&gt;ba&lt;b,a&gt;ba&lt;b,a&gt;b 同时为真的情况，否则会 RE。如以下实现方式就是错误的：
struct query&#123;    int l,r,id;    friend inline bool operator &lt; (query x,query y)    &#123;        if(bel(x.l)!=bel(y.l))return bel(x.l)&lt;bel(y.l);        return (bel(x.l)&amp;1)==(x.r&lt;y.r);// 这里会出错    &#125;&#125;;
常数级展开
发现 add()，del() 两个函数可以压行并展开到 mt() 中。
这看似鸡肋的优化实测 572572572 ms——又优化了 505050 ms。
代码：
void mt()&#123;    S=int(ceil(pow(n,0.5)));    sort(q+1,q+m+1);    for(int i=1,l=1,r=0;i&lt;=m;i++)    &#123;        #define q q[i]        // 压行并展开：        while(q.l&lt;l)cf+=(++cnt[a[--l]]==2);// 与 add(--l) 等价        while(r&lt;q.r)cf+=(++cnt[a[++r]]==2);// 与 add(++r) 等价        while(l&lt;q.l)cf-=(--cnt[a[l++]]==1);// 与 del(l++) 等价        while(q.r&lt;r)cf-=(--cnt[a[r--]]==1);// 与 del(r--) 等价        ans[q.id]=!cf;        #undef q    &#125;&#125;
玄学剪枝
我考虑到有时候可能转移大半天还不如暴力重新算，所以想出了一个玄学剪枝：
// 如果转移代价大于重新算的代价if(abs(q.l-l)+abs(q.r-r)&gt;(r-l+1)+(q.r-q.l+1))&#123;    while(l&lt;=r)cf-=(--cnt[a[r--]]==1);// 清除    r=(l=q.l)-1;// 直接跳转&#125;
（这段语句加在 #define q q[i] 后面。）
没想到只优化了 111 ms（悲。也许是每次都判断的代价太大，抵消了直接跳转的优化。
预处理 belbelbel
我写好几题才发现其他大佬都预处理了 belbelbel，于是赶紧改过来。快了 585858 ms。
int S;int bel[N];inline void initbel()// 1~S: 1&#123;    S=int(ceil(pow(n,0.5)));// S=sqrt(n)    for(int i=1;i&lt;=n;i++)bel[i]=(i-1)/S+1;&#125;...void mt()&#123;    initbel();    sort(q+1,q+m+1);    ...&#125;
例题
例题：DQUERY - D-query
简要题意：给出一个长度为 nnn 的数列 aaa，mmm 个询问，每次询问给出数对 l,rl,rl,r 表示查询区间 [l,r][l,r][l,r] 中有多少不同的数。
数据范围：n≤3×105,m≤2×105,ai≤106n\le 3\times10^5,m\le2\times10^5,a_i\le10^6n≤3×105,m≤2×105,ai​≤106。
板子题，难度在于如何 O(1)O(1)O(1) 转移答案。
考虑用数组 cnticnt_icnti​ 表示 [l,r][l,r][l,r] 中 iii 出现了几次，变量 nownownow 表示 [l,r][l,r][l,r] 中有多少不同的数。
要添加 aposa_{pos}apos​，那么 cnt[apos]←cnt[apos]+1cnt[a_{pos}]\gets cnt[a_{pos}]+1cnt[apos​]←cnt[apos​]+1。
此时若 cnt[apos]=1cnt[a_{pos}]=1cnt[apos​]=1，即多了一个不同的数，那么 now←now+1now\gets now+1now←now+1。
同理删除 aposa_{pos}apos​ 时 cnt[apos]←cnt[apos]−1cnt[a_{pos}]\gets cnt[a_{pos}]-1cnt[apos​]←cnt[apos​]−1，若 cnt[apos]=0cnt[a_{pos}]=0cnt[apos​]=0（少了一个数），now←now−1now\gets now-1now←now−1。
其他的正常地跑莫队即可。但此题似乎卡常。
例题：P2709 小B的询问
简要题意：给出一个长度为 nnn 的数列 aaa（值域 [1,k][1,k][1,k]），mmm 个询问，每次询问给出数对 l,rl,rl,r 表示查询：
∑i=1kci2\sum\limits_{i=1}^k c_i^2
i=1∑k​ci2​
其中 cic_ici​ 表示数字 iii 在 [l,r][l,r][l,r] 中的出现次数。
数据范围：1≤n,m,k≤5×1041\le n,m,k \le 5\times 10^41≤n,m,k≤5×104。
难度依然在于如何 O(1)O(1)O(1) 转移答案。
ccc 数组很好维护，但答案（设它为 sss）就不那么好维护了。
由于每次添加或删除数时只会改变 ca[pos]c_{a[pos]}ca[pos]​，而且只会 ±1\pm1±1。所以：
由
s=∑i=1kci2=c12+⋯+ca[pos]2+⋯+ck2s=\sum\limits_{i=1}^k c_i^2=c_1^2+\cdots+c_{a[pos]}^2+\cdots+c_k^2
s=i=1∑k​ci2​=c12​+⋯+ca[pos]2​+⋯+ck2​
可得
s′=c12+⋯+(ca[pos]±1)2+⋯+ck2=c12+⋯+ca[pos]2±2×ca[pos]+1+⋯+ck2=s±2×ca[pos]+1\begin{aligned}
	s&#x27;&amp;=c_1^2+\cdots+(c_{a[pos]}\pm 1)^2+\cdots+c_k^2\\
	&amp;=c_1^2+\cdots+c_{a[pos]}^2\pm2\times c_{a[pos]}+1+\cdots+c_k^2\\
	&amp;=s\pm2\times c_{a[pos]}+1
\end{aligned}
s′​=c12​+⋯+(ca[pos]​±1)2+⋯+ck2​=c12​+⋯+ca[pos]2​±2×ca[pos]​+1+⋯+ck2​=s±2×ca[pos]​+1​
转移时修改即可。
例题：P5268 [SNOI2017] 一个简单的询问
简要题意：给出一个长度为 nnn 的数列 aaa（值域 [1,n][1,n][1,n]），mmm 个询问，每次询问给出数对 l1,r1,l2,r2l_1,r_1,l_2,r_2l1​,r1​,l2​,r2​ 表示查询：
∑x=0∞get(l1,r1,x)×get(l2,r2,x)\sum\limits_{x=0}^\infty \text{get}(l_1,r_1,x)\times \text{get}(l_2,r_2,x)
x=0∑∞​get(l1​,r1​,x)×get(l2​,r2​,x)
get(l,r,x)\text{get}(l,r,x)get(l,r,x) 表示区间 [l,r][l,r][l,r] 中 xxx 的出现次数。
数据范围：n,m≤5×104,1≤ai≤nn,m\le 5\times 10^4,1\le a_i\le nn,m≤5×104,1≤ai​≤n。
首先因为每次询问给出的是一个四元组，所以莫队不能直接做。
考虑对询问进行拆分。
可以发现，get(l,r,x)=get(1,r,x)−get(1,l−1,x)\text{get}(l,r,x)=\text{get}(1,r,x)-\text{get}(1,l-1,x)get(l,r,x)=get(1,r,x)−get(1,l−1,x)。展开：
（为方便，记 g(p)=get(1,p,x)\text{g}(p)=\text{get}(1,p,x)g(p)=get(1,p,x)）
∑x=0∞get(l1,r1,x)×get(l2,r2,x)=∑x=0∞(g(r1)−g(l1−1))×(g(r2)−g(l2−1))=∑x=0∞g(r1)×g(r2)−g(l1−1)×g(r2)−g(l2−1)×g(r1)+g(l1−1)×g(l2−1)\begin{aligned}
	&amp;\sum\limits_{x=0}^\infty
	\text{get}(l_1,r_1,x)\times\text{get}(l_2,r_2,x)\\
	=&amp;\sum\limits_{x=0}^\infty
	\big(\text{g}(r_1)-\text{g}(l_1-1)\big)\times
	\big(\text{g}(r_2)-\text{g}(l_2-1)\big)\\
	=&amp;\sum\limits_{x=0}^\infty
	\text{g}(r_1)\times\text{g}(r_2)-\text{g}(l_1-1)\times\text{g}(r_2)\\
	&amp;-\text{g}(l_2-1)\times\text{g}(r_1)+\text{g}(l_1-1)\times\text{g}(l_2-1)
\end{aligned}
==​x=0∑∞​get(l1​,r1​,x)×get(l2​,r2​,x)x=0∑∞​(g(r1​)−g(l1​−1))×(g(r2​)−g(l2​−1))x=0∑∞​g(r1​)×g(r2​)−g(l1​−1)×g(r2​)−g(l2​−1)×g(r1​)+g(l1​−1)×g(l2​−1)​
若记 ask(l,r)=g(l)×g(r)\text{ask}(l,r)=\text{g}(l)\times\text{g}(r)ask(l,r)=g(l)×g(r)，
原式=ask(r1,r2)−ask(l1−1,r2)−ask(l2−1,r1)+ask(l1,l2)\text{原式}=\text{ask}(r_1,r_2)-\text{ask}(l_1-1,r_2)-\text{ask}(l_2-1,r_1)+\text{ask}(l_1,l_2)
原式=ask(r1​,r2​)−ask(l1​−1,r2​)−ask(l2​−1,r1​)+ask(l1​,l2​)
肉眼可见，我们将原来的四元询问转换为四个二元询问。虽然 l,rl,rl,r 并不表示区间，但我们可以用相同的思想处理询问。
如何 O(1)O(1)O(1) 转移 ask(l,r)\text{ask}(l,r)ask(l,r)？
考虑若其中一个（g(l),g(r)\text{g}(l),\text{g}(r)g(l),g(r)）增加 1，则它们的积会增加另一个数。具体见代码。
核心代码：
// cl[i]: [1,l] 中 i 的个数；cr[i]: [1,r] 中 i 的个数；now: sum(cl[i]*cr[i])int cl[N],cr[N],now,ans[N];void mt()&#123;    init();    sort(q+1,q+(m&lt;&lt;2)+1);// 原来的一个询问拆成四个，所以 &lt;&lt;2    for(int i=1,l=0,r=0;i&lt;=(m&lt;&lt;2);i++)    &#123;        #define q q[i]        while(l&lt;q.l)++cl[a[++l]],now+=cr[a[l]];// 相应的转移        while(r&lt;q.r)++cr[a[++r]],now+=cl[a[r]];        while(q.l&lt;l)--cl[a[l]],now-=cr[a[l--]];        while(q.r&lt;r)--cr[a[r]],now-=cl[a[r--]];        ans[q.id]+=(q.t*now);        #undef q    &#125;&#125;int main()&#123;    ...    for(int i=1,l1,r1,l2,r2,p=1;i&lt;=m;i++)    &#123;        scanf(&quot;%d %d %d %d&quot;,&amp;l1,&amp;r1,&amp;l2,&amp;r2);        q[p++]=&#123;min(l1-1,l2-1),max(l1-1,l2-1),i,1 &#125;;// 拆开        q[p++]=&#123;min(l1-1,r2),  max(l1-1,r2),  i,-1&#125;;        q[p++]=&#123;min(l2-1,r1),  max(l2-1,r1),  i,-1&#125;;        q[p++]=&#123;min(r1,r2),	max(r1,r2),	i,1 &#125;;    &#125;    ...    return 0;&#125;
卡常：P1972 [SDOI2009] HH的项链
题意：同 DQUERY - D-query。但数据范围不同，还卡莫队。
我们就这么屈服了吗？没有！
其实本题莫队理论上 n=106,O(nn)≈109n=10^6,O(n\sqrt{n})\approx 10^9n=106,O(nn​)≈109 是可以过的，因为莫队经常跑不满。但经不住毒瘤出题人卡莫队。
考虑常数优化。注意到大部分时间花在转移 l,rl,rl,r 指针上。
由于 aia_iai​ 的波动程度可能非常大，又由于我们的转移方式是
while(q.l&lt;l)now+=(!(cnt[a[--l]]++));
访问 cnt 时下标波动程度大，导致访问慢。
如何加速？关键在于用等价但是数组访问只与下标有关的转移方式。因为下标经过排序后相对连续。
考虑记录两个数组 prei,nxtipre_i,nxt_iprei​,nxti​ 分别表示上一个和下一个出现 aia_iai​ 的位置的下标。如添加 l=il=il=i 时，r&lt;nxtir&lt;nxt_ir&lt;nxti​，即右边那个最近的 aia_iai​ 已经不在 [l,r][l,r][l,r] 中（显然左边那个更不会），那么 [l,r][l,r][l,r] 中多了一个不同的数，now←now+1now\gets now+1now←now+1。其他同理。
代码：
for(int i=1;i&lt;=n;i++)pre[i]=lst[a[i]],lst[a[i]]=i;fill(lst,lst+A,0x3f3f3f3f);for(int i=n;i;i--)nxt[i]=lst[a[i]],lst[a[i]]=i;for(int i=1,l=1,r=0;i&lt;=m;i++)&#123;    #define q q[i]    while(q.l&lt;l)now+=(nxt[--l]&gt;r);    while(r&lt;q.r)now+=(pre[++r]&lt;l);    while(l&lt;q.l)now-=(nxt[l++]&gt;r);    while(q.r&lt;r)now-=(pre[r--]&lt;l);    ans[q.id]=now;    #undef q&#125;
*带修莫队
简介
如何实现带修莫队？
发现普通莫队不支持修改，那么如何使它支持修改操作呢？
考虑存询问时加一个变量 tit_iti​ 表示进行此询问时前面修改了几次。同时存下每一个修改操作（无需排序）。
再新增一个指针 ttt 表示当前区间所在的时间位置。那么移动方向就从 444 个变为 666 个：[l−1,r,t],[l,r+1,t],[l+1,r,t],[l,r−1,t],[l,r,t−1],[l,r,t+1][l-1,r,t],[l,r+1,t],[l+1,r,t],[l,r-1,t],[l,r,t-1],[l,r,t+1][l−1,r,t],[l,r+1,t],[l+1,r,t],[l,r−1,t],[l,r,t−1],[l,r,t+1]。新增的两个为时间轴上的移动。
例题
例题：P1903 [国家集训队] 数颜色 / 维护队列
简要题意：给出一个长度为 nnn 的数列，mmm 个操作，要求支持两种操作：查询区间有多少不同的数、单点修改。
数据范围：n,m≤1.33333×105,ai≤106n,m\le 1.33333\times 10^5,a_i\le 10^6n,m≤1.33333×105,ai​≤106。
板子题，直接上代码：
constexpr int N=214514,A=1145141;// A：a 的值域int n,m,S,qm,a[N];// qm：询问的个数inline int bel(int x)&#123;return (x-1)/S+1;&#125;// 分块struct query&#123;    int l,r,t,id;// 额外记录时间    friend inline bool operator &lt; (query x,query y)    &#123;//		若 l 所在块不同	按 l 的块的编号 否则 若 r 所在块不同 按 r 的块的编号 否则按时间排        return (bel(x.l)^bel(y.l)?bel(x.l)&lt;bel(y.l):(bel(x.r)^bel(y.r)?bel(x.r)&lt;bel(y.r):x.t&lt;y.t));    &#125;&#125;;query q[N];struct modify// 新增：修改操作&#123;int p,v;&#125;;modify mo[N];int cnt[A],now,ans[N];// 类似于普通莫队void mt()&#123;    S=int(ceil(pow(n,0.66)));// 这里块长需要调整，具体可以可以看    // https://oi-wiki.org/misc/modifiable-mo-algo/ 中的证明    sort(q+1,q+qm+1);    for(int i=1,l=1,r=0,t=0;i&lt;=qm;i++)    &#123;        #define q q[i]        #define p mo[t].p        #define v mo[t].v        while(q.l&lt;l)now+=(!(cnt[a[--l]]++));// 类似        while(r&lt;q.r)now+=(!(cnt[a[++r]]++));        while(l&lt;q.l)now-=(!(--cnt[a[l++]]));        while(q.r&lt;r)now-=(!(--cnt[a[r--]]));        // 压行：先加时间 如果在当前区间内	   相应的转移	   *直接交换 v 和 a[p]        while(t&lt;q.t)&#123;t++;if(l&lt;=p&amp;&amp;p&lt;=r)now-=(!(--cnt[a[p]])-!(cnt[v]++));swap(a[p],v);&#125;        while(q.t&lt;t)&#123;if(l&lt;=p&amp;&amp;p&lt;=r)now-=(!(--cnt[a[p]])-!(cnt[v]++));swap(a[p],v);t--;&#125;        ans[q.id]=now;        #undef q        #undef p        #undef v    &#125;&#125;
*回滚莫队
简介
何时使用回滚莫队？
对于某些问题，普通莫队可能难以解决。原因在于删除和添加只有一个可实现。这时就需要回滚莫队了。
先看题：AT_joisc2014_c 歴史の研究。
简要题意：区间询问，给出一个长度为 nnn 的数列 aaa，mmm 个询问，每次询问要求回答
max⁡∀x{x×cnt⁡(x)}\max_{\forall x}\{x\times\operatorname{cnt}(x)\}
∀xmax​{x×cnt(x)}
其中 cnt⁡(x)\operatorname{cnt}(x)cnt(x)，表示 xxx 在 [l,r][l,r][l,r] 区间中的出现次数。
此题添加数很方便，但删除数却很麻烦。因为当最大值改变（如变小）时，我们无法确定新的最大值。
又如求区间 mex⁡\operatorname{mex}mex 时（P4137 Rmq Problem / mex），删除数方便，添加数麻烦。
这时就要用到回滚莫队了。它只用删除和添加中的一个操作，剩下的就回滚解决。
算法实现
算法流程

对原序列进行分块，对询问按以 bel[li]bel[l_i]bel[li​] 升序为第一关键字，rir_iri​ 升序为第二关键字排序。
如果 bel[li]≠bel[li−1]bel[l_i]\ne bel[l_{i-1}]bel[li​]​=bel[li−1​]，那么将 lll 初始化为 bel[li]bel[l_i]bel[li​] 的右端点的后一个位置，将 rrr 初始化为 bel[li]bel[l_i]bel[li​] 的右端点。
此时：

若 bel[li]=bel[ri]bel[l_i]=bel[r_i]bel[li​]=bel[ri​]，直接暴力回答。
反之，

移动 r→rir\to r_ir→ri​。
暂存当前答案 tmptmptmp。
移动 l→lil\to l_il→li​。
记录答案 ansi←nowans_i\gets nowansi​←now。
回滚，使 lll 回滚回 bel[li]bel[l_i]bel[li​] 的右端点的后一个位置，同时更新答案 now←tmpnow\gets tmpnow←tmp。





代码实现
typedef long long ll;//!constexpr int N=114514,INF=0x3f3f3f3f;int n,m;int a[N];int bel[N],S;struct query&#123;    int l,r,id;    friend inline bool operator &lt; (query x,query y)    &#123;return (bel[x.l]^bel[y.l]?bel[x.l]&lt;bel[y.l]:x.r&lt;y.r);&#125;&#125;;query q[N];ll ans[N],now,tmp;unordered_map&lt;int,int&gt; cnt,tcnt;void rbmt()&#123;    S=int(ceil(pow(n,.5)));    for(int i=1;i&lt;=n;i++)bel[i]=(i-1)/S+1;    sort(q+1,q+m+1);bel[q[0].l=0]=INF;    for(int i=1,l,r;i&lt;=m;i++)    &#123;        if(bel[q[i].l]^bel[q[i-1].l])cnt.clear(),now=-INF,r=bel[q[i].l]*S,l=r+1;        #define q q[i]        if(bel[q.l]==bel[q.r])        &#123;            tmp=-INF,tcnt.clear();            for(int j=q.l;j&lt;=q.r;j++)tmp=max(tmp,1ll*(++tcnt[a[j]])*a[j]);            ans[q.id]=tmp;        &#125;        else        &#123;            while(r&lt;q.r)now=max(now,1ll*(++cnt[a[++r]])*a[r]);            tmp=now;            while(q.l&lt;l)now=max(now,1ll*(++cnt[a[--l]])*a[l]);            ans[q.id]=now;            now=tmp;// rollback            while(l&lt;=bel[q.l]*S)--cnt[a[l++]];        &#125;        #undef q    &#125;&#125;int main()&#123;    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,a+i);    for(int i=1;i&lt;=m;i++)scanf(&quot;%d %d&quot;,&amp;q[i].l,&amp;q[i].r),q[i].id=i;    rbmt();    for(int i=1;i&lt;=m;i++)printf(&quot;%lld\n&quot;,ans[i]);    return 0;&#125;
莫队延迟更新答案
出处
该方法整理自：

「一叶知秋。」大佬的洛谷题解
「qwaszx」大佬的洛谷题解
「一扶苏一」大佬的洛谷题解

也许还有。我看到的就这些。
其实就是普通莫队的升级版。
算法思想 &amp; 实现
对莫队算法进行观察，不难发现移动 l,rl,rl,r 指针过程中的答案我们并不需要，于是就不一定要 O(1)O(1)O(1) 移动指针并更新答案。只需要能 O(1)O(1)O(1) 移动指针，并记录修改，移动 l,rl,rl,r 结束后再 ≤O(n)\le O(\sqrt{n})≤O(n​) 地更新答案即可。
这个寄巧很早就出现了，但无人详细记载，故记之。
更具体的，考虑 P4137 Rmq Problem / mex 这题。
此题 n,m,ai≤2×105n,m,a_i\le 2\times 10^5n,m,ai​≤2×105，我们可以进行值域分块，开个桶，cnticnt_icnti​ 表示 iii 在 [l,r][l,r][l,r] 中出现次数（而非是否出现，方便维护）。每个块 SSS 维护块内的数在 [l,r][l,r][l,r] 中出现的个数，即
exiS=∑i∈S[cnti&gt;0]exi_S=\sum_{i\in S}[cnt_i&gt;0]
exiS​=i∈S∑​[cnti​&gt;0]
当移动指针，添加/删除数时，直接修改 cntcntcnt，同时修改 exiexiexi。不急着更新答案，但移动指针结束后，扫过值域分块，O(n)O(\sqrt{n})O(n​) 更新答案 nownownow。具体的，O(n)O(\sqrt{n})O(n​) 遍历每个块 SSS，若 exiS=∣S∣exi_S=|S|exiS​=∣S∣，跳到下一个块，反之 mex⁡\operatorname{mex}mex 必定在块内，再次 O(n)O(\sqrt{n})O(n​) 遍历每个块内元素 i∈Si\in Si∈S，必定 ∃i,cnti=0,∀j&lt;i,cnti&gt;0\exist i,cnt_i=0,\forall j&lt;i,cnt_i&gt;0∃i,cnti​=0,∀j&lt;i,cnti​&gt;0，此时 iii 即为所求。
本质上，该方法就是利用莫队对答案修改 | 询问次数 O(nn)∣O(n)O(n\sqrt{n})|O(n)O(nn​)∣O(n) 的特性，调整对答案的维护复杂度，将原来维护的答案修改 | 询问复杂度 O(1)∣O(1)O(1)|O(1)O(1)∣O(1) 的高要求降为 O(1)∣O(n)O(1)|O(\sqrt{n})O(1)∣O(n​)，以适应更多题目。
但有时第一时间想到的是 O(n)∣O(1)O(\sqrt{n})|O(1)O(n​)∣O(1) 做法，此时就需要修改策略。
代码
constexpr int N=214514,B=514;int n,m,a[N];struct qry&#123;int l,r,id;&#125;;qry q[N];int S,bel[N];int cnt[N],exi[B];int ans[N];void mt()&#123;    S=int(ceil(n*pow(m,-.5)));    for(int i=0;i&lt;=n;i++)bel[i]=i/S+1;    std::sort(q+1,q+m+1,[](qry x,qry y)-&gt;bool    &#123;        return bel[x.l]!=bel[y.l]?        (bel[x.l]&lt;bel[y.l]):        (bel[x.l]&amp;1)==(x.r&lt;y.r);    &#125;);    for(int i=1,l=1,r=0,j,k;i&lt;=m;i++)    &#123;        #define q q[i]        while(q.l&lt;l)l--,exi[bel[a[l]]]+=!(cnt[a[l]]++);        while(r&lt;q.r)r++,exi[bel[a[r]]]+=!(cnt[a[r]]++);        while(l&lt;q.l)exi[bel[a[l]]]-=!(--cnt[a[l]]),l++;        while(q.r&lt;r)exi[bel[a[r]]]-=!(--cnt[a[r]]),r--;        for(j=1;exi[j]==S;j++);        for(k=(j-1)*S;cnt[k];k++);        ans[q.id]=k;    &#125;&#125;int main()&#123;    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,a+i);    for(int i=1;i&lt;=m;i++)scanf(&quot;%d %d&quot;,&amp;q.l,&amp;q.r),q.id=i;    mt();    for(int i=1;i&lt;=m;i++)printf(&quot;%d\n&quot;,ans[i]);    return 0;&#125;
例题：P5906 【模板】回滚莫队&amp;不删除莫队
对不住了，回滚莫队。
题意：给定一个序列，多次询问一段区间 [l,r][l,r][l,r]，求区间中相同的数的最远间隔距离。序列中两个元素的间隔距离指的是两个元素下标差的绝对值。
数据范围：1≤n,m≤2⋅1051\leq n,m\leq 2\cdot 10^51≤n,m≤2⋅105，1≤ai≤2⋅1091\leq a_i\leq 2\cdot 10^91≤ai​≤2⋅109。
考虑普通莫队。硬伤：当删除值时，若最大值改动，难以维护。
考虑离散化后对原题值域进行分块。维护每个值在 [l,r][l,r][l,r] 中的最远距离，同时维护块内距离最大值和全局最大值。此时复杂度（修改 | 询问）O(n)−O(1)O(\sqrt{n})-O(1)O(n​)−O(1)。
考虑转换成 O(n)−O(1)O(\sqrt{n})-O(1)O(n​)−O(1)。
「qwaszx」大佬的神之一手——再次值域分块！
刚才的对数进行值域分块就不要了，只要保存每个数在区间中最边缘的两个位置，同时分块改为对距离值域分块！具体的，cnticnt_icnti​ 表示有多少个数满足 [l,r][l,r][l,r] 内最远间隔距离为 iii，sumSsum_SsumS​ 表示块 SSS 内 cntcntcnt 之和，即 sumS=∑j∈Scntjsum_S=\sum_{j\in S}cnt_jsumS​=∑j∈S​cntj​。
若修改最远间隔距离，直接 O(1)O(1)O(1) 修改 cntcntcnt 和 sumsumsum，而查询时则从大往小扫过值域分块，具体的，块 TTT 为最大的一个块使得满足 sumT&gt;0sum_T&gt;0sumT​&gt;0，则一定 ∃k∈S,∀l,l&gt;k,cntl=0,cntk&gt;0\exist k\in S,\forall l,l&gt;k,cnt_l=0,cnt_k&gt;0∃k∈S,∀l,l&gt;k,cntl​=0,cntk​&gt;0。即 kkk 本身为最远间隔距离的最大值。
实现与 P4137 Rmq Problem / mex 类似。
例题：P3834 【模板】可持久化线段树 2
嘿嘿没想到吧，主席树！
又双㕛叒叕考虑值域分块。像上一题一样维护 cnt,sumcnt,sumcnt,sum，O(1)O(1)O(1) 修改。cnticnt_icnti​ 表示 [l,r][l,r][l,r] 内 iii 的数量。
从小到大扫过每个块，记录 sumsumsum 的前缀和，若前缀和 preS−1+sumS≥kpre_{S-1}+sum_S\ge kpreS−1​+sumS​≥k，则第 kkk 大在该区间内。从小到大扫过 SSS 内表示的每个数，累加 cntcntcnt 直到找到第 kkk 大。
结束
Thanks!\Huge
\text{Thanks!}
Thanks!

后记
此 PPT 是本人一边学习莫队一边写的，肯定有诸多不足，还请包容。
当然还有树上莫队、二维莫队，由于难度过高，我自己也不会，就不多做介绍了。可以通过 OI-Wiki 自学。
]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>数论</title>
    <url>/number-theory/</url>
    <content><![CDATA[长文警告。显然的性质略去不写或不证。
本文研究数论，故所有字母默认代表整数。

整除、约数和倍数
定义 若对于 a,b∈Z,a≠0a,b\in\mathbb{Z},a\ne 0a,b∈Z,a​=0，∃q∈Z,b=aq\exists q\in\mathbb{Z},b=aq∃q∈Z,b=aq，我们称 bbb 能被 aaa 整除，记作 a∣ba\mid ba∣b。反之则 bbb 不被 aaa 整除，记作 a∤ba\nmid ba∤b。
若 a∣ba\mid ba∣b，则 aaa 是 bbb 的约数（因数），bbb 是 aaa 的倍数。特殊的，000 是所有非 000 整数的倍数。对于 b≠0b\ne 0b​=0，±1,±b\pm 1,\pm b±1,±b 是 bbb 的平凡约数。其他则称为真约数（非平凡约数）。一般只考虑正整数之间的整除关系。
带余除法
定义 对于任意整数 a≠0,ba\ne 0,ba​=0,b，必然存在唯一的 q,rq,rq,r 使得 b=aq+r∧0≤r&lt;∣a∣b=aq+r\land 0\le r&lt;|a|b=aq+r∧0≤r&lt;∣a∣，我们称 a mod b=ra\bmod b=ramodb=r 为余数，qqq 为商，上述过程为带余除法， mod \bmodmod 为取模运算。这里只讨论最小非负余数带余除法。
素数 &amp; 合数
定义 设正整数 p&gt;1p&gt;1p&gt;1。如果 ppp 除了平凡约数外没有其他约数，那么称 ppp 为素数，反之为合数。这里只讨论正素数。这样，正整数分成了三类：111、素数和合数。
性质 1 任意正整数 nnn 的素因数中至多一个大于 n\sqrt{n}n​。
性质 2 若大于 111 的正整数 nnn 满足 ∀p∈[1,n]∪P, p∤n\forall p\in [1,\sqrt{n}]\cup\mathbb{P},\,p\nmid n∀p∈[1,n​]∪P,p∤n 那么 n∈Pn\in\mathbb{P}n∈P。
证明 2 反证法，若 nnn 为合数，则 ∃p,q, n=pq, 2≤p≤q\exists p,q,\,n=pq,\,2\le p\le q∃p,q,n=pq,2≤p≤q。故 p2≤np^2\le np2≤n 即 p≤np\le\sqrt{n}p≤n​。可得 ppp 的素因子 ≤n\le\sqrt{n}≤n​，且为 nnn 的约数，矛盾。
性质 2 体现了一个 O(n)O(\sqrt{n})O(n​) 时间判定 nnn 是否是质数的算法：枚举 ppp 并试除即可。
最大公约数 &amp; 最小公倍数
定义 一组整数的公约数整除组中所有整数。最大公约数为最大的公约数，记作 gcd⁡(a1,…,an)\gcd(a_1,\dots,a_n)gcd(a1​,…,an​)。
同理，一组整数的公倍数被组中所有整数整除。最小公倍数为最小的公倍数，记作 lcm⁡(a1,…,an)\operatorname{lcm}(a_1,\dots,a_n)lcm(a1​,…,an​)。
不引起歧义的情况下，可以简记 (a,b)=gcd⁡(a,b),[a,b]=lcm⁡(a,b)(a,b)=\gcd(a,b),[a,b]=\operatorname{lcm}(a,b)(a,b)=gcd(a,b),[a,b]=lcm(a,b)。
特殊的，我们定义若干个 000 的 gcd⁡\gcdgcd 和 lcm⁡\operatorname{lcm}lcm 均为 000。
裴蜀（Bézout）定理
裴蜀定理 对于任意整数 a,ba,ba,b，存在整数 x,yx,yx,y 使得 ax+by=gcd⁡(a,b)ax+by=\gcd(a,b)ax+by=gcd(a,b)。
证明 一般使用辗转相除法。当 a=0a=0a=0 或 b=0b=0b=0 时，可以发现定理成立。同时 gcd⁡(a,b)=gcd⁡(a,−b)\gcd(a,b)=\gcd(a,-b)gcd(a,b)=gcd(a,−b)，故与符合无关。综上不妨设 a,b&gt;0a,b&gt;0a,b&gt;0 且 a≥ba\ge ba≥b，d=gcd⁡(a,b)d=\gcd(a,b)d=gcd(a,b)。
将 aaa 带余除以 bbb，即 a=bq1+r1a=bq_1+r_1a=bq1​+r1​ 其中 0≤r1≤b0\le r_1\le b0≤r1​≤b，q1,r1q_1,r_1q1​,r1​ 为整数。若 r1=0r_1=0r1​=0 则辗转相除法结束，反之将 bbb 带余除以 r1r_1r1​，依次按下式进行带余除法：
a=bq1+r1(0≤r1&lt;a)b=r1q2+r2(0≤r2&lt;r1)r1=r2q3+r3(0≤r3&lt;r2)⋮⋮rn−2=rn−1qn+rn(0≤rn&lt;rn−1)rn−1=rnqn+1(0=rn+1&lt;rn)\begin{aligned}
	a&amp;=bq_1+r_1&amp;(0\le r_1&lt;a)\\
	b&amp;=r_1q_2+r_2&amp;(0\le r_2&lt;r_1)\\
	r_1&amp;=r_2q_3+r_3&amp;(0\le r_3&lt;r_2)\\
	&amp;\qquad\vdots&amp;\vdots\qquad\quad\\
	r_{n-2}&amp;=r_{n-1}q_n+r_n&amp;(0\le r_n&lt;r_{n-1})\\
	% r_{n-1}&amp;=r_nq_{n+1}+r_{n+1}&amp;(0\le r_{n+1}&lt;r_n)\\
	% r_{n-1}&amp;=r_nq_{n+1}&amp;(0=r_{n+1}&lt;r_n=1)\\
	r_{n-1}&amp;=r_nq_{n+1}&amp;(0=r_{n+1}&lt;r_n)\\
\end{aligned}
abr1​rn−2​rn−1​​=bq1​+r1​=r1​q2​+r2​=r2​q3​+r3​⋮=rn−1​qn​+rn​=rn​qn+1​​(0≤r1​&lt;a)(0≤r2​&lt;r1​)(0≤r3​&lt;r2​)⋮(0≤rn​&lt;rn−1​)(0=rn+1​&lt;rn​)​
因为 rn+1=0r_{n+1}=0rn+1​=0，退出。
从第一个到第 nnn 个式子依次可以得到 d∣r1,d∣r2,…,d∣rnd\mid r_1,d\mid r_2,\dots,d\mid r_nd∣r1​,d∣r2​,…,d∣rn​，故 d≤rnd\le r_nd≤rn​。
同时从第 n+1n+1n+1 个到第一个依次可得 rn∣rn−1,rn∣rn−2,…,rn∣b,rn∣ar_n\mid r_{n-1},r_n\mid r_{n-2},\dots,r_n\mid b,r_n\mid arn​∣rn−1​,rn​∣rn−2​,…,rn​∣b,rn​∣a。即 rnr_nrn​ 是 a,ba,ba,b 的公约数。又因为 ddd 是 a,ba,ba,b 的最大公约数，d≥rnd\ge r_nd≥rn​。
综上所述，d=rnd=r_nd=rn​，即 gcd⁡(a,b)=rn\gcd(a,b)=r_ngcd(a,b)=rn​。
由第 nnn 个式子可得
d=rn−2−rn−1qnd=r_{n-2}-r_{n-1}q_n
d=rn−2​−rn−1​qn​
由第 n−1n-1n−1 个式子可得
rn−1=rn−3−rn−2qn−1r_{n-1}=r_{n-3}-r_{n-2}q_{n-1}
rn−1​=rn−3​−rn−2​qn−1​
代入
d=rn−2−rn−1qn=rn−2−(rn−3−rn−2qn−1)qn=(qnqn−1+1)rn−2−(qn)rn−3\begin{aligned}
	d&amp;=r_{n-2}-r_{n-1}q_n\\
	&amp;=r_{n-2}-(r_{n-3}-r_{n-2}q_{n-1})q_n\\
	&amp;=(q_nq_{n-1}+1)r_{n-2}-(q_n)r_{n-3}
\end{aligned}
d​=rn−2​−rn−1​qn​=rn−2​−(rn−3​−rn−2​qn−1​)qn​=(qn​qn−1​+1)rn−2​−(qn​)rn−3​​
于是我们用 rn−2,rn−3r_{n-2},r_{n-3}rn−2​,rn−3​ 的线性组合表示了 ddd。以此类推，我们也可以用 a,ba,ba,b 的线性组合表示 ddd。
□\square□
算术基本定理
算术基本引理 设 p∈P,p∣a1a2  ⟹  p∣a1∨p∣a2p\in\mathbb{P},p\mid a_1a_2 \implies p\mid a_1\lor p\mid a_2p∈P,p∣a1​a2​⟹p∣a1​∨p∣a2​。
算术基本定理（唯一分解定理） 对于任意正整数 aaa，必然有表示
a=∏i=1npiα(i)a=\prod_{i=1}^{n}p_i^{\alpha(i)}
a=i=1∏n​piα(i)​
其中 pip_ipi​ 均为素数，αi\alpha_iαi​ 均为正整数，且满足 ∀1≤i&lt;n, pi&lt;pi+1\forall 1\le i&lt;n,\,p_i&lt;p_{i+1}∀1≤i&lt;n,pi​&lt;pi+1​。上式也称标准素因数分解式，其对于 aaa 唯一。同时，我们记 νp(i)(a)=αi\nu_{p(i)}(a)=\alpha_iνp(i)​(a)=αi​，即 aaa 的分解中 pip_ipi​ 的幂次。
同余
定义 对于整数 m≠0m\ne 0m​=0，若 m∣(a−b)m\mid (a-b)m∣(a−b)，则 mmm 称为模数，aaa 同余于 bbb 模 mmm。记作 a≡b(modm)a\equiv b\pmod ma≡b(modm)。另一种等价的定义是：a,ba,ba,b 除以 mmm 所得的余数相同。
一般的，只讨论 mmm 为正整数，bbb 为最小非负整数的情形。
类似等于，同余为等价关系，具有自反性、对称性、传递性，并可以左右同时进行线性运算、乘方。
同余类 &amp; 剩余系
定义 对于所有的 0≤i&lt;m0\le i&lt;m0≤i&lt;m，我们称 {j∣j mod m=i}\{j|j\bmod m=i\}{j∣jmodm=i} 为模 mmm 意义下的同余类，即同一个同余类内的数对模 mmm 同余。
如果 iii 还满足 i⊥mi\perp mi⊥m，则 {j∣j mod m=i}\{j|j\bmod m=i\}{j∣jmodm=i} 还称为既约同余类。
定义 在模 mmm 的剩余类中各取一个元素，则这 mmm 个数就构成了模 mmm 的一个 （完全）剩余系。
在模 mmm 的既约剩余类中各取一个元素，则这 mmm 个数就构成了模 mmm 的一个既约剩余系（缩剩余系，简化剩余系）。
数论函数
定义 数论函数即定义域为正整数的函数，也可以视作一个数列。
若该函数 f(n)f(n)f(n) 还满足对于任意互质正整数 x,yx,yx,y，都有 f(xy)=f(x)f(y)f(xy)=f(x)f(y)f(xy)=f(x)f(y)，则 f(n)f(n)f(n) 为积性函数。
更严格的，若 f(n)f(n)f(n) 满足对于任意正整数 x,yx,yx,y，都有 f(xy)=f(x)f(y)f(xy)=f(x)f(y)f(xy)=f(x)f(y)，则 f(n)f(n)f(n) 为完全积性函数。
费马（Fermat）小定理
欧拉（Euler）定理
ab≡{ab mod φ(m)gcd⁡(a,m)=1ab,gcd⁡(a,m)≠1,b&lt;φ(m)a(b mod φ(m))+φ(m)gcd⁡(a,m)≠1,b≥φ(m)(modm)a^b\equiv
\begin{cases}
	a^{b\bmod\varphi(m)}&amp;\gcd(a,m)=1\\
	a^b,&amp;\gcd(a,m)\ne 1,b&lt;\varphi(m)\\
	a^{(b\bmod\varphi(m))+\varphi(m)}&amp;\gcd(a,m)\ne 1,b\ge\varphi(m)
\end{cases}\pmod m
ab≡⎩⎪⎪⎨⎪⎪⎧​abmodφ(m)ab,a(bmodφ(m))+φ(m)​gcd(a,m)=1gcd(a,m)​=1,b&lt;φ(m)gcd(a,m)​=1,b≥φ(m)​(modm)
中国剩余定理（CRT）
威尔逊（Wilson）定理
参考

https://oi-wiki.org/math/number-theory/basic/

]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>2025 年暑假计划</title>
    <url>/plan-2025summer/</url>
    <content><![CDATA[
  40fff3a5cf27b77ac08956115c071329e5e28f65186d644c44ba8dad7423807a40f3801c0fa8a3872882060f80be8708d712878114bb007a5bd598498c6902ad1bef47d842cac34ef7ff285a3b22ed5b932a31a8393d64a1a943b37d3754afd3ce41e631c72b07dcdfaf0c9a00d162d8697f2afe446d5e976d1534caa73d84f044764181126078b0ab543abb1ccdd76fa3c25a4996f6ca4c228528c6730f8191520f08ef3195c94f4ad2d0ada51123ebb87d2dae183a2874d2a5a30b15ad3573f9f11d3d4a37609f9c431287e9ebd20f533a809b52ee7a4e6d1d87fabdca12ef75eeba1b47d32e7139f641f55a1ec3150114029062592b990b36dbb418e680ef6b6e767b8d3cef874da4734e95949fb81b6eeaa5452a3d5e7d64b0bb197ad1b4473c8b4c97485e9346c244992b885c2b8622778429b2f3305ccc0c8dd0abaf98a7dfe8ba8bc319f4fa2913fa18715f9a7947590360a7f6d15f1091683c8a530fb6c7405d3ba318bf1977fe55b4b34b956962912930c804838b29c2d12de85b12f054bc466f7f60936d98a6f03b4f0c0ddddcc1ba363cfe926ac11c5aadef5d83f0138c30e798e8d0c01f52ae60565e60ac0b8aca6e5e5e0d96307760e7727f60ab4d1867d121daeed4a5676b81552f7c484f7c55dcf7d61358a3f21a3debc33c6f646da1715d1dad5bcbff7c4a74d47ceadbe869b4ee57e1e3ce7deae6cb06a4afa65fd57341980c9071c2eb58dee55f2ef58314c0575596a40d452b8f9f0dd29bc20d6f2e01dbdcfd6027a014d5c8ff20760a0dca109cdeb133df2caae4102eb57f0b2d361af3ffd2dab8fa56966eaefb2740af6d258155974d3d32807f15f097f46dc42eb4207e1715cb04742ada9fae692d6fe5ac7a02fa5e2a1fb0db8c4f1e5f80f0f016a273fcb41424aa26878732be4066fb22cbf11eb61d5fdf51440c7ab236d3611cc6a807c52c1d87bbbb9d06df3fe801f896968ad94551d00ac06fd73400a597bb7e9847b1f6f8c603cb7594649f17d1a96b688e6531e9fb50ef9c4a787f7f5275476cd7e475a98e1e8df2c5e9d3aa5e0742de230910d77d141c68d9097f317e06d0db49c37c0f59acabb941eaa42db5c742baf6cab22d87850d0d32f909d029201b9d267a0c27980d4761cdb3dce6acd9d883e27b92bbf28baa18a5bcd64fe211783e64ecf651c6031743dcd6ab8be3790ea0cdfa6b22d349e9a7decf3f2a5d076b5cdd354d7ab52b2aeef126e6d96eaeb6ba37e7e960c774e5bb6d9811c8c5619ef2c86bf982f6fa049d13001d45becf75d1cef8e312ea4ee5df69527b7db0cbf868998ee7935a594c1da42994e5a3b5da0fd1fb94b229072cbf84339b27438ddc75279590b1648b6e4a4fe33558316845be0e9742963608ef30ba06396d6430e01732e42a9ce96cecfcf623cdc56aee1db93ef6f73d45274471e7effdd94d2d2393407fc396e56a70eb6749315d6ed1cee897dff2cf70fdfbba54407cd7ba019bb96fe772c8f23af6bb6c394e6b79c25d7d7b554a031f6cc0ea48b104045c884e6e5d17864df0ef007370b94718835e62fee08e6844da19c76cb8341f40eeaad881148cf046e6a14ef7606f4158c8b090edd915c8c58cbeae4f4c650696c61a0b96811dd49643e22899d337f6c33cbef3e4e517289053b0471cd1eaa56e12451baafb15f4a7ec2af6f6679e1b9e0eeebe5221eb95cdc190c19d2711ae584da12d80f4eb4717a5aa868c7d4bf6279b4759b4f2c2cbcd2622caea0de2c2ff61f422d6adf7494e5a36122a5f0350fc0ee971c2e9c46bb8c1dc73f09faf5b5376b2aa2d7fcbf3af28dfa8f89e121822ab50fcecb94223fa50ce6f58ea636d28e935239b4959f25700f517bb8e0ef1f71831e99e2f0b372a5c85f860716b49f9332fcb2bc6144e50a021586c9303c09e2d2f822598c8783421a9fa2094303f54a2d5921c1adbcae2615ca32901e684680ea7072eef52b8b73502ab490dad580106e53d70ec55609411e311797482aea2146a197eb3f53e498bc79c8fff28db0bce3b6f9ce3b00e9c4f5c3da12017707b0c730fb3cf8a5bfa3f5fd461ee282a6a0a167028eea142e12e99390b24043ae678716f2fa09f5865e0593e1e0cea5a99fa4ee9cb7d4f17f2a89deb1114cb6e20dfb69a151acd538b9b5abbef7b0bc8950951c59f786c1c28b2dce520c2f17fb65e241ab4638331318ed85b8ca25f3570625b467e100c8cc062c76bdfea7745e9a28f0e090607e4be67df58628ac12f12e538059a87d52a5b1400ec55da2b9087d90fe787685f0c7ea6c7b37d79261c426ea64f6fddaae820206f555302adf7421abcfd1428c3660e88c59aed0e84c76232139b25d6951e042d753ac8afbf36f7e3299d32803fbf08a68ab8796b33eb584fa2a835df6cae0ecfa40f8a75c17cd72b44322353e073b2d6bc9c45b766c053423a4db5f5411800ee64f92e237dac159bc248e9d32f69075cddfd98be53092c614ab2c01eaa4c0ab153c207c3abfadd2cc784457b7f98a806c6bb636d155250580b14c633239ab93cef5bf4774eae93357490bf38ad85d913b0a6e5f364182ddd7770eecbc2c8c5054ac073b9066db8c2905cb418203e511c2403b83e13098624e99da86eb543675bb869802d14e7d9431d124f337d9730b4caaecba12fc61f4186bccf99d9a2dfc39e47f584b2c8d13ef34fea260667aea9b25ba90d6400845ab61bfd5d2e052ab28aa538933b8be26fc1161f7661c6d16fd5fd188d38562811f29f2049ae7c060477ca8ae0291917ff055c996d0ce9b9f42581f940474f78374c89320c5e00c5170f9a370b473fc9948ab183c2bb9008118fb414d616a1f48e3c0ee313b5997623b7c137a19000a7361ee613b22d73ee3ef0b69eb44ad95c21251e9ee9408bf9215ba244500dec7733632655960e5acebac4f25bd408f131ca5943a33309aceab942e41fdd56b85e1a9b7f51001119619c67fc7b541ba3ef6667fb67b11177b7a3a11410b3f8c5ef92ec80006d10650137a8c5b44e20c1ff5beedc57154b914ac514dbe456ec926e66224d1855737088f92fadd3e085147e6509e78e3f8f3207061a06fdc007ba75cc01bcc86524c4cfcb6ea114e852ec0fde9dfa410e03fd2c1f6eab7be372cc492fd891a141885e66b7bab9bc694416308ac4185620f0086864444bb09a8c02dad4351d4e2e5158754e67ba65ee0a03bdb0c67db710d8dea061ff45dbb3d76ffdda85d3318436db7165ae0c290bb7aacba68b2c4f2a4fc2c6ed55c1b4c024313fa7d6975c744d368f1c9df58ed9d3552c99249fa308ee5812fc75c3345071965c2f88300bd62c34bc454bba57f3cdd9a8c2770bcf4e1d1d7503e2992414b0849ab673e1c52723ae71a8364243598625d2d91cfca2676a92ca9b0c4cbe0555ef4d935af4fa35e6dd8cdd27afc5a206b93b1b106b328a56af3290e37d666a02eaf40fc8519cc387517933832922595496ec0fcf0a226a0168f42455189348f277c8aa36addc88b3936bb9a78cdf51fc74777c154e9b7d55a0c9772c095c9e2c7dc2b24063f8fb44b739c7730210a9b05ac0cd915992c0b3eb0f8adea6d27fd3d7b4d64a7a3bc7792f0f8bd83d6be1e929f4786493b72710818c6d6851131d06de48ca03834dac13439cb11d66671d7876c8203e18dd1d645cfcad86b5f08889e630a4db218984032df91afcff89243bb6a8b9c1a69950695ab359663fd3b439edefca0a631fff35b864e6cb532682671700503b94639498946d4d71e6b84c82301352cea8af08ef2d48873e9ecde40ed78449905e95f317577bb6863771a8d80d861548502d8f89da5a35eabf7a22062ab816aba37572415defe16e5042852c39370743fea936ea4d480318f38bc3043a1fbdca237c875b6ee46453443c6a9c17881651e18ec3b075dfb808234c272f46a65d53d0b7bbb9908efe5c02dd696ebdf490c159e295768a345c9ceb78c2672c4b58d7368e8005b401520681b3483e18d1f13213ec6676141348acd6cde64b11431314a207ba647e132e6cc8ba735e7bcb19fc62a536fb277f70d85f2261cd5e7fc3cbe9fd96fc3406e63f9aa3c04cf737df22de2d3824f0609b6ae05ec94b7111b01af5de301b8530889b8ee5b7222cc51c5b167dc455036eb268fceab3fb622912c6e80fb7a6ae35b44ff8a8a7733658906c697b510d668871bae538d89cacebe389b81013278ed2fccc2b752d9fd50fa1f85f249c5fe47197afaf2412cc7ca277842394cfc3f05046ddef85be38149793cf6b22cfe3164fa3495e70a0e64f8a44300c7c88a6ce436caedc9c3093f8150a878e1ced60eaef9c18a3eb4289c844fe0acedbb99bbb4789cffe5d051cfe86d73b41dd4189ca33894f4aa5a3cf26acdf5eb5c3299e9e1524c514090dfda9d4627b6fba78bd2a16c496ac1d9021261fcbbef97ad8178546a9fccdedd2e90db99fbef734afd42363d03f62c281f972f3a7bed07606b6656027027ab0e1e4ef0c4c1ba3760a436067ab9643792773938838946afd502c31cc30ddd55dc2828825b38e8bee58f399ee8da3c94b60e2ca54b69e79a47296e2d2b57461330dd8d7be76e817f7cfa56cda0974c711b09e5912ce5a82ff6a360415f1aace22ce07c3340f819d4b157a265fc0d6e79bc1d3fc7670775f6cbf108daa3c37fc51ba548cd9a5c3b72ea9f20219a398e4233c5c1cc55af9d961c3a1f4e068a7d0b26c8be0c6aacf22f8fb4feca80ad80518a9639f818e03d670f1adfc99bd22a913a03e3071f3e9efe0939e2ccf5533910b8c5a591abe6a858004badbb7c831149895fe827a824bb38f07f74d4af0a5b2e2e378977b7a62b08485c05127465a01dfecaf33c65a2a9989d2658095d56e3f7537d81f244561f777dae0a6ba30c8a4372c6680c299b0159d956bd96371d492046ffd4f4f36d8e6858b6abf726d17327889004664c05a842dff3c610e861cfa2d85ac8d093a2617b61b01ee4a7d9797b6dcf32fe8a62e03cf5bb8c6d296fe175cb3f67d40b04ad4bd6d23c337a24b19e9ca7893b0e33d18b5cec244ecbd082f049a65104bbc16fd6aa5e3d69e26921556281ae0543bb0b950c4c5fe304170829b0f7304923dd02f2b00b4e27de5b96416a0762113feb1a2d19bd6045ecee9901134a3cfeac0a490bdfd35d5c858cedf79005c1c0452cf57813af403ac2e3a22a49f3912b54626131ed55f8e3bb1ab62b9963ad7e24a2ee32f3293f6cf76d004c20fc23ec1dfd04dac0b2d20cff61b8d543427d62b0df4857ac86408a9e14b832f58af26eab0bda95ea5848d0fe82890bbd55d639de90ba868e0eb24fbe8352f937a268bf4e84ba5b627e66c5e0af68ca092897fc9c1b69c1c21ccb4e2de65e62139c303b0a58b7cf66fcf3d850c6284ea75f3be66cb411f6d0d779a64c6b4213e5cc16c557bd3b7ec2bc00349364639f5eb6c94d9deecb253cb7dd24c725743ffca7fa8daa8a2d3eb5813ffca317084eca98f9e64fbd8088808ded87ea6d8fa2e0c7ce70468a92a13beb2bbe8e4c82e689b2eef52cc2c36fd1bdfa3860cced3c46fc5f2d05c5e22488cff6248bb0c763c69b7509e0ae89222d092b0162057ab18649d47e2d50078379a9af40c608c20d9668b1cfa075674ee5fe378e1853c40b7bd7c0b521e1f063a46450ad50fa230c8f93b8672b960d72265c0dca2509fe675e71261aaa993164f7b13bb8a6c3e2f7b1f4cf5e6ef115a5173a0aa009b0800f2ecb0b6317d57ddd05c75f535ed84b0a96f85046ea980501b23ddf1f827ae3f9f4ddd83adb48fc635422f2a68b82c5146f2c47081d8d3ff723f1a295120a2dd964aa84303f247667dcb05470bf9a7d315cdafdaea1e56349cea6e839506fb24af52818d683058eb97336005dc32ad389d25bdd4617d8f53fb8ad27b5ca4929290a7ff53659e4a20a43ee09b05c9229da2f449a8cedbf2b7a1a8c0b3b10773867bccef1100b2cccb22896e7aaca9fa7832e0f8783a985018c564d664a68a280eac49e30a3b83d9c75a2d6d7b1bd381b1e1516a76ba82c5446e0ebf7058728d11c74d4fc2757bc24d726149a310c0042b8ed6ff3f3c1cace23a794b91365bec5e323dc9ca7613e2983aeb30a8f097115f790a4d094a912ee8311f0e0cbdf1c22efb7d3143a98eb99a047ab3b183423a0cb2efe619860e906e77fca3953aae230bb8db0b7f8aa6c15687eddfd2c796a7308ff9c596102e8df0eb406936566b92969a57a7b6a5294d2c42d3c93584b1486fcd4b607eb056124d538d1b628031c01b31346fe443afa54881e7f036a332c727b549956525918238366e74a2609bb2f0ac9b5e5c9cbe5d78d4e8c0fedf4c2af8ca4b0148bbc0fb6d345ea3f075b0ab7e90fba80c2822a425627f175c06456b75c77ab373f90f323ac3707954ee39638a412dd9efdd4dc7d4151584301c17d5238b069c301ac0a92fb7250aac55e194ed9e190003732e787b3933b49837e7309b97bc97a5922702240ac60f7af25d0ffda33e56000c4d1903a88b16705a42376d544a0a202a159cdff88fb711d2b884cd8a53237ec776d838454acf4364c6e857b07b9399fa8d2b9756781366da63062d0462337d07e72647c977b11344678deccb8c0c83249819ee6a20507c9a1ec4f81db9d11eece4325c6440b7d5cb82873632a9ac7c6f21dfd6c0a915d6994a66e8d4f6135180de35a9079b8a9d808c6624ed373c1086d028e30ce25d901570dfbb79c65167061237f3e5cff524b7d3d80b149136dce1f7f3353585954a8f419485fd3abc45cb8e954557b6891af63095272282fa8933ed3c54e6181c77c6310129cfcf135daee7a2c58451b5a8ce8f4a8a3e5cc4abe9a38c06eb4b4631d07e30044af224c52008714ca039e1258bee336780e59d32fed6810256dbd49e405ec71e53a7bdb63881285d892ae2e57fbf10d38e8ac00861285e4dd49e731b28d1c797e0150adeefd71bfcaf04329eb865156d5ccd63d3feccc97470933840ee95f5061f2636f381fabf092145f83ff6646e4d749191431f93c3c0af4eb8e91692404fbd506966563d647187b2a69ebf5bff451e07a109eff0a78378c62025b5b14a0310083f7804a99be1c40b2a08bf76a22245d5a24e2ac905ad5ddc7049cd91822f3c6f72b08f9ed1c134c04de7e851cff307e21299f1d0de37623bd8470f3ef273e3c0d71fe52efd4d54d1bb645522e8a510f671a8ed7a6d74421d6b2c527af6dbc2d63185863589d8cd4ea3e9449cf2cf4a0c8613a261564a11dcb5c6cb37ca8f3c46d82bc12be40272cbfc3c0a1bc05b08bbf58fbae9b6aa7c0100f26fb8d88436826281835dcf00801b22624aeb1b26cb103c4bf08870178efee319eabf6086359d4be698445aec08abebbfc291c2e457e8852e73d3a131e538ef989e39785fb2767dde38c17e158f6daf421a2e4c190dc2e7c4d1bda9e8356d01c476f468faf7eaf553ba818a96341fe01ea533cf453b
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/string/</url>
    <content><![CDATA[本文字符串下标从 111 开始，无歧义时默认 nnn 为当前所述字符串长度。

自动机
自动机（automaton） 是一种对信号序列进行判定的数学模型，可以模拟人类的思考方式，对给定的一串信号给出真或假的判定。
确定有限状态自动机（DFA） 是自动机的一种，在 OI 中较常用，其中信号序列一般使用字符串。
形式化地说，它由五部分组成：

字符集（Σ\SigmaΣ），为信号序列所含信号组成的集合。
状态集合（QQQ），为所有状态构成的集合。DFA 有许多不同含义的状态，可以视作有向图中点。QQQ 可以视作点集。
起始状态（sss），s∈Qs\in Qs∈Q，为一个特殊的状态，是所有转移的起点。
接受状态集合（FFF），F⊆QF\subseteq QF⊆Q，为一些特殊的状态，是判定的依据。
转移函数（δ\deltaδ），δ(u,c)\delta(u,c)δ(u,c) 表示 DFA 在读取到字符 ccc，且当前在状态 uuu 的情况下，DFA 的状态转移到 δ(u,c)\delta(u,c)δ(u,c)。如果 uuu 没有 ccc 的转移，则约定 δ(u,v)←null\delta(u,v)\gets\mathrm{null}δ(u,v)←null。null∉F\mathrm{null}\notin Fnull∈/​F 是一个特殊的状态，其不能转移到任何其他状态，不是可接受状态。

若将 DFA 视作有向图，则状态集合可视作点集，转移函数可以视作有向图的边。
设 DFA A=(Σ,Q,s,F,δ)A=(\Sigma,Q,s,F,\delta)A=(Σ,Q,s,F,δ) 判定信号序列 SSS，我们有 AAA 工作流程：

设当前状态 uuu，uuu 初始时为 sss；
对于 SSS 中的每一个字符 ccc，执行 u←δ(u,c)u\gets\delta(u,c)u←δ(u,c)，即通过转移函数，转移到新状态；
记 A(S)=[u∈F]A(S)=[u\in F]A(S)=[u∈F] 表示是否接受 SSS。

Trie
考虑构建一个自动机，使得其只接受字符串 sss。很显然，我们可以对 sss 的所有前缀建立状态，将该前缀称为其状态的对应串，然后在所有相邻前缀的状态间建立转移即可。类似的，若使其只接受字符串集合 SSS 中的字符串，可以依次建立状态。上述自动机即为 Trie 树。
形式化地说，构建一颗 Trie 树需要以下步骤：

对于 SSS 中每个字符串 sss，枚举其前缀 s(1,i)s(1,i)s(1,i)，即遍历 i=1…∣s∣i=1\dots |s|i=1…∣s∣；
设状态 uuu 的对应串为 s(1,i)s(1,i)s(1,i)，状态 vvv 的对应串为 s(1,i−1)s(1,i-1)s(1,i−1)。如果不存在状态对应 s(1,i)s(1,i)s(1,i)，新建一个状态；
构建转移 δ(v,s(i))←u\delta(v,s(i))\gets uδ(v,s(i))←u。

         he* -&gt; her*        /(s) -&gt; h -&gt; hi -&gt; his*  \   i -&gt; it*
上图为 S={he,her,his,it}S=\{\texttt{he},\texttt{her},\texttt{his},\texttt{it}\}S={he,her,his,it} 时的 Trie 树。其中 (s) 为起始状态，每个字符串都代表一个状态，-&gt;、\、/ 代表状态间的转移，带 * 的是接受状态。
KMP 与 AC 自动机
自动机结构
我们希望借助自动机完成下述任务：给定字符串 s,ts,ts,t，找出所有等于 ttt 的 sss 的子串。
我们知道 sss 的子串相当于 sss 的一个前缀的一个后缀，所以我们考虑建立一个自动机使得其只接受后缀为 ttt 的字符串，然后依次判定 sss 的每个前缀（输入串）。
类似 Trie，我们对 ttt 的所有前缀建立状态，将该前缀称为其状态的对应串，并让每个状态表示输入串的某个后缀等于该状态的对应串。
设状态 uuu 的深度 dep(u)dep(u)dep(u) 为其对应串长度，定义邻转移为 uuu 到 vvv 的转移，使得 v=δ(u,c)∧dep(v)=dep(u)+1v=\delta(u,c)\land dep(v)=dep(u)+1v=δ(u,c)∧dep(v)=dep(u)+1。那么显然可以建立若干邻转移，其他默认转移到初始状态 sss（sss 对应串为 ∅\varnothing∅）。如下图中，所有 -&gt; 均为邻转移。
(s) -&gt; a -&gt; ap -&gt; app -&gt; appl -&gt; appl -&gt; apple
但由于一个输入串有若干后缀，可能满足多个状态。可以发现较短后缀一定是较长后缀的后缀，即符合状态 uuu 的输入串一定符合对应串是“uuu 的对应串的后缀”的状态。
所以我们修改定义，令每个状态表示输入串的某个后缀等于该状态的对应串，且不存在更长的后缀等于其他状态对应串。也就是说，输入串只满足最长可匹配后缀的状态。
自然的，对于状态 uuu，若状态 vvv 是对应串最长的状态，使得 vvv 的对应串是 uuu 的对应串的真后缀，则称 uuu 的失配链接（fail 指针）指向 vvv。通过不断地跳失配链接，我们可以遍历所有对应串是“uuu 的对应串的后缀”的状态。值得注意的是，失配链接并非转移，其表达的是一种“继承”关系。若 δ(u,c)=s\delta(u,c)=sδ(u,c)=s，我们可以 δ(u,c)←δ(v,c)\delta(u,c)\gets\delta(v,c)δ(u,c)←δ(v,c)，即继承 vvv 的转移。故这些继承来的转移也可以视作跳若干次失配链接后邻转移。
                           fail             &lt;===============================(s) -&gt; t -&gt; to -&gt; tom -&gt; toma -&gt; tomat -&gt; tomato
如上图，tomato 的失配链接指向 to。
构建过程

建立初始状态 sss；
遍历 i=1…∣t∣i=1\dots |t|i=1…∣t∣，

设 s(1,i)s(1,i)s(1,i) 的状态为 uuu，s(1,i−1)s(1,i-1)s(1,i−1) 的状态为 vvv，状态 xxx 的失配链接为 f(x)f(x)f(x)；
f(u)←δ(f(v),s(i))f(u)\gets\delta(f(v),s(i))f(u)←δ(f(v),s(i))；
δ(v,s(i))←u\delta(v,s(i))\gets uδ(v,s(i))←u；
δ(u,∗)←δ(f(u),∗)\delta(u,*)\gets\delta(f(u),*)δ(u,∗)←δ(f(u),∗)；



复杂度分析
不难发现判定一个字符串 sss 的时间复杂度为均摊 O(∣s∣)O(|s|)O(∣s∣)，但构建 KMP 自动机的时间复杂度为 O(∣Σ∣∣t∣)O(|\Sigma||t|)O(∣Σ∣∣t∣)，因为需要拷贝转移。故实际实现中不会拷贝继承来的转移，构建时间复杂度就降到了 O(∣t∣)O(|t|)O(∣t∣)，判定字符串时直接跳失配链接，不难证明判定时间复杂度仍为 O(∣s∣)O(|s|)O(∣s∣)。
综上 KMP 算法时间复杂度为 O(∣s∣+∣t∣)O(|s|+|t|)O(∣s∣+∣t∣)。
推广
上述 DFA 即为 KMP 自动机，观察其形态可以发现其邻转移形成一条链，其他继承来的转移为“返祖边”。结合 Trie 的思想，我们就可以造出 AC 自动机。但这次我们就需要拷贝继承来的转移，（为什么？）。
如果你理解了 KMP 自动机，那么 AC 自动机的构建方式就十分显然了。
后缀数组（SA）
定义 sufi←s[i,n]suf_i\gets s[i,n]sufi​←s[i,n]，rkirk_irki​ 为 sufisuf_isufi​ 在所有后缀中的字典序排名，saisa_isai​ 为字典序第 iii 小的后缀。rk,sark,sark,sa 互逆。
例如 s=aababs=\texttt{aabab}s=aabab 时，aabab&lt;ab&lt;abab&lt;b&lt;bab\texttt{aabab}&lt;\texttt{ab}&lt;\texttt{abab}&lt;\texttt{b}&lt;\texttt{bab}aabab&lt;ab&lt;abab&lt;b&lt;bab，所以 rk=[1,3,5,2,4],sa=[1,4,2,5,3]rk=[1,3,5,2,4],sa=[1,4,2,5,3]rk=[1,3,5,2,4],sa=[1,4,2,5,3]。
后缀排序指求上述数组的过程。
O(nlog⁡2n)O(n\log^2n)O(nlog2n) 做法
考虑朴素倍增。不妨定义 rki,j′rk&#x27;_{i,j}rki,j′​ 表示将 s[∗,∗+2j−1]s[*,*+2^j-1]s[∗,∗+2j−1] 按字典序排序后 s[i,i+2j−1]s[i,i+2^j-1]s[i,i+2j−1] 的排名，sai,j′sa&#x27;_{i,j}sai,j′​ 同理。
倍增分为 log⁡n\log nlogn 轮，第 jjj 轮得到 rki,j′,sai,j′rk&#x27;_{i,j},sa&#x27;_{i,j}rki,j′​,sai,j′​。
具体地，在第 jjj 轮中，按 (rk∗,j−1′,rk∗+2j−1−1,j−1′)\left(rk&#x27;_{*,j-1},rk&#x27;_{*+2^{j-1}-1,j-1}\right)(rk∗,j−1′​,rk∗+2j−1−1,j−1′​) 排序，得到 sai,j′sa&#x27;_{i,j}sai,j′​ 并推出 rki,j′rk&#x27;_{i,j}rki,j′​，注意需要去重。
最终 rki←rki,log⁡n′,sai←sai,log⁡n′rk_i\gets rk&#x27;_{i,\log n},sa_i\gets sa&#x27;_{i,\log n}rki​←rki,logn′​,sai​←sai,logn′​，即倍增覆盖长度大于 nnn，使 sufisuf_isufi​ 等价于 s[i,i+2j−1]s[i,i+2^j-1]s[i,i+2j−1] 后结束。
O(nlog⁡n)O(n\log n)O(nlogn) 做法
考虑到两个关键字的值域都为 O(n)O(n)O(n)，可以使用基数排序，复杂度即可优化到 O(nlog⁡n)O(n\log n)O(nlogn)。
#include &lt;bits/stdc++.h&gt;using std::cin;typedef long long ll;constexpr int N=2e6+114;int n;std::string s;int sa[N],rk[N],id[N],ork[N],buc[N];inline void build()&#123;    int m=1&lt;&lt;7,k=0;    for(int i=1;i&lt;=n;i++)buc[rk[i]=s[i]]++;    for(int i=1;i&lt;=m;i++)buc[i]+=buc[i-1];    for(int i=n;i;i--)sa[buc[rk[i]]--]=i;    for(int j=1;;m=k,k=0,j&lt;&lt;=1)    &#123;        for(int i=n-j+1;i&lt;=n;i++)id[++k]=i;        for(int i=1;i&lt;=n;i++)if(sa[i]&gt;j)id[++k]=sa[i]-j;        std::fill(buc+1,buc+m*2+1,0);        std::copy(rk+1,rk+n*2+1,ork+1);        k=0;        for(int i=1;i&lt;=n;i++)buc[rk[i]]++;        for(int i=1;i&lt;=m;i++)buc[i]+=buc[i-1];        for(int i=n;i;i--)sa[buc[rk[id[i]]]--]=id[i];        for(int i=1;i&lt;=n;i++)rk[sa[i]]=            (ork[sa[i-1]]==ork[sa[i]]&amp;&amp;ork[sa[i-1]+j]==ork[sa[i]+j])?k:++k;        if(k==n)break;    &#125;&#125;int main()&#123;    std::ios::sync_with_stdio(false);    cin.tie(nullptr);    cin&gt;&gt;s;    n=s.size();    s=&#x27; &#x27;+s;    build();    for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,sa[i]);    return 0;&#125;
注意 rk′rk&#x27;rk′ 严格满足排名的定义（即小于本身的不同元素的数量），可以维护 rki,j′rk&#x27;_{i,j}rki,j′​ 的值域 mmm，当 m=nm=nm=n 时直接退出。
同时对第二关键字的排序是不必要的，对于 i∈[n−2j+1,n]i\in[n-2^j+1,n]i∈[n−2j+1,n]，rki+2j,j−1′=0rk&#x27;_{i+2^j,j-1}=0rki+2j,j−1′​=0，直接将它们放置在 sai,j′sa&#x27;_{i,j}sai,j′​ 的开头，其他的按照 rki+2j,j−1′rk&#x27;_{i+2^j,j-1}rki+2j,j−1′​ 顺序即可。
hththt 数组
记 lcp⁡(i,j)\operatorname{lcp}(i,j)lcp(i,j) 为 sufi,sufjsuf_i,suf_jsufi​,sufj​ 的最长公共前缀，hti←∣lcp⁡(sai−1,sai)∣,ht1←0ht_i\gets|\operatorname{lcp}(sa_{i-1},sa_i)|,ht_1\gets 0hti​←∣lcp(sai−1​,sai​)∣,ht1​←0。
结论 1 若 rki≤rkj≤rkkrk_i\le rk_j\le rk_krki​≤rkj​≤rkk​，则 ∣lcp⁡(i,j)∣,∣lcp⁡(j,k)∣≥lcp⁡(i,k)|\operatorname{lcp}(i,j)|,|\operatorname{lcp}(j,k)|\ge\operatorname{lcp}(i,k)∣lcp(i,j)∣,∣lcp(j,k)∣≥lcp(i,k)。
结合图片容易理解，lcp⁡\operatorname{lcp}lcp 实际上是一个取区间 min⁡\minmin，也就是说：
结论 2 若 rki&lt;rkjrk_i&lt;rk_jrki​&lt;rkj​，则 ∣lcp⁡(i,j)∣=min⁡k=rk(i)+1rk(j)htk|\operatorname{lcp}(i,j)|=\min\limits_{\mathclap{k=rk(i)+1}}^{rk(j)}ht_k∣lcp(i,j)∣=k=rk(i)+1​minrk(j)​htk​。
大区间的最小值自然不大于其子区间的最小值。
求 hththt 数组所需的一个重要引理：
ht(rki)≥ht(rki−1)−1ht(rk_i)\ge ht(rk_{i-1})-1
ht(rki​)≥ht(rki−1​)−1
证明
记 i−1i-1i−1 的前驱 p←sa(rki−1−1)p\gets sa(rk_{i-1}-1)p←sa(rki−1​−1)，根据定义 ht(rki−1)=∣lcp⁡(sa(rki−1−1),sa(rki−1))∣=∣lcp⁡(p,i−1)∣ht(rk_{i-1})=|\operatorname{lcp}(sa(rk_{i-1}-1),sa(rk_{i-1}))|=|\operatorname{lcp}(p,i-1)|ht(rki−1​)=∣lcp(sa(rki−1​−1),sa(rki−1​))∣=∣lcp(p,i−1)∣。
假设 ht(rki−1)&gt;0ht(rk_{i-1})&gt;0ht(rki−1​)&gt;0，则显然
∣lcp⁡(p+1,i)∣=∣lcp⁡(p+1,i−1+1)∣=∣lcp⁡(sa(rki−1−1)+1,sa(rki−1)+1)∣=∣lcp⁡(sa(rki−1−1),sa(rki−1))∣−1=ht(rki−1)−1\begin{aligned}
	|\operatorname{lcp}(p+1,i)|&amp;=|\operatorname{lcp}(p+1,i-1+1)|\\
	&amp;=|\operatorname{lcp}(sa(rk_{i-1}-1)+1,sa(rk_{i-1})+1)|\\
	&amp;=|\operatorname{lcp}(sa(rk_{i-1}-1),sa(rk_{i-1}))|-1\\
	&amp;=ht(rk_{i-1})-1
\end{aligned}
∣lcp(p+1,i)∣​=∣lcp(p+1,i−1+1)∣=∣lcp(sa(rki−1​−1)+1,sa(rki−1​)+1)∣=∣lcp(sa(rki−1​−1),sa(rki−1​))∣−1=ht(rki−1​)−1​
即同时删去第一个字符，lcp⁡\operatorname{lcp}lcp 减 111。
同时因为 ht(rki−1)&gt;0,rkp&lt;rki−1ht(rk_{i-1})&gt;0,rk_p&lt;rk_{i-1}ht(rki−1​)&gt;0,rkp​&lt;rki−1​，不难发现 rkp+1&lt;rkirk_{p+1}&lt;rk_irkp+1​&lt;rki​。根据结论 1，
∣lcp⁡(sa(rki−1),i)∣≥∣lcp⁡(p+1,i)∣ht(rki)≥ht(rki−1)−1\begin{aligned}
	|\operatorname{lcp}(sa(rk_i-1),i)|&amp;\ge|\operatorname{lcp}(p+1,i)|\\
	ht(rk_i)&amp;\ge ht(rk_{i-1})-1\\
\end{aligned}
∣lcp(sa(rki​−1),i)∣ht(rki​)​≥∣lcp(p+1,i)∣≥ht(rki−1​)−1​
□\square□
以上内容可以结合下图理解。
s=aabbabap=sa(rk(i)-1)ind    rk	suf		p.s.7    1	a		p+11    2	aabbaba	sa(rk_i-1)5    3	aba		i2    4	abbaba	6    5	ba		p4    6	baba	i-13    7	bbaba	
这样，我们就有了均摊 O(n)O(n)O(n) 求 hththt 数组的优美做法。
for(int i=1,k=0;i&lt;=n;i++)&#123;    if(k)k--;    while(s[i+k]==s[sa[rk[i]-1]+k])k++;    ht[rk[i]]=k;&#125;
参考

Bilibili 【manim | 算法】OI自动机大炒饭（字典树，KMP自动机，AC自动机，后缀自动机，广义后缀自动机）

]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>学长建议</title>
    <url>/suggestion/</url>
    <content><![CDATA[
  40fff3a5cf27b77ac08956115c0713292362f196ad6752227a761f63c2d08a793009c47c139cf0c527f103801c47c6ab892a0490a41339332db2373bd7e77d5c8649271ba47a8ea1a9432cbb4e31bf4966d8004acb1c8f78511e7fb7c226828a09685de389680504693304471c090b87f5268a1bfebeb60b98bc8d27870d2f86b6613050a33c1d67405302a933adbeead6003dfa5a1a924f2524edb6e1412ebd2bcb1dc6de9950a549893e5818d110575fc99e44fbdbc159fd96fecde6d4396d4240f2429da9a078a4cac1171c841e08e665d741325aa1f8e78b41b0b0fd35dab611a5e41384523fe0295f205ecfc8191f42352761ba2a15bd79d353d012600042e9287b86935ecb42fa894aef8e86c8b8d5397dc078de3d5136f6984920a51f2ef95ebf022a93656f8f3c0f96974c37c20382ee254fd6c48d7313d412cf207fcc494c915ee53e45434abaabfdf60cdcf507ca6f4f271c20f53944f21b57f1f65b021512ee78039abf11fdeabbc0196eb16dbd5a85a0a879fdc584afdef7ed7b53b73b67458d08084d1ea90734f045585c1b968dcaf2164250c3ab5f735d071aea94b82210eb853b6f474c2b220fa5aa8c5bf8e962f1faf0577a1e682dd1c2a1f5115963a670efbd1c316c7ffcac0e534cff1862994ffadbc42775f69ebec0ff81832df0cd8e5372400542949c3a2c341aa45a351c4d0d0719a2497699698d02cd405ddbb0c54f515ac479b3988eb74693d369435461049f07004881aa2569dc456c7101f9e1e54a26cd1e9e5040aa0b9aff05852de9fede8ebbc1ecfe91529ee4705277e283e7265236fb45beddd4b890236e794a41e52ba282ff9886c79877a247c58ba421a38ba2328f2472f4b8d563a794c01ddae7e55bddff399dc0db726091fcbca8040a9f308e464a399380e79cd8e0f1cebd5166c2daa080ecdc11ad60cb2a2906a1b74689be28370bfa9bc82b2e56b5e375c4e215878bf54d142020db4bbd269f082a49129fd270ab908caa79601d93f9436ac50f6d45fd6b01c002f8e108aefe7007f159d5eca5e3ccbc7b81e2bee7e4842d80a38ced95540ea0961a312fab6cab4c27b88031b76f96bfab9cbf682fb25b63b01a34b2a6a8d5698ad31ba2c363c3bc50a5a5d55814c9ee7182860847c06717cdeaccedd34e2893d0ec6bce5eb55d2198defd467d51b492fe2ac365cd97954d11ab8f0bbf2c2cbd3d303ea54572277a2ae5542c27cddc86ca04b4255218549a5534ee835edc55c95928bd5368d6b739e17f11029f03684f5dcdb4a279f7a4cd3e1b6557a4bef9ff8a3ac1203893002eaeff06e70320716a41db7b811f3f2e00345916d4dadab0072e89a4cd487e63304ec141ab964b022810c28d785c87543292cd3e066ab4e6861cc254dd14ae1aa650fa8e78db43bf82c74708554f988f026b04d44596372c6a2364ba989bd627c97e2eb00d9f254a5893954eafdf51e2c5f7b25bafdd19e63d55968e15c78484a1b1f7de9f02338597342b85505aa88b3e7d9b85c1d9f87c4d7fc1859756dc15b1ebd588071d94e5c204334dce45642590e1a07b6a456ec82d26dfb921081b6926785c29625415c1570f435f54c42d4e024a5ca7ea5a179e9eb0c23ad1ae2bc108e921aae2aea6febdb276f55c662ad2928faf07af4a8b082267c74bff2aa651865d60884ea704fbd9e30d1bda769705e90c39320251762849ed550021967cc7f5cba78fc745e94913be97b2de8037059cce407c61da08fca907ee438ce97845c1d6a157ca3046af70becf2b1e4cbda6577edcc04d9238d30d2639892f6a3fe549af4caf0138412aca5bcbd46a2042baf77e990d9c6759fd646710e407fda12173592d5d850bde4ac33a135c84232d155ecca4faf83080182050b84e42bb20bf0b4a7bf12ee2abc0786218f7ae88cdab08e5a506422f40d7972ed05454aded19bc36f2c61c5530e3d9c7213a4cbd993afb9f4ee308fea69bdc57a4622327813719a21aabe2b7b4298e617c89c480bd6436c6bfc9f8965996d2a0d1b0d492e23a797e4b1e587090d16eb4cab58cd3ebdb8c52e0eb57ab72531fce7db9010468f9abcc988c5a360eb07bbf09d47fc73508a988f11d57fe90b02aeea44490d89b378a9336d94daf6dd1b96a5f78f5ee06539b426477c63ad1d635711666180b7a9c0d89efa9d024aaad4c581272b4f3693cf693003454eae382a62b7ff50f2344ca7900a98701f935cf3df5d721c15f061fb4ec6810108bc4c2ebdc98d8aa2b72149792abe023cc6627948d3b991e935c209b0ab015e1c422caad248cd090ddf134881fa5fbf0bf56c1a7db155b4acc31a0076565ce0f7f75ef25d09df44b4b2a3a2e8557610c50ebd7ff3e7c5ed90aa9d1ef4a3b8a0de0a2c3fb1c8f1bf8efb88987dbf4e8ccf9f5289718231daa043090f5a3e932dcc94a7382c596cb057f3431f19cdce99c066a42737550ba5b07c205d9793a45d364a1dd2afb75e978fb21df8bfe97266b18dacafcd746ffca89ff657787bd0be0882a708316e5c4589a259ed704dcc306bc59a4c44bbcc2492b6817f62c87d37314b59853950944336c8179f3c5a8fa029252fa03e7b69e1ddf550c035c51e57c892f8171b129291cb16a253149953d90d1b0187399480b632392111dff3f69ef1515a64ced9ad8046a6fde19941d50c1d1e06f039ed474a8df7eaf737fe2f12c6a1bf33a2f060646f0cee9d20d4cd5dec29ac69d2e6445f021c85212f361a42b7d920bb84c08204c0a1805203c0ae3fec02c1685069e5d87f49279f903e13e009f43fe0f7d06a4cae621495cb09c12736fb05f639fa3707bf3d3f9f49379c6be196d9a8f6354c759af5b56dc6eddd917eff56b5b92d4c8af1e3ac0e2a87f43e4652b010a9dac852c1c5cd3421027be0f8d96a091b2cab0b8a4b0e271060851bbc5f0b712c8abe9a639f60f1e28442b8390f59fdc9ed88e041efcda6d88ca868363ab36695a7e87373e2ca2a8089fec4adb6228bf869018b32e8eef94a6225c7a5dafa82a6d0783500747f64f2bd69af5fe4843bff22c429af9df81e865a49db4fc35e66bf2b8a7be4b192011f815b12d14f29b9638dafb3782537faf2d8cefe1e896cb6ddd4fa290f708981981c4c2bff1867641f00c19e3e157c5e164e1986764e4ab5b18ea716a0d54fce785690cccf5457b1756b7edfbbfe32917ccc693c6b4260c069b7ccf7bb98886f51583b96db0f15175d26becfb8543569d70c02e2d9e5b74d8033968bd8bde93f9e6df4aa698bd81337324b80874169ef2cdfd32768e3249dbdba8fa41dba117125d65ad0130ed4acf834c04d85e40c3f1f13563fe5217a77bfb05854095ec997a22a56a3f1e3bba2c4e5d721bc9296d9d7ddce45d6e7b98991e9075c19f1633023376f7c72832de59368d0aa3b8732b1268467fa48f8873f60becee352e332a275997d06285f4191e6a923382a0f2040a43e418d8de3a6204cbc7339280222f7d3a8a0c3f7ab900daabef5bb30e1b37b3dfdd7c17cc5e4e5ff9071fa5bd5d6c2d1cb37c9f0a328339e7b9e2d59e64f25e369c748104e78cf936b118c0bc4d8c3000c0fdd4c98aaf02d0b31155dccd965ffec5f32b55ada203216f60059964cdb07a20d72b4227de49172bd41a735b9ca0c7753b7598e2fe5971ecc961f24eb85bbe07cb00e0a2c1adaafee98d7b5df3e54e0b33c44c38801814c8de0c777630a22f0bf285597c428b8b614f8d729c6da39b0323a0761eb14a6c905438c958bce7467259bf2585d4e3ff791b6bddf00fde4e9085bd0a841a926fdc1d73267ad8772fa6784ba48f60853795e3bb44eea55b20498b3bddcb9e0696edf72c4b07270d8de946fe822c4a665a7e8684ccef3a826a938a0fabee298ee6f8f3527a6f5cd624950e8bb8761edcab8d0fd0825ae9653ab4ef26e48b15f0e7007300c59fb4a09057882f016b67dd856ff1c7eac4a242282d7e15d55b74dec5aff5e41c7b4ae33de6aba76ba36509a73959147b8310e2883d36ed5327005ab421919a154bf114c3be83210e6f3f660f544f717a46dff5b3fb5542a1bbda11f75395528bd6b6f80f0793795d2ddeaaf1e39c210bac7d930506ecca5bc5ed3bcdaac9d775981a83c2f0fb6202c91f542dbf649c228b71a2afcb364c82992090b9b30940b911b3164ae93300ea1b26481fff2c3da35dcfbd739af2c0cb219c26497f61976fac58418b332bbb6eeedd5d371da1ab27a3830c60f92419be493ce65eb79f2fa831336d3780c6a4b26dac416f4739a27b4285d4a8d8fff0637f366c81c3be9702c79c786d062dcfa789f20d421510517d6f7ef5d3ebba69f75d6f2fe5861bf27718b92d328a7cfd83d463d9bae9c805fc69983fe2a9d47b3401a132f57ad9e91d31da1c9d55ebe923b67c6f74a2837410ef6b35596d1c34389e4e1b6c2999157ba84e6e0d332456ac5b686347be66c1d6b6112283bdfca9932d4f6ff4b07a1786f1da66decb428858215789109803817a9fa0bead9f717d4b2d6b69f5288660fc517163913865e28a6ec148db9b5fa0cc06e2683c3abbc983b8f8336176b59da8bacb6d2c9518b869d03bef41db95860fe5819fe8ec5072d2cd6ddadb39571e6fcdda7669d57cbdd87d7c19ca4aa434e13386d8120e47369469f01bcef44489ecd0219eaa9d346eef3f4e72da97e6263f981e7de0624a58ab55aca68b82b6b554aa036228740575759fa8ea1272fb2e032f2827d7ca9f20b7b227c141f5cfa1b6e47af1e6e98bb614dacec3c9cc46bdc0619070212c8f6c0ed3549f2eb664e7fabff7a8bb846282d42d52103e1774d3ec1acfe4b1e0451dc1204863aba4c84a8da53e8ebbb9271a2f2a266bd2ee3362cdcf38259b6a108d7ab8ee3e5578ea23b78d5582089f972e09da9e087e3ecac3c5f25ca7c1f9ec276c58034d6776f9862948f07e37cba2b57e2b6167e7f8ba749e24f203b452f6692cf3f0048fe69f724078ad1c1b8df6d4f0f05ea5951b160de111849ce7ea19cf7e03f175b928e389782080aff10adab378a3d77e5bd2197f0cf06ab69b32230f948f31d3e8b560c030bd9ecaea11f6ad97b214a33a5de85889f87499ec51f43066c405232536693bb49cbd3b0c639c81d18cceeadb317bfd503fb1a72ad8dfa487a439edce7a4b26f0bb49fa75ecaf57ca5b56d840d37457831c90ed18578fe1dc2589c486d6b3171927fb893f7bc883b0abf2546560701228143dadebd5c93b78b89de21ccdccebb35168d92bdf772bcb03d642089fb53e586a0473e340207fb3628d2ded952df60f806e97acdb9a13a7171fe58a9d34790afda3eaa0cb05c32646dfb79ae7667002939ebd85ab1b0943c8dbd8c1a7bf5cd1e0854defb5d418512fa06e8aab914a4d0ddb7d5705444770640bdc2cdef2a7a6172c03219c0fbc3b90f480316704576bb5c3912331625bfa63eb294960310940c101492148a48fde47032eb775d12249d5eaad0f2761d92cd8043fae045270b0a857f14f74fdff1c48b07b25ec5c9423f650716bf03014056ff0a52d90e655be51c24d73ce2eaf39c6a468e0773a027a55616e8931a744174b005d33bc752b4e1916963fcd6708da8a94d4a6c6b47a3361499077a45b2f863e64d29561c4b4331c3a4f8a7e4e0e3ae33b9b5fe32ae6ba0f643af72c58e162f22ea977e2e10d4294836cb432b30737b2aa99163a289983e3a4f0fe382adda0e2cf37534adcbcbadccf87db67f650b3e022bdd6f78ca5ae43f1e2385e1cb2d08f03edbd68bf44e062d961625a5ef2fb1546bf2a590f94258ce0b72df24f5b0f0c372c9aa5728d2229e7daeb06c9236a2e4b5e805d2aa326386b412fcdf281a6564225d9b85cbe3d6d3b6dcb743d7992f2cdf662eae813d7e4b0692b0e238ab5c99963a7c3650cf1d38e766530fa2737f4cf2b83f8cc904fc41e7d5e27af40c11b2d7eda90bd6586e09439bb812b2cd382d0cd8b4ec7c5317b133b82faf816bf69895740b1aaadc80f480e52313b07caf65fd3c25665ccda289d5db7e8a779cbf191f1b07eebef82c5c8de07f3bde8e797ee65bb848cfbd82ed3c1d8a620932e1dc1ade86feb834c97c36d08dd5655f2caf4d81af7f073469aa765a58acbf782bb1c9169aae0c1075fba0d064d205474bc12c2cdc8d5f55584433398a74864e41bb74543a1f3eecd2ee299570ad0ece25a8f20f1479f04441f77bb4275695a668e75d304f50197b45b505b79821f4eeb38b1136edb3631687271d87dca7b83f31291222655b467d63c1c777e5ad9aefea4aa7098406873deeec8da09138ec64b1f498fccafc301d0fae58e9e94b53d36b7e479751ec1d196ec25aae170bafbd2e37398d35918907ada225d4a921f4c293a1ed34ddbb6a589870f3169a758654573a61dc4dc42d7b596ad17e76d65c81c76bb0d175efae3a4e6a4a9bbae23a23d73a8548388dec332a2d48132240ece0be7889a776892e49f3e02714b352e49143edd009b856ffaf8c1bf976c414116578721fac7dab96c6bcd24e528cfafc4d13e775178b181f52719c94c7c0e7d19361b32016d17a0f902bc26736a065a9e1d669f9ed4c6efa9c7af451a9ba976db85ed5b5625ac4a6f0a19f9ed17704279724b65b2a5a4dea5de4113d335d5e013d1a4d0379d112ecc7143bcc2933f49209edd2fd9a29702dc7c61f37e4f365f87c48f75ac5751ed95649873e6bb270534f0c8de3f2260c24fd98e9418f25cdef064a0624eb9299a1060885ce7ee139aaa34cb5169778e769b06244f566daec482785c54ec13f43b609ec0eb68de744ec8be542e66299110af2109f21035cf9270bdaf6c2f3bdecc2d119b965455ccb77cd15565f09ac8c543c8e77a98ae31d8353f6d48976e960cb69a966167f2927e0973f9af39749503242fc7cfb633c4ba20e9842252e2e3c998d37f7067afdb92ee1cf8841a17f356703c3e5054030ea28b1aa4429ec3ff70912b5b3717c81dd462ab29c1c5a1ac54e6dbe79efcb549e204d48b0edd7d98ae633cac038f4c70aeee65106fefdc1717eedee4ac9997ea404ef1536e4c170848c7cc2d37944b31acfeef67e7ff9836402ca7ce5b1791c8341920d432874c9ed47382b85ad4f07ed5a8a47cccbba805eff6e385798119bb16c5b0e08df7569c9695686e43c6de5b8eef96f816ff8701d7dead142ca6ce5784ab9bb84ce35c6501d908b8a5fdaee2e1bd2a2594423676c3464b1cf268b94a34a850eb8e67069215c5efc957da292f9fa54a07365614c1d57132c7ac9dcc6b14643ce52d9eeffe68667a083028a2cf7112be4ec63e0917b4a94fc09045690be48ef7df0ec3b248e85b8754f520f9a7cad2e909ea0863773e72931062f10c0e8b266936d7fd0a18241923b43e69ecfc70970a4df4ebabc2d7bb4282c7b3881471c44a0a03f5e4702d45f41013596ff3ef7df89f6e2095a444fbe1f2f3448cf4f529732d2b9e7563d9f48a952b9b5dce6562d7a90b0252b20fad53101b42411b8a5d9afb591f28a552acd644c8093603a968e6c57aada7b9b098e2ed6a0efcb3509329bdda7c91bf819c996a810727ae9aea2e7eb653cf8977d3433a6d993c1ee98c322f5f63700795414ea179be39b5038698de15379e39648bd81de4d17f657ec5184507607e4e3c25cba082c9ebacca0a6ea340fe6f42a1edcdddf9cc015c788ea19014132d94d6976a851a1637caec5c5922331717fe95b4bd9080fa5c4cef4ef0c4e7143054c4fed6d42680fafb5b5d89ca41af405c0351428921efb127d004988c7cdbef64f40f2431a42c4fa015bfa6d8581ac49188f5c9daa6018a4d74f629066a3b584ec195547844782638936605699d8a69c2b491975fca054f494122f6fa8cc084fc3987336e098ed82a995de91df84b0f7df1b7ef0d6d3f98e55efd00d151a47509ad8a2842c3c8314375032566bde216112f175b794592a0bcfccadd3ef0bfac8ab26204da192e026d48b249ec6acc3be483580c35253f0fe9d62c087c268235f4c5a0914efab6f897526b85f745dc233664d955d5631429d199036a64795ff57a8cc804ff9e0ccf2a73211063eb071f1c9038a7e6308272e0fc24647c4d1c17e2e81b965237ddd3f4035caf56aa3a1fb5816848ba1cfebbb5da37d8ba5e7b0b8f0b9ca66a862c8122bcf96ece9413cf1bc88806d8adff3b6de87a6b17a5f66d54cd913c38cb3abc5d668bca0c5e057854525d977d5e854f06a5dcc74d6be73f43b69eee2bdd401b0565fcff6b9212e81691c73f149394f81316757ba99db35c532977d02dc944c207cb262efe2538b8cf37969befa4d15720e0419ab88bacb9c8a5c751adcebfeeb838ecc27796fe4225eb69ffb00b4e9f6efe30418938d10f460cd5f00a5ee88a51151aa26141fe97a962ea5e06fe39509dd402d00d95093853a7ede85593c4bd8f35dba367dbba5e7c34dd96c6461795b78efa90257d399f8a4c3666dcc7cad1c73f786fed840e960775a329f48fe19958d49558d932f358644ecb9b08ba9098e29e923da9757edeb5d0df80d72c549ecf5a788d7d8f74540cbe15abb356b87a175e6c2522b63c920146184d1fdc511d71830031cad0f6b7350da2a61bf1d289778e08221974f98cc3d0df9d21575558a8276c26065526391c3c20d58f7905bc54ebbb72fd2ecbb22fe67386a6beeb32ae0abce243dce2de87f0491a0298bff1ee825ec8ebf12e057a754dcc350a6f6db6b3ec58db0ff5d3e67ae15ab458f10f9191cafbd4c2d46dbbfa03897a59c4f1787fab9fd413bbf79250abf655e27a90e791c71fe3c007507c6afc2b3bb07293bc161c94e03f6a6e9609099a8d73d901a1aa9aa3c139d6fa05e6b35a8c19e25b62c41fdeb6a8d5be8169c6dce3e0cc83a2b797185187ba934abed38897c174db8a8b077a97623a80fa15cc61b91ac9fc73b32b563c2774ded7a819b4ac9dcb102ff105499f938fe044519c5aa09c9eb3dfe78fbf81403741dc6b235b7e81c076aee4246dcd2df79b5c0c58c92f7ae5b683bf9a85caf1cd77105e1603cc32d17fc4e033760a6470e500f484c3ab6717d589f9c8553dffc7ea488eda399aaccc13442ce51553e223694652e35649a136beeceaa72f557b5a03c259ccc279c4fc6f8d0d0ef27c7b905d0b5a9343d3608a07b8b6727b1691807389187fb3a0ab29eaa264e197cd445b9b1bd33968bbcd341814c1f6dbb8db0eebfbecc74491f97b91747b833c1ebe1b37981351b36fda220ac78654e2bb3115916d27f7d3a9ace378e65fe985c7857e518398b54f039acef7435a1659fd7bc4e0863459caf2d224d3f6f45abe4278471321619b7f0b4d6d06d73f6e6b93f1d020d57aa51dd84dedffbf496862b419ad553bbcc5e21ddecef0b4352aa9ace6b6c9ed4ea99859ee82a43b362cea7f8ffa3f2a6ab3f58b7781268b753c8de278ff43486502566869d5e0140e3c5210978526ce981f4da63d5ba219e44c1f286e2bc257bdd10d20606b13436d8a69eb1f2e48666d35964b32324a2f9a988dd36a1418b3e327b38e2138016b63160bcb6acf71388d9520948243b3ea07a681f29b1daf8dda66a8f52ab3152f3ac565ae1fef0cb97e5987cae77dc0faf756bae4cf0550249cd0dd34d1f71c97bc1acc771db1b9622bae2f98119502dd85d9c37c0658cf7d27786a6184dc4cd65acc207428ae9a8ca3c1c27dc2a717bce20f95a4b43c1c8ecac7dedfd097ef8cc40ec5f9ee978349614c036dd2e0abf1654a8d75c9cf32f819937112cca51e46d5d6721e3a517a3fea9b28e0a818bcc416f8872de3f25ae09ef37feba4ade1a35261b5fb5dbf8589f2848b72275729dea3638358c82282598fe63fec9019ac39e7ecd2f2ae4f464bec2ed8950b3e9a3a0d3a87f80c3d1890092a1f46059c0d95e5632c6e6d532af334160a9224545db18b64db1c43af3af34aef7d9ba94c243d14031bfba5c8678b4a7cfb9d78f96f9c0660140f786217248d59ff781c59eb89acc3f266555cbca5e970d607b011d8e9d2ef15dacebe32
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Tarjan 求双连通分量（点双连通分量、边双连通分量）</title>
    <url>/tarjan-bcc/</url>
    <content><![CDATA[注意：本文只针对无向图。
对于无向图，显然不能只考虑简单的连通关系，应该研究一些更强的连通关系：双连通。

前置芝士

点双连通分量：若一个连通分量任意两点间 都存在 至少两条不经过（除起点和终点外）相同点的路径，我们就称这个连通分量 为点双连通分量。
边双连通分量：同理，若一个连通分量任意两点间 都存在 至少两条不经过 相同边的路径，我们就称这个连通分量 为边双连通分量。
Tarjan 求割点和桥

首先要明确的是，若一点（或边）对于原图是割点（或桥），对于其任意包含该点（或边）的子图，该点（或边）仍是割点（或桥）。
可以想到，在一张无向图的点双连通分量中，一个割点所连的点有且只有 111 个（注意这个点必须是指定点双连通分量中的）。注意不是度数为 111，因为可能有重边。原因是若某割点连接了一点双连通分量中的两个点，必然有删去它后该点双连通分量不连通。反之它就不是割点。
同样的，在一张无向图的边双连通分量中，必然不包含桥。
Tarjan 求点双连通分量
算法流程
首先维护一个栈 stk\mathit{stk}stk，一访问点 uuu，就将 uuu 压入 stk\mathit{stk}stk。
书接上回，当判断一点是割点后，我们可以从 stk\mathit{stk}stk 中退点，将这些点加入新的点双中，一直退到 vvv，注意不要退出 uuu，但要在当前点双中加入 uuu。
因为上文说了，虽在一个点双中，割点连接的点只有 111 个，即 vvv，但 uuu 还可能在其他点双中，故不能退栈（或者你退完压回去也可以）。
所以注意，不同于强连通分量和接下来要说的边双，一个点可能在多个点双中。
进一步的，我们甚至可以求出删去 uuu 后连通分量的增加个数，记为 cutucut_ucutu​。每当满足 lowv≥dfnu\mathit{low}_v\ge \mathit{dfn}_ulowv​≥dfnu​，cutu←cutu+1cut_u\gets cut_u+1cutu​←cutu​+1。因为一旦删去 uuu，vvv 将与 uuu 的祖先脱离联系，导致连通分量数量增加 111。
其他与求割点相同。
代码
暂无。

Tarjan 求边双连通分量
算法流程
还是同样的维护 stk\mathit{stk}stk，当判定边 (u,v)(u,v)(u,v) 为桥后，可将 stkstkstk 退到 vvv，并将退的点加入一个新的边双中。有没有发现边双比点双简单多了？是的，由于桥不能存在于边双中，故退到 vvv 即可，没有太多可叽叽歪歪的。
其他与求桥相同。
Upd\texttt{Upd}Upd：实现中，为了避免根节点（可设为 111）所在的边双未被退栈，可以按以下实现：
对 uuu 的 dfs 即将结束时，判断 dfnu=lowudfn_u=low_udfnu​=lowu​（可得 (u,fau)(u,\mathit{fa}_u)(u,fau​) 为桥），若为真，则将 stkstkstk 退到 uuu 结束。这样的实现相当于在上文的 vvv dfs 结束时直接退栈，而不是回溯到 uuu 的 dfs 时判断、退栈。应为根节点没有父亲。
当然你也可以依然按算法流程的实现，但要加一个超级源点 000 只连接根节点，这样就能保证根节点所在边双被退栈。
代码
暂无。

完结撒花！
Tarjan 连通系列正式完结啦！（除了代码）。
以后可能还会更 LCA、LCT、splay 的文章（挖大坑）。
]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Tarjan 求割点和桥</title>
    <url>/tarjan-cut/</url>
    <content><![CDATA[欢迎批评指正！
注意：本文只针对无向图。
前置芝士

割点：对于一个点 uuu，若删除 uuu 会使当前无向图中连通分量增多，我们就称 uuu 为该图的割点。
桥（割边）：同理，对于一条边 (u,v)(u,v)(u,v)，若删除 (u,v)(u,v)(u,v) 会使当前无向图中连通分量增多，我们就称 (u,v)(u,v)(u,v) 为该图的桥。
Tarjan 求强连通分量和缩点


Tarjan 求割点
设两个数组 dfn\mathit{dfn}dfn 和 low\mathit{low}low，表示 dfs 序和至多通过 111 条非树边所能到达的点的 dfn\mathit{dfn}dfn 的最小值。
注意，这里的树边是有向边，是无向边中按 dfs 序访问的那个方向。非树边包含树边的反向边。
在 dfs 过程中维护这两个数组。
当 uuu 和其儿子 vvv 满足 lowv≥dfnu\mathit{low}_v\ge \mathit{dfn}_ulowv​≥dfnu​ 时，称 uuu 是割点。
感性理解：因为这说明 vvv 无法通过非树边“逃出”uuu 的子树，只能通过 uuu，那么当 uuu 被删除时，vvv 就与其他点脱离了联系。
但有一个特例：如果 uuu 是 dfs 树的根，那么只要有两个或更多儿子，uuu 就是割点，因为删除根节点后这两个或更多子树将互不相连。
算法流程
dfs 到 uuu 时：

给 dfnu\mathit{dfn}_udfnu​、lowu\mathit{low}_ulowu​ 赋值。
遍历每个子节点 vvv：

如果未被访问过，就先 dfs，然后更新 lowu←min⁡(lowu,lowv)\mathit{low}_u\gets\min(\mathit{low}_u,\mathit{low}_v)lowu​←min(lowu​,lowv​)。
如果访问过，就更新 lowu←min⁡(lowu,dfnv)\mathit{low}_u\gets\min(\mathit{low}_u,\mathit{dfn}_v)lowu​←min(lowu​,dfnv​)。
如果你想知道为什么这样更新，请看这个。
如果满足 lowv≥dfnu\mathit{low}_v\ge \mathit{dfn}_ulowv​≥dfnu​，将 uuu 标记为割点。但要特判根节点。



代码
int n,m;vector&lt;int&gt; e[21145];// 边表bitset&lt;20008&gt; cut;// 标记是否为割点int dfn[21145],low[21145],cnt=1,root;// cnt：时间戳，root：当前 dfs 树的根void tarjan(int u=root)&#123;    int chd=0;// 孩子数量    low[u]=dfn[u]=cnt++;    for(int v:e[u])// 遍历所有孩子    &#123;        if(!dfn[v])// 若未遍历过        &#123;            tarjan(v);            low[u]=min(low[u],low[v]);// 更新 low            if(low[v]&gt;=dfn[u])// 判断是否为割点            &#123;                cut[u]=true;            &#125;            chd++;        &#125;        else        &#123;            low[u]=min(low[u],dfn[v]);        &#125;    &#125;    if(u==root)// 特判是否为根节点    &#123;        if(chd&gt;=2)        &#123;            cut[u]=true;        &#125;        else        &#123;            cut[u]=false;        &#125;    &#125;    return;&#125;
Tarjan 求桥
求桥时，需要稍微修改 low\mathit{low}low 的定义：那条非树边不得是树边的反向边（即不能从儿子走到父亲）。原因下面解释。
如果边 (u,v)(u,v)(u,v) 满足 dfnu&lt;lowv\mathit{dfn}_u&lt;\mathit{low}_vdfnu​&lt;lowv​，那么边 (u,v)(u,v)(u,v) 是桥。
证明：
如果 (u,v)(u,v)(u,v) 不是桥，那么根据桥的定义一定有另一条路径可使 vvv 到达 uuu，而这只能通过走返祖边实现，于是 dfnu≥lowv\mathit{dfn}_u\ge \mathit{low}_vdfnu​≥lowv​，与条件相悖。
同时，因为 (u,v)(u,v)(u,v) 在检查是否是桥的过程中应假设 (u,v)(u,v)(u,v) 被删除，所以 (u,v)(u,v)(u,v) 正走反走都不行，于是限定不能走树边的反向边，否则一个桥都找不到。
注意：重边不能忽略，因此在 dfs 时不能传父节点，应传父节点连过来的边。
算法流程
dfs 到 uuu 时：

给 dfnu\mathit{dfn}_udfnu​、lowu\mathit{low}_ulowu​ 赋值。
遍历每个子节点 vvv，如果 (u,v)(u,v)(u,v) 不是来时的边：

如果未被访问过，就先 dfs，然后更新 lowu←min⁡(lowu,lowv)\mathit{low}_u\gets\min(\mathit{low}_u,\mathit{low}_v)lowu​←min(lowu​,lowv​)。

如果满足 lowv&gt;dfnu\mathit{low}_v&gt;\mathit{dfn}_ulowv​&gt;dfnu​，将 (u,v)(u,v)(u,v) 标记为桥。


如果访问过，就更新 lowu←min⁡(lowu,dfnv)\mathit{low}_u\gets\min(\mathit{low}_u,\mathit{dfn}_v)lowu​←min(lowu​,dfnv​)。



代码
int n,m;vector&lt;pair&lt;int,int&gt;&gt; e[21145];// 边表，pair存，.first 是连向的点的编号，.second 是边的编号bitset&lt;200008&gt; cut;// 标记是否为桥int edgecnt=1;inline void addedge(int u,int v)&#123;    e[u].push_back(&#123;v,edgecnt&#125;);    e[v].push_back(&#123;u,edgecnt++&#125;);&#125;int dfn[21145],low[21145],cnt=1,root;// cnt：时间戳，root：当前 dfs 树的根void tarjan(int u=root,int pre=0)&#123;    low[u]=dfn[u]=cnt++;    for(pair&lt;int,int&gt; to:e[u])// 遍历所有孩子    &#123;        if(to.second==pre)        &#123;            continue;        &#125;        int v=to.first;        if(!dfn[v])// 若未遍历过        &#123;            tarjan(v,to.second);            low[u]=min(low[u],low[v]);// 更新 low            if(low[v]&gt;dfn[u])// 判断是否为桥            &#123;                cut[to.second]=true;            &#125;        &#125;        else        &#123;            low[u]=min(low[u],dfn[v]);        &#125;    &#125;    return;&#125;]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Tarjan 求强连通分量和缩点</title>
    <url>/tarjan-scc/</url>
    <content><![CDATA[Upd 23.8.29\texttt{Upd 23.8.29}Upd 23.8.29 修正错别字、证明，添加代码和注释

欢迎批评指正！
注意：本文只针对有向图。

前置芝士

什么是强连通分量（SCC）？
强连通分量，一般指 有向图的极大强连通子图，在这些子图中，所有点双向可达。
dfs 序：即 dfs 过程中访问点的顺序。
dfs 生成树：由 dfs 过程中访问的边组成的边集 和 原图的点集 组成的树。
树边，非树边：属于 dfs 过程中访问的边 为树边，否则为非树边。



返祖边（反向边）：从孩子连接到祖先的边。
前向边：从祖先连接到孩子的边。
横插边：除返祖边和前向边之外的非树边。（连接没有祖孙关系的两点的边。）



某个强连通分量的根：这个强连通分量重 dfs 序最小的节点。

Tarjan 算法
设两个数组 dfn\mathit{dfn}dfn 和 low\mathit{low}low，分别表示 dfs 序和至多通过 111 条非树边所能到达的点的 dfn\mathit{dfn}dfn 的最小值。
看下面这张图：

每个节点的编号就是它的 dfn\mathit{dfn}dfn，旁边标注的数字是 low\mathit{low}low，可以自行理解一下。
另外，我们还需要一个栈 stk\mathit{stk}stk 存节点。
算法流程
Tarjan 是在 dfs 中实现的，每次访问到当前节点 uuu，就将它压入 stk\mathit{stk}stk 中。随后访问所有相邻的点 vvv。


如果没访问过，说明 (u,v)(u,v)(u,v) 是一条树边，继续 dfs。
dfs vvv 的子树结束后，更新 lowu←min⁡(lowu,lowv)\mathit{low}_u\gets\min(\mathit{low}_u,\mathit{low}_v)lowu​←min(lowu​,lowv​)。因为根据 low\mathit{low}low 的定义，走多少条树边都没关系，而 (u,v)(u,v)(u,v) 是一条树边，我们可以从 uuu 走到 vvv 后再继续往上爬。也就是说，vvv 能到的 lowv\mathit{low}_vlowv​，uuu 也能到。于是更新。


如果 vvv 已被访问过且已属于另一个 SCC，说明 (u,v)(u,v)(u,v) 是一条横插边，两个 SCC 无关，直接跳过，不予处理。


如果 vvv 被访问过且在 stk\mathit{stk}stk 内，说明 (u,v)(u,v)(u,v) 是一条返祖边，更新 lowu←min⁡(lowu,dfnv)\mathit{low}_u\gets\min(\mathit{low}_u,\mathit{dfn}_v)lowu​←min(lowu​,dfnv​)。
因为 low\mathit{low}low 的定义为仅通过 111 条非树边，故可以直接走返祖边 (u,v)(u,v)(u,v)，如果 dfnv\mathit{dfn}_vdfnv​ 比 lowu\mathit{low}_ulowu​ 小，则更新。
关于为什么不是 lowu←min⁡(lowu,lowv)\mathit{low}_u\gets\min(\mathit{low}_u,\mathit{low}_v)lowu​←min(lowu​,lowv​)，因为 lowv\mathit{low}_vlowv​ 可能已经经过了一条非树边，如果再走返祖边 (u,v)(u,v)(u,v)，就可能走了两条非树边，与 low\mathit{low}low 的定义相悖。（其实这样些也可以得到正确答案，但是求割点时就会错。）


然后判断 uuu 是否是根：若 dfnu=lowu\mathit{dfn}_u=\mathit{low}_udfnu​=lowu​，则是当前 SCC 的根，然后退栈到 uuu，保存答案。
因为 dfnu=lowu\mathit{dfn}_u=\mathit{low}_udfnu​=lowu​，所以 uuu 的子树内的所有点都不能通过返祖边到达 dfn\mathit{dfn}dfn 比 uuu 小的点（否则可以通过树边到达这些子节点，然后走返祖边。使 lowu&lt;dfnu\mathit{low}_u&lt;\mathit{dfn}_ulowu​&lt;dfnu​。）
关于为什么跳出子树至多经过 111 条非树边：如果有 222 条甚至更多，必然有走的最后一条边跳出了子树。那么跳出子树前的点必然在子树内，可以走树边到达，故至多（其实是要且只要）走 111 条非树边。


代码
int n,m;vector&lt;int&gt; e[11451],stk;// e：边表int bel[11451];// bel[i] 表示 i 属于哪个 SCC（编号）vector&lt;vector&lt;int&gt;&gt; scc=&#123;&#123;&#125;&#125;;// 存每个强连通分量的点的编号int cnt=1,dfn[11451],low[11451];// cnt：SCC数量（+1）int dfncnt=1;// 时间戳void tarjan(int u)&#123;    dfn[u]=low[u]=dfncnt++;    stk.push_back(u);    for(int v:e[u])// 范围 for，遍历邻居    &#123;        if(!dfn[v])// 未访问        &#123;            tarjan(v);            low[u]=min(low[u],low[v]);// 访问并更新        &#125;        else if(!bel[v])// in stk        &#123;            low[u]=min(low[u],dfn[v]);// 单纯更新        &#125;    &#125;    if(low[u]==dfn[u])// 是当前 SCC 的根    &#123;        int t;        scc.push_back(&#123;&#125;);        while(stk.back()!=u)// 退栈到 u        &#123;            t=stk.back();            stk.pop_back();            scc[cnt].push_back(t);// 保存            bel[t]=cnt;        &#125;        scc[cnt].push_back(u);        sort(scc[cnt].begin(),scc[cnt].end());        bel[u]=cnt++;        stk.pop_back();    &#125;&#125;
注意图可能不连通，所以主函数里要加上：
for(int i=1;i&lt;=n;i++)&#123;    if(!dfn[i])    &#123;        tarjan(i);    &#125;&#125;
每次都调用一遍 tarjan。
缩点
缩点很好理解，就是将每个强连通分量中的点的信息合并，缩成一个点，形成一个 DAG（有向无环图）。
代码
for(int i=1;i&lt;=n;i++)&#123;    newval[bel[i]]+=val[i];    for(int j:e[i])    &#123;        if(bel[i]!=bel[j])        &#123;            newe[bel[i]].push_back(bel[j]);        &#125;    &#125;&#125;
其中 e 为原图，newe 为新图，val 为原图点权（或者什么类似点权的值），newval 为新图点权。
参考

这位大佬的博客

]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>测试自定义路径</title>
    <url>/testpath/</url>
    <content><![CDATA[测试自定义路径。路径名：testpath。
]]></content>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>单击此处添加标题</title>
    <url>/untitled/</url>
    <content><![CDATA[
  40fff3a5cf27b77ac08956115c07132911eba6dda545f898e5c24ed0558c16a39e40c05cad9636d59b2397ce55d2ce936fe093ce07d1f9b55b060002dc17655e7ab8d5914ff692650e5434f1f298671ede9eb84f765ff8aee6438f3e5501bcbd1d60654b06d1a96432340462393b34b5f8e85ea557bd170eef84dd543045e0c6b3844cca5b92f8a650d969aa65446bcc92e73fc33731932f7e3857296895b012964d6caca446a4fc796764d6081291cfad3aa250df83f6eb6081aae8fd6d7c70dee1a384ad02809d44b60821db5f4051c8b5453506bd360ffa1e8da0388ec51e83a78a4549b7a631c186a287fd3750ba1e564863a43df9a211de58ed093e5610cf9380cd67cad358500766197993f6841ab704aad80e38f35f4a2641344d67da0199ce6627f45ba7dcd572ced102f03b9b996d9707bd7bb0228b29aaa82f117a1e035b27b8a6abfff2d6cf261c67f7e2b2a3d95984d2e36f163516893b78220ffdf88f1799c15bb2a04e1f2f30e6532214c93644c96caca1c8075d1e405201a5a52cbe3a7d31aba3f76e379da4f7b71d34a2e9015c44557526c9bf497074cd3bb04cdb3a2da1dfae611516754d4f01fdec8327ddb530506dde3971481a42f59ee4d9b2918c700c305f6ced4e14a808da7b46a72e7d671ef3d6fa12b5485d4962955ac3fe052f25a54c736ff14e8acdfa676e61065f773b545628b24e5571dcc175f8c01178f2a225caefb2880d65889c211c5b3c815c7375bf2d795d80d8c8061d25249d762816a08fe8af07de5bd2c4df26c57bb3c906df94a3dadd7ca640207bf1deeafae0988bf4aa47deb0962a1c27100b942a6c63a6ce89c59fe0ce107a1083432b29be9e0013ddb8aff4fe36848c9c51dc9dd093525965a223d7291cadf6c197c7272d91ff6b7b4f0266317d18e7e42c7e5040bd0f7ca89e992d71ffa700db736cbdf68f71b7ac17563e064350a994e6fa5f58b23313e11c4ecade6cd3f7408875930532d3b054bf05296d6846724e9c5c87650429104b00dd36cc2b613b830bd4f6cc24d4e67e7d7f4eea50fb17114f15afa45065aedfb6639958c78291122343a71c881e54025546a39d284e799c6ccedbf434e7d3801d302d0038ac7f5ecf055eee5996133b971b8fa6adac5d833476955d907d04fd5f1adff9bbda1dff6fd1f9483fb63fb2845964ff4a53b1126d2e8a6266df49c63b45af2eaa6b4dda8406e2e3211c5240fa2dc4e51c8180332881f615ab7bdae84231f0fc7879f9661333164120ca8103ff36b66574669195576a08fd6400f85fc299dce670bb44906413766cc61687b795eda7e22e57e2f45a7eb564617aaf6dbc7e0ee7e866649ed3449b1bfa50649106091a540d736cca9933993a156877a32ad27177a26c5baf113ae66405a212118da9f7559eb93e55d91d362448782477e185a8a165145835de607765ac26e98fcf0dc19889da2b07cc6c1748f89c96be06ecd4aa8263c687ca0475279de989084d3a36f92978ebaf2fc26b5451b737ddc93447098d4ec487d94cea5e12b45b72ff58eb4a73dcc3511d4865b0751c5dbc4365ade854360e6a2e9f332539ea5d6a64ce043c92dcd90a13f4c04ea86491cdbcd8cd7189dfd5dc91260c85dbefae7652643b56ff1c173b82eaf8da5a3bcba10d452eb860d5a150eaa5fbc581144b5e7fc5976985840c1618e32abf2b7a423c9b6215f740fc85356a3e849ff4de7ccd2b01ca7fce266260268912d157805146a10540f4c3058197496ebb0028e2103be2199511c640268d577e861e2eb844013940c4bcc1c29aee01f53e2bb8bf222e6aaa4e052b7705c2a7bbfa049bb2dad3f3aa3783337215025ab6292593e6d12531c4bb05c0691a6b2a643570493034ec56a69e12b1b5fa507114bfcc693ff7122fd6ad18ad06fa8ac49b98cec0ae6f2ba284850f7c912a292d1a88289900615c2d04d7e8546c609454b47354d82b8d5c60b9f76fef95d3775aa8411c3a7249991b5e0d1e46c2b05a23a95686926f78134fd7efc9ab1c8530cc9e4a0816300fa80ccc1b55efa090d39e32f5edd288a0681533a0365adf5a4726ebda594207e90c2221abef6d1775f99a4222dac21b714cd478b16880e1b1304c6dbc8b8303941a5bf3012389a8e8606a230d260c2e8e1973be8ff917d670ab4ef90a69d7999f0e7a02d4f20c92367f889758eb35ad6d9adc64c8bd6d7b8c3cad0731ba486b171baf8461bfd8ed606910c92d86768ed6d906167b34c53edc860c3f79c7dea03863ce5dc67cf4b6bba978d5f211a5be2e3c269d0b623488977297319a2ebfafce7b7b89b09f98b104ce6d8fdcbc569ff70c15a1b1fe95ba76d3fe6c948f438df5f8a97b703b60dc63089c79bcedabf4a74b723a1229d638a7aac291eeab82ba52b3dec018e221a004d89731c6c6c05421f473e99a2afd60b179bd6b72c53dfb8a47de3843d5a6748835f02f948dc2d4ff6deb7788314233815fc69e08d66e2f5da3fd217d2d619de40088fcd1a614dd2a817bde7fd3187647813471805f19ac70d29cd5de3a71e57f8451acfa738be8c8c2ab34b5439a848b3ec34b4c4326d27a080ab2da5dd801cf283b2ae87d1383d27b847a818f530e9afd8ef212bbfc3174a9fdb54facdbad66fffe26679e0ea457c269459d1820463b144df4033c8c62f424d866e5b4af02ad15f8d2f8ce02f85b8f7d0b7a1bce80b9c91e5bfe84afa26f1db5b7a276f51a49da26f728039a0eba4af1f8cf94e48c46c90a46fd7e793397374395b4901bf071e8df8d373a99d20b2e0534e7cf913971df0c5b5b6f1c26502c657a1e46dd9eb10eebcffaef1795164221372bb9185c35575cb4743c89dcf440cdffedbea8fa0c7b452d0145dc8755b2bb02e3b8b205fe8b17868399dfc8948fd006e671af0b90bca313ff044c86d294a42082fdd69b47608e82181c495c98eaa8daf530dd2cef7da15cc0f28dd9f2e798156699015704705ff684764f1f293bd566e67720046480db474115ae468eff166659e19e54d0b8c563b90d744bf746fdd09ca59974f348e9e7a8c8a0448b4c03b81f62f45fcd9c3909e1cdef01cc0950517722bd5b615235b6d3af07f343cd3aff977f3d47cf6adaa9c9b8cd47b7a31c280e4f8bf34fe04f0341a58d9fa089cb72f5a065a49de9b1c71229fb47c9dfc58257204be586e750a39518080984960c1a219979d2dcf81aff066c09ac32214c6191f375cc66a8fea3642fa749782fd850df7793562f68a4709f38e1bce0ad093a80707d11a6005ad097be3afbb4700cba550411311843fc0656ff2ed0315aa1e894fae7e8be0a167ffb3ff09b539ff95180a574bef71c535093b35618d2b57094b37cfe0986f585cc676f3d47640a68618227209cbb427c75f978a3a711cda30caca48fc93114759ebc791de8b51f13b852e76ccd510b5db5fb0ce7083fd7a237563ad38f704fecb2dfc432a710fb5eab6a6104ba2983fed46c0331a26aa910d488b20ba4dc3ea44db8945d64b440ac6522f5c645eb01f2ee7a5e898434231699a60ff515ba339120958157704a8adec2f3aebd9a80863859257cb96a499a81ad43802ac8eff6906494ea7e5f136f13b7aa14d88acc357891db73a269c52ce9fa3298c192a8fcdeaf98ef4c9e8dbd677a27757c4845e61ddbb66ff16e4b14e04f8ac566b874418c90e7bcd73849d3ebf33966f319b71935d13ceda6da2b0a05221195bba23fc2d588818f17c241fd42b9f490011f1c1a0b7c7d86f73cddc1e5120fb1cfdeec4af9342b8e9cd6d3b3c7a801798865d5d21421b28a20534c82efccf6fb7c1d6c7e64547075db0843423abc710c68d44a57daf16c53807baf9448d88c2d180ae63c25256b008fbbc352841500ddc3a3964585f648e830546c68528938c137891f1cb9021037618682057f55742f994be3bf434eeaa3d02023aeb83e2872697d3a96983e6531294234924ad724e61ad5614fc33e831cf659c24540b9338363223e6e859b24fd7436425aea0f23f10f19c52af9c8ce81991cc6e4b5440e9567b2f302c16c19cfb494819fe4d67dc562bb7b7d87a4ef8de81585e5f31016cbad1b2f867fdc43d3cd89dbb838df74920b0babfe1203e791f1207ea98740884d12284e08c96b98f9ee5f3494b5e537c8e029244c9d7af8645f1dafd748d93347a7ad0cbd7719d2719b0742d892b01ba0526a0de4c5ca46f93997502c467be5ad6b1515ae628bfddaa87bf182407b6148a60ebce7ba0b966cf453ebf7d90da3164a85c92c1e253860b8ddc4c3dc98f182280f19324aab9da4a56ca80f49d4e4460a7cd304b0647f650c118877bfe16e19cfef8c54f8d2f037c423e8011be3cb73a9a1bae1daad92ea777dc6aca692f6ce32c5b9973f1316e7e5dbcf8f7bda94ff1408822383f3364eb662ee88fc6bbf438c377e35d65f1e167675b7d7efd8d2e801c47c54bf99d48eec5cd262e46cf3928336a2be3a75fdd37b3af9d8214ccabfc8e42fe7a2e6b7a98f5c30c41274b6c7b86ae90170eb2d8a23e16d1edbfc8eb44c5aaca83489a1a0e0134f5ecc30b9cf7740604ece7047ad5c656b7f7e3d7b95598290c844564702997eacdce992b55b5666db4577c73157f7cf27a6e146f7f9be0e975a01a5490a92a1d175cb694f06dfe4e050fcf248361403f0fdc369c45f3a90d561bc805dd3d7a2cd3060ad5c8ab86911c4144b5d33d351485d60ab824844991cf21a09a357e7bef0e3ae9cc14ac42f4ad352fdc5d6fb86fa2e8a3c7645d0d4ec3942bf6af9e7a89950248c65f276a73b6480e7ce4f51da9cdd7ad4a400c6afffdf70253fed0541e0a702325eda63e022a1b5403b5cd66c93daf6b71985c2cb42b100a68d195d2e01134b985d73a5b25abf3d3b6295e5d0b887cdf24e7fbe281323ae1683997cfb2d260cbf502557d4271566ab3167099b68055c5c2ce56317a9037a880f2ffd40d4e0febe22ac77ab884d5b9c5b48ca354cb3320c75a5be0faeb0d31add844df44a31d441e27c25cd9a139cb0ac84159702d5fd9e5c58ee3cadeab60e83794db20f0d051d896f40700e09862e8f83bdba72f7b674c509f46b8f2ec89bd022f5122c91a7537987f899f52f0610e788b8e02e06816da94c6d56716b700ed22018ac603f768a646e4048788dde8247a3c423dfdf6d99b63b6175bf1f878164684d207f5c1f23fda42891beec6e30e6aa322c80834f2d13128e1462c86f172c88ed0ab90963d65cb3094ffb2fea7051bab83aba1a8eb8a0b773c7e9a921eba0bd660372a0300d003ca5d0b5d874a270e27ab16c1d9de26b8785dfb26e46464df974226f6d5854920071967976977b251fac7957133024f51a4f3efa89187ac16ad4438d14f4927b5bf1fd8f2989de863448f10b349a1acfa10fda73158ff4b271420d016b222424d2c4ac28a46447e9111487cf4943baecd3a75532920a7a73e24d14814cdf1f13b15eb82e2157c6fc893054e8289b24de5b4678649abab78f9ee7914771b23ce01ea47ee49466404a3346679d07509ee4843ab03a750eecd095a7667b1fa03371bf4c71fe1cf184df2466de1ef823c31add70c7f35999c73a00644805751d8e5d00c14a6b067a3730067c700554cecaa788d46bbcc6cd2512480fb666d2122c657c0eef7bd31bb8de4da900bec89b2af4c942e88874f37e4f30d2f41208d58cd0ac80815b7a74723b22330ce353fed20ac0f62b6d6424a0caf1ef42428000ca09f2e3af0aee40b4426547ecf6d826b52ac78efe632d53614ac128cc94af622987acda244d67caf02019ad8953d71b6b653f71d21e53cf86d7f8667cba7bdf2164b465b9b54f801005fe88dd208e898345ecd89b0ae2579e58c1ab48492210d09f76f4de93c5e5a3531a2b0e338c5fdbdc15d82b4a564983430d793d44f6758edf438c57009168e2449c2ec5abff72eac8a213c3bebcb856388d730adec9b5517849928770aad00a1e5b04960e8e7f25fa541312da64ce5d7ae12fd95f5c062534e426005832005aab65f0c32c58e0ecad0d0acb53fcbc7f5f01ebb986c4d8a80f2bbf6032f0e203d5a176a5aca7dc0dedfec576181ec2b164c5ee8e4ee54958cfbcfb6ec76a9d8b8c2626a3bfd23fb2599d3fab4e9cf8550c39fcb089920bbfba95a8812f7b4d6e25ad783839dc6fc68f44ee987d4c9c2d1331aab6a5897166e4a50bdfb53a14bbe01f02ea3a5f58ac35c92131679b02f0d49fc816f4e578f16c66304fa0ae337ee3641f96f1bd7d0b78535bf445ec272605c7977e85918e0a343a45ece35ea61811a28476de53004a2b087a1ca9fc0efea3e5af39a4cee98c55399eba4ebf87bda92e65e1f5d323425927dc928db1ff27af04afb93e89a22422155a85f7d5f921648d70b833b9eea49bd0ac13524aa02bf16633cfc1ff1e91f3215eac9277ae093e7a291be98e2f488b0587e71dd0eb324f6909c2500101b6a574fc5321a3a57026581f6cac00fe2bc455783f76a289e631f7032e52ac8290a53fbafcecd84f3e456d9ea4c1ced0a0776ffc917bac05cab62e205af4079614172d702114d8a277ea6ef8d9f5de4ea990839fc6f78445a2780d2b50bdbee577435ef517deb75866a2329ec528107093c4d40e7b8615fb659a9339d2c3d8ec9b40b1277c9eca91b0340b75805f9c39787cbc2aa5e5f66765d04e62f3f9b53e06885bf5015ca7cb1bcefb7e0fd1e2272c66fcaa3cc947e047f7eac3cf9558959a35b046a360a8a56de19753e54182df8f7ddce3e657e4209595845b1ad3fba2eae559201f7ac793aaf899f95daed6b9eebf1cf626301d8613eb4b1cfd6e0b05d2042c85cb096151e32dcd4409997e39b420883878e460fbc79c830c85e202db675b8a9d85980b7e2eef3306a83f6d5fd8b6e1bfb6c574280ca4c1baffcb1ebf758ae7b57d783566395adae4ca22ba7ba7a8f972a6b77bde16ba55dc19435905c2e6eef4570745cb0656da762c962c7c5d99efb7d47ec19ee3d7d904ee57778f2d07916067d34706648b684b3fe21a0d6ddd2d290ce6578e98015bcdf4a17fa04c4bfbb07e9aedd1ab8a02cb2fe0222d2faf6a07bad703ca3c5147a25130cf8f5516de056a60cfc9e958dda6af983ee1542bdad0bdcbd5bb3c3df03b437dba13bd488526a8bf64326af47b9329edcc19d6830316f5f26286650dee515fc9e67d6b1481999b4ca05f1e9c95453603c0876e9f74a0aa772ad6804d9f667c16a37fbd94c46e6c01cbe78e04812dce78fb6963fee1e18a52a1af5d599aa4d7e1682cbfbddc883e144466baa637b740e7a0c5742cfc02491cfd62b1bb1e026327cab0c6abf504777b6914383fae46d460dad4df7170413256c9738d2625ef9f6033e38edf3cdab333718d80df625f93f90469961500bdf85dd8face99db3f4397ac49c15c37fcb0735ddc9a0c26620f8022c417cee4f1add435956157dd6fca4be9bb9eb59c4c503b02567964565f5d263b3b1268aee4a28895e6e98d7c230e9f20e04848617f403164cddea2f0021d25df69273697650ebe2944aa42d091c0fa8ef798ca87e1d16ce2fbbdcf808702e324ce14c99d06af8de1e4b735188de41ea137a692b47905f7c437e63bc296d11417654300e7d871cf4f4ea3102da2f1968e2a8d3c07478a41819de23684bc0a0532c5104425aa6b49f7ae679e32dd6919fe09160f416ef269b7d2d3cf404b79a59f3e2328bc95f6c8903c8fa44f7f03008487ad10c63cc2849fb55ae0e2a6e44fca79398556426e3e1e1b5529aa97b9c0393b1f278b49225af57de5b2d333b6c3c789b74713b9939554476ebfef9edc5a98e6215e8396d9be8cdb3d2386398d267e0420e152d29752c431df6c96d72ed9d75175ee88f88d857713b36805ffef13be10fe3721710567d4bff4e9056ad631a514f368f1edca2c160064d2405ad4b035d6161e573699c0366ff7f2885aa9b9b1a6fb492c67d2f859bb9940d38ce4e2c55f09bf031921ac385ab630677fde087f978e3f3e75d4dca288a595f6c69e580fd6f7e2f77402bf6196f01d382fb988f70a5f13df252aebc4c734fac464fd8c8996258b313d3caaff19ca3f3d508723d3e940f80fcc2bcf9e6224cebf8cd38d700d5300fa61e11016663a8f2735f4a4e8038fbc2a7055ea70b1e2ede9b2d053bcaba46e72e061864184ee396ad980c6cc4245b523fba6795f30be92ee137c178ea772fd710624e4f7be10783afd5d697523b675e03c3c57759a8c4c4d51e3dd1bb5d5f7f3b065973714cfcaded39aa61cbd23cd872fba94962d02a45cce6d554c48a8cf28c3cd14f3749f2c30db21e73eff9e2ddd4707763bd2051e4a5164473efbe44c7b4d9f672ef7a4321ff73b7c6f7a6957af8bb1e88df81d7d742069b5102bcbb59e16f00259821b8c2775224015a3f1699901f4dec1dff632d85c0a55deb0430285107e75b19cca6f143aa91fd196505324252515a82279dd8b092f7297c301459ba5e8fe3974664100207fa1ec511cdeba1629411ed0ae81f838af9b33b11fd62befe3f9db0bfd9fc40b431692888fdb0374057e4f6fbd91b801b903297f1ed995eebb833de16bd24fafced9fc2b2332e9640c820c734519b3f01b7b1383aae601869cb1e110a352f6d9c804b419ddb790a1d9f35e86a8735c93a1918fcd456df604b46ab4179a81056a462897ba84cb416f945a19ce4177d28c9d57c0556d89e3a3df1415f23b7531bb516609554fdee990ecb33f88cee5e54bb26f7ae0d6252ac77320635e3fe693699837c2658b87ed7ca83f7f947c67544dbabffec6854102816e1847ece05fcf7f5546f8e12efe53b2d9ddb83f12daaf472f365f140dd45342b64085bbb367d1348bd137c5ca900731fdbbd34ffd4317f25ed8f85cddfad7eff6ba46c51c3acba048403aecea4f7a5fbb9a401e8ec793027d5b60baf189d1c28c2ee2ca17d98307c6029e18935dfe49029f2e115c6e7e115ce33fa37697310c27036183e70489432eaa7be32d2e5ca700ae12d018333682b99d968529132047e44174f27c33c199ad6d1d0414cda6b56890a81b23f2873c2d642421e233723053cc3e37911fb99b7f71183d860a3cd97db41d41506d4f3fd5599d05b7c9f900a6b9b7a3c7163275bdd8873315bb3282050c7fa7be9c8fc0c5597efe0aaa7be63d1bf1dab53646a499baf505035b4aa3a3f6d077d58d600925e3a636580cbda243cc827a4633328bbd1f0bab4b9b3aa4e91b1b42d093efb233381552c161fe2b5f567641706348a4aeee65106f94137f2d374943e0c2a8d455486a7fc499603d6106e4fc9038d506ee3e7346bb9952eb182824789fbea4aa510af442338a56e520f3d15de1a04331efaa4104479325147be4ba4925b3b28f1a277ea5a258f4a4bcb8e315582f1ac30c6bbcce91f467bdfc9bf92d651a10a0618a7ea221c4650acf29d60c048ca8b96c48b696e8a937489aa0e98a6ebd7c737331fd4d9cd7621cb57205d884f9df03dae886632586601d402e3b25bca7cbb827a025b936123f28f326b763f994de7ab53dd822e3918a3e061067bd41469889a8353d1041d4d0d927bec3ba9922c6000fca634b178b5687ec6a142c1bcbeb393174a2e4a09d8182f3b9361d76421187bf1bff96965219cf42832c94d661597c356c91d5966fbecb88e53793a5519df0743632886e6c6eb95a13baaa725b58a4321817b5fe960a46a06c5b272b15266f7789e609b871dbda19c9453027c6cb16ac4725765fc4bd0d5e778e97b186b709c1275e1598c9f6e62392b9dc8a0aa52ae687c826374c3b28e08c6d3727e5dfdb93bb128cfc12a0214965dfd5907e5a53f43b8e153c16d909418574f74d3b606aad80099479df8cee019117a76877561c1aecdc0a2464e879af4d992e22834e57f93825a7bd00980a9d44b7472ffd19d1006c2cb440b3a96768fcbb820a0f1656857667b5bdc15fa9c0f8505291367d6a5588b76924eda4a8ed306a49bb2d4aa43fdd5e115e9baf44b71990efe10365709448c048d2b2c2499634a3ed2872dc18777f93b386cc2915fba7b05fb84284c2359dea5ea897c6f228231c2e2946ff34eb94c541a9ec919ddc6d46a0dccf6ce44b3d162dd7bface6b2a29e9d165ae8445b2d3751023d2936087061016dac260c5f85e19e1bab49ac03cdebfd9421640adce09de8bf7e43be797d71ef195333d67211837e19041f6d7c2654c6fadad44c6b5b132eac58b2f749800c7dbcd834053e57974fd6573e72b6ff03d0138f85ac50a436c017b722650037df2409005caedff6ded9c61f4dabb0c0aedeb2984bec5a4eb66a31f3ebb2e0543c447722a74218d3183fb5da15ebbc3b0207e8b77ccbc631a00c3a00b1a425b9b81132cb060c7e036807199b271e01376672a1473261f17fe27f62d1ddbf44594831d2f3cf215c74b0f69d0f140e261a43f8737a1a224a5ebfb89178a48a0c0e35e03db5efc16664382a9ea16fd554199b69fb530cf0ce8743d1b00b12fa56c3dacce046de4ad4c5c3803d22f595443235748b09c99b416781e25e2ba27bcb70707ad8985efd8dff4d2952d0a1e6d09950775671500dacd0079ac08fe094b50eb0b49dca0b0078fefa329ca354f5d723ec4d9332cc4423370c5a1d7aaa85c997ebbab28868dd88b81b3072f2b98fb938e7a4f994687e4e6e096fe970fbb36dac92ac480115d94c04882a4bed1c0b44494260d580b2b3b338c68fa0172ac0450e194ac8ba05aa3a9b8b22f29fbbdd89b6ce44bdaf844b8d45ed1249326b799dcb2eadc01ac7662f30b569854c10f7699804e3233a00ea4765e1e853338420098c515006b21f2a9233b4eb8706285bde4f7dde058402cb572b707d5e97adc627cfe72c09f6238f8e27a4c5bf5cbb8c527b40420c37dcc732646009154d7b881837d02f4c8125a57797311097148ca7563bbccb5779e865f5bd3d91848fc2325d203e1655b7acafb5805f489cd3f39be04716f1b7dca2e0da3086f9910f2ccde7de646c40fd823fb9b79776095fd859600d95a28162704c146fa59e01991575168677c1fca65877abc671f23aa098aa1ce755ab7c98da7ffd7bcdcd7bb94ce1c83f446dd7e852c8c7079bbec68964d763674895a513870c1cf7fafecc1d209f2bb65f4b464db5922a9f0be4bfdf096d946a6221813c4d269bc02781932cb628a56aa80578da63cbc3ce2a06a16056f008ada0f7bb53e4bfa938651f5efdf530c1a956681bd0f888d5a2ab46066c443c2484ba631368ea0fc037203d083f4b68ecef73f8caa4f98e1cbab2bdf9d39b992a7c0c3544858f4df6901a611b28103246a8a4f94af4f051227763c858fce3e616b6653904f16b2caaeced75a5fd434ebb8884570654d2e2cedfadb4fcfa3009c167d71c137ed5fa10433f7def0af3f2c39b57ab16b74aa88db96ae455ce9d8c8bcc4df642afee9faba47665369e944e572a85efa57a67c12ae0bd57f5c5d801edb95d2d0d0315fc260bd05953212afcbcc8750b3d4bc8ae61fa69dcc72984e2ab352dc4f3978326e5f9ba78c834b10d7775fc454cc70261b30b582f20c8b4d975bb2f1e8f63a86a55a65d5aa73a204312134f9c7643bed794d575b8337cb3294608433943666c06c6854fb1d6b83156f271cf457e29f4421e9fd1da8b300bd85d8d0ed5db4f3f6051f23dcbe531a8c5cb6ccb73d06a35e8e36d8449efc1b1f0625ac25aa9fb739e75a84dd18c088d6509e1d1eec0a1f9b9786cc62268292deed751809a1420d7e7830969e0c0c9ca8ceb873b2ef0afbc8eb22802186c53dc51de5b972c330d425ec0735551e5db79d177aa57a5b1bcc902db595963e47108de9a4bee76eb96b390cc5cbf83b28fcae945b18eb1b101240fe7fb122b78765d5606e6ba3a53ca5343b0909128a9c4fdb93c81babe3f2098b5e190b88279a381ffe5df1f92ac95878919ef6ae4a351a01ccc15c9300f12857a44ee41ab650f5ac248a428610f06451c9de0b94a16de9d76f1063b5061e90ee209a030b290b7a21a216c43e7f54be5413bcc8e9e6aa40462f3c442b609a26837b1fb55150a1f5fc68a2c513f6ed5a41b12d2826564584a65af6e99bd3b0c0a314c5f97735940e19134afcb12b3907904133f0555513209b849ddb78b1ce89c198dbf20782ce9f8a1e3aa2c9481761e1cbeafdaaa583906aa03062e7b1c5f1b1c3dde20d6b2efcf1451c81d9a240290f2a10359dfe6ffc8990c73826db39896f886d5dffab7ab9e0dd9f506a7494e45f9ea728906e6923206e24a22531bf8e377e1547cc5c1bc4131ac086cd7c08d090714741d733f20f9a739934f36f74c3f50d499a9ffb6492b2c33b6d40634db5740ae6c5db1cdb812468f95234e3386d25056207dceef04fd38023e02a379f87ab8a6a87943dbacd8b676dd50e7ac7fb7d22cdb855d3da94717739ba095516f9ee0f7fab49d07d63640a28bd62f1f2cc8b1bf544c96915c1a3461630e5d4e49fd51166a110fbf339ea7c334655bbcf652b89ff7742294c24ca05219b3d1df030df491d4c0dea8131af4f7a263119a8f0b9d7750a5e4c2c03816b84ca523d399371a5685b55671a68d35a9dc0e7bbdc3236d9f0f7c4a6dfd1e87bbd7899955d350684b21010769f934ef575d93c599dbd98b6b707581ebf49ed1c3aab3e015fb2f267913242a5d08f1abdbefd0b0f92b3eb351e794dc034bd7c16e8c2e0f49a1a4c1f90f41101def5bb824f6592d3c18f011c26d9f1a0f733d62de47fca5343bb60dd61792a42f6b8267224d438a287b1924a53427daa3cafa94c835c450a638728343c8266dc11c7c2d1db7d6c4411e1165876776b935b3236a1a59b229e302408d5e4ea0eb5be4efe4071d2c9d93dd2e71494bbee19fa61f3ea3b346b0c73d7b18dc2a78c8c8ceb8c5abd9a20b232e3f05a0e41ed6de2aac36ee0e880b868396866e73164fb29664389eee1dfb8b764c2a91e2e5c12c06c6ad0c21a80a73c2c7d6a382f32ff8c5796abb4736d29b2fbf4ac72f717d9758faa536d74a72b56625aec8146806454be482e9a7d308407d4d8aa606b2423821bd4da95037f23c4e744eae53eff341eb62b0e3a70fd43bba9a8a7d27f56455b1638358dff94b104205a09e368dc340783e1a4480eb5d4a65658db41fd8960f866fd5ea8e486c83f5f029c134183b0dd052dead011ef280b449f6145614d12b880240533ea39ba4a3df2a33f91e3edc4dbac81bbf0f2093a6bd9eccad712ba324d7a591f4c812947d6fd327eb170f24fc0f8a54642421604af71f98dda70002f787f8318b9282f3cba23c6ba58a39c8c27b5816d1f294cb20d7a096152dc512432b833ef79f0ec7e526917d0c3813fb1f6f32c144565edfed614c5992693a4e350b4f9bec132d6f96b93f27c6e72c5b6f5f2ed5d571d07d720d347923c3262ff9f224a8d986bc08f6cd1e0bdfa0f7a3fb59dc2d9b04d2749bbaaa001724a639f68a2442ab89f7d511e4a3db0c6e6c05d05e571ed23f781ad30b2a087385b09ad82535064e6a2b8257092a7fd83c741bbbd0f1158e6217d92f68da14996ba8059590a645db5e67896445969ff54fb13e6c967f5fa1e3ad0b597fb4db58f00e2effd3bd1557b4d03116ba3c830806993f0c5577fffc1e4431acbf8c562026ec3b6d390f696795949ab038f80f5af4e49375ff202ed72eb8fdfdf5c2c8d58dad9356ae9bae31a6f29db225e517780daca78f6ec53e3721f46c1accd86f755a038d934d7c3624255106be23e58f6d0e1a7c41e872227ea759c732afa59ff25411e087c095cd73dd37a3683eaef25283bf5bd001e7e3564209d876b44d6792c91c9994b5a57674eaf2ac0306abab2a03a3877b9d436213875a5041fd68c961bbd302c894fbad70e123b2f61cffa329f54c782f639c70ec78582f688365100cffa0bc3d67908bd99e8164a9226fc0059fa9b914591e079c6ccb3082d3762a9d6129fdf25d5e66e66794156ca2fe1d8a8674b1a3e3bf516f9dda74564027ff6047e61f1dbf3d2cc745943a7fa84da674b9fbee454e2dfbe98b847a79ae60b974781da39c2221d506cb78a152d5e74f3ad0c0fc70eeae13dc4d1e1e1d90d6fbc2e7e795b2faa39b924cbd5831a92e6cf80f49e550e646bc2c3eb59273438f9303844a69abdc7d9887132e7cd9749fa5c9ef7d09bb3cf52587e1c7b8fd2875a034fa47cd847675c4fc0db34b72fc1e53fd64ef999772c91ce06044a8028fa95c0337821b5c758017c25d458e0fd8f73bd2f478324f9b2bd053133f6cd488ea60e293574dc82c63d2bec9d95d1fe6d4a5d8581ec24c427cda94e7a1260211df06be5c81704a2dd6eb9834dc338ea3b07ab87fa81bf319b33bc0fbba658b5ba9fa3a49bfa4e6dcdc87645d583dbff1c548cbdefbbc483483ef2542c7a5256eea38c92e6fdda5977ce09f5b1844017dfa62993e7568324a5c6415bafa97018bf23456e7490a663d529cbaf2a9c1b46e99453a1ebbfc94a4685696c8f0406bd6e69354acfe5a7c166947b49b8a02cd974670721bf8a71af39527ef9551cabdba6fa092cb2ba6e3232c042d9f11184435dc91f2b842a12d29a02a65140ee70c2d4a7b605a904f64b93b216a5c33e2e0d6f21f72d34c6a650ae6387b7c59b06d40357b5ea13c4cd982d28d8d537f237beaad97c7e33334cf4c5ab3718c6bce258d2b274077aba5826ed71139815aab2e5138c6964497c93c043e7a1b42a2012c27c52a439bf7580730ef9ab2a327eb9e69fd26aa3a3565f8576a7ac1d93a3909956d1e59bffede9f0b6eb6aba357ae3c1a4dce1ac4a2ecbf84a0ee43ee42ec3e7be842426605c8c99877ebd9010c0d7a6cd709b24456df7dc94a1bceaac072b00a62f52205c807605e780e116f6510d9b1fd6775ddc3ab0bbe49374ae9b7fb24ac651b1c9f06b979ba5c1861604472032d878a6beb9702c153d4315a17a3ab95c52e4d99592c50c1dd0360588e701fa76507d273bf1a465c871257bad27a11d730ab83616aaf60d03e08d3f8745bd179522e2a5db6c2c9432b81c930fa658e08b70fe43b61b7cdef1b6f68c706505f587290809c5a37e692158bbf93581f05fee45b817f36d133de8f9615b4944f4c653c5c312d075bbe95ff90b6b043812e520dd1b0d6b53f098f87f7d8075bc62acaa2e140ca195eb0a9f953e8f3e085fcea62db3053964cee767c5771720b289e7e75f08be5bdda5ec85bf3a3015fbb4c3c256cc130a76da11c5cf615b21cae7fffcea39a1786c08613a77b7642bf60f90e9843ec8395bfa71d53ee1110ebf9d51dd0a97edd75cc162aa02a0856c38947ca5c79489a2f9bee0b2ad83a1dd3d7482d41776f24cc7686ec1366ffd9f412bfe5d326c7afd8d7a411080a13935492c32512134065114a335492fbaa8190c4e30df52cdde0d705114fbabf8a93fdcf5fe7bc7ac34ab9ef42c76c8f6f8852062075d5b636659c6f8d85f57eee8ea2e5b32db2600f15a79f555eec674ca26e1d2830f9d3f8cdcfa594c57465adfae4b9ad029aa2cf1e810ea0591306cfc5179e346c38361356915370fb30466e8b5f9fd51b53cf74af757861afeee6d8a937752bfbd16bdecd49ba638d5d2c1321504533fd6065278d8687b3e8a51e08c57854dc9f8d973d883d3e1726fdd0362e07c4f1e6a53dfa63cc933d23c3ff527956ee5ad319c64ae42a5ae811d3c51e0b766f01fcb29eefaa512ab91defcd24d1354dacb299d36c1f3e8f212620e60a43834fae5dc21f5bdb36db896cd131fc0e8a31aa144624fdd7109542ef1675cc5b274d003f9592da08ae5df4454400c15e428435522569fafc8e7d423a8cd0b46d7857b572681f9bd689777a6b372aad4f3bf92f0ceb38ebf28865be5648bf114e9f46a0206d59b4ba5147f94acf5d5df5c459e7d8b1585b06c293575021966ee5e99a5b45c0f6656928ead2cad1ebd5302960df3fb74379932e161f61933ea1a394c96ddfa8dff631c6bf4b76ced5a468884dc61ad0fbad348ab4bb044c61304cd21e0b187a9e5f5a9cf336cbea81339bbcf8a94b094e8cfa8bf3b0a02f13e304455fe326c51bf6b0b3990bd5c124b9cb5dace95edeff10b920465eae2157bc98c758a8112f32ab5eb05940b8877fdfaeede0c57ce08b0b974bdea21f04853e3422f17bed34308a8efade31dcb2ef50984144b213c18a26456fb179c09790706146e5214c9ba70344c87f7bf16e16e3631fcec269c940053cfa2d4f7fa14e9928ee94cc2e97a01ca2fa6cd137afdc2779cb75d387c7ee711e0db10d88c5e1a516d50a7c749ebe383c03cc9ac8cb00699f6e55b14779357241309c9724192f2799234276c560b622085313e99aa0a4f33defdc246655b55f0bdf76618294406cb2b93eec89464ff6089b7ac9bcd019533bc9f0af700858a9c9ebc115751a7a5aa64994551fe714ad1d9f96b18c39785563c2f75128c9f1d04ea45071b24f578b2027729f66ce2c4c268d4ce40dfff1d64a84c8a0897b7ea9bf90261acbd4bc805a48fdbeb4625b880a10cf9050f413de1c071dcff9442c72f6e78d39fe92bae6ed7fc748ba5afe580e3447b9974f2a1626459fca3328d9ec597fd81a70b31a957e0a42ada255ef59b9dc4fce99d7bf32a87332bfdea611bf5be453fa173fcea89f2e8d44328c274734d8705d9de2aebdedc208cbc6210be87045280249f0b0bb46133dc36997ccb1340daa106fb5490c16d64924838f2195dd27b2ed6a87bead7627917e030d0e2caa2752cd57aa31d890ce9c58c812544f705f01b036552f35915318cf30cb9020a2b508f1b5a267d9d1e0c375166b905284d33a94ebfba43f29c201bd757759a3c3210e7a690ac5f48c05adbd4b510d4e020c37126c896a3b408bac302507960d7cc420c0dfcf67a2b0fe0f2f9272246d13f1f71a00d9ac182317697750d37b71ad19bb11a142d0e720f72c5239ca210a7b35af1d19a6a37ce38c322d060e8e0a7daf43af9f6682e2baf2062303c99b854146c70ae9ca88a5e615c414a1388bfdb77f609d13774ea3319bda0ba282829869b35edd57786bc02cff0d73ee9d63c9dc9fe77d4cc01d966b8ac5feba4154813c01850ee8153158909b15ae7966061fb1064d53d73ac3041aefab3f80d9e76650dc38280a1322668050f65720de3ea17279a6eef2b7a09f7f712d480f76a7dd66ec48ed6509efac3f6cd6f3fe154b1b31810a2f96258b278ebf361c57c918e4963219e82b9e0fc4507e78f70a493d1d59ca781de81c0200fdf8fc5564890e29c9cd94c444580000bd81d49f3fa3b3a9064d4ce74e896f8a27bbe887c0ef9e4e221999bbdd90d608b9a4b240b725cc9a863e5b9485a4d7f334b056c006391ff34f608ee6cfd080a89f161c3ee01e0371d88492e7e08b3d65399b740ed91a5180cb27088c8b569f5220a6b811775e6f79e8877b76290c06b1f5535833661f7aed656ef7564a6561ae34a38ad89f97b098063043ab2d6a0367a7ca46d6274cbe1648a907ea349d2ab731caf7ea23550121b54f3112968947a2623dcfc446219fbc17fc932219434eabad39705e1fb1fb85263a0740220297b6a77e02c9842dfd698fadb5390b331aeb08efd0739563e4ae5b87e90953b431ba85870114830ad7500c4d08d0d1d977308fd2154abef3a4b3949af4a2b8a83354c3616616f1612af42de7274056df73d6b31462e64f244882ba7f1d497ec455998b5733dfa11a62f175e8fc517a664656f0ef6397e6b5897a64214f7d42d9bb5b40f2a89cd6d36be34489af777119d5ca1351b3ca7f95e1aeab9b286c44175e6d1505b22c407dbb58b7bb8c1e4c472906d324e41aebc55349d80fe6976117c43a63d00bfc7de6baabde6a742754389133e4f216f4f32caa68ff803e1b50d9a9ea28d92cb7dbd3da7521dcc4b218bce279f8f57c68192a3e7df81cc76b9ef1d0d5272fc47addeec8dd161e13c062f9c094fe76de09b7f2689937d3ce862c52c211a3292bdf9596de7809ad1bb2b6b77c630d6c94bf2b48dce9cd05c40a51104e94e13320854e671f2165a82b12d8740b0b354b2f3702107b96058c7b1165658c2a91acb36440da830d349098d33eccc08406e9da51c7d2e56a8d6a9a7b31925db24daf270f700388abbcc29267255dcbe1539bbab0d1a7fb68b2ab74dec76aab335d8d9c8f9cd7bd4ab8c499b1d5131cbc2e462ca85336b8ae6766c02a3e71c83e6be3788b912bf498c49436251fcd52020e3b521c8b498122e9bef032fc301a1f9e17796d919985f3fcce48315a0f9dbfd643a3e638e6c634673f13cd5365c5be630e55bffdbb4c3a729a0286cd0a5435c3efeece2214dc88c5deca4e48b33427f3d71919ce32fa1abbef843a76c1b4decdc713aa2915d486805a3819c0e0cde379376ea09ecec1a306ad83fc1f7c72e37b12bf8b612f4bf142041a32107a045db45701ca281b3b39b4fb4f8ed7cbfef5f3d2fe5eb225a0cb1fee1f4aec69d0a5bb05dcb58e6b2d26704f98513562c326d43c4a2a7520b1e5cb7a20008c0a8969bd4a6f4a1fe23538253e7c47e807ca109e7359cec0ede4b35c54495d7c9af3e1505b97e2a15b5591921942727b2f2ea9c5b902ec2ad02394b0a6d1d8be66cc26e12cbcd6d6b6ea327131ebc92a0c0679469524511fc4abc5bf48df849c0f7d007c1860f3dfb3d08f384e22ee37700d9e09df6d029f28c42267ec66123678d4a5cf87427ebc4bcbf8d2302968159bfdf800938f2cd437d85463b088dd6be9cb95ee0d6f013e4ca9a83e24309e314fb9b5fc2f0e1842d80d811db069a6e8aa5fd76b1fc465e1e92a8abdd9328b630193c69903325feef87832d3f1dc9a451df513330e4e40bff583480afd56222b5059711137c20a10cb49f1d36f0bd07fcd9dfaf2fada4f19878a22b5f7dd2387b477348d370020e761b46c31f44eb0713989f85274ec7a7890f59f9d64d8f7a3b15b080a540a093696c9b7b364aa3b32c1eb1c10ccabf901e4c75a94ada7d475393b386cf2958abb3469b1b9345fcecb3d8cba5aee04562e9c655eeb26e3634a92c47fb17a77b02fabbfa234153a290add47095c197a4d4c3268d795c931fe6804dbe65129219afec5bf8780be3390fed8430f841139451f494397c979430c72391ef2ef6f224d3c0bdd337be6ca8a54b3ad0a589f92e0dad1ba3a9e1df0d5e502b24c1d4ecf9bb5b9932669aa5f8da10e0ff4b0920e26cf28c914747dd73210dafef8debb1965e353364127cf386fa48d6a156bd422e7a59452c04a3464582391269b5c7fce0ebc0865ad6b85293883fc3ea4c2586499d1f8335bb3eb3dfde753d9deb0dda8af52a9e97a5d270169f25dc10d24ea0480d6309200cb3d5d5a1c053a5257adf7fd5bc5e11610e6765a0eead06fb73110cdaa2af28ea7958523826baf6cd340b1475ede98cedd8dbadb7f224eb6b3dfc22272f23125670037d1e5f90bd112dacf2b569c4cb81b106e0689233f0b12e160c7a66d120fb14d78d9dd0647631f0ad41e327ebf87ddcad4236ea2ff43165200491e001bf04a141bfb662e300a0caf11985a794312ba6ebf0d5bf168e12e7b696064622a843c4982217b86df858cd30e053350415d4942603525319665e5b17fe9863bb2f1431b6da374c140565b5f4f5ecc7602e6bfa19d9d59acd395644837f9a91ffcdc51eeba2ba4bb0718524094710d45f2526b5c848e99252f30c4ffabbe3f9476dad8be4716ec6f90bb552ce69d1ad94fbd769f15517f5ab148f85502c108a6f5c3cc5f0e762f43b2a30d29cbbd16d24c3681a5a0a42bbec73197a9d9370c63cd5280b67e11d4c8b9dc5af0faf22dc70742cc9ec7d91bc14174a013ab2b6ccd2e475c0ee14bacee684eee6fd2dc19cec8f936ec014b5a279161860235bae0b2fe6b2ab03edfe3ea2967828a6715d8413d86ab34669b805d7c138785393f11a82c1940cc44ba82dfab450deee6c9781c8a600e86511d063948640740e960827e15f791d6a045d7cf886da9a7edd98c6745b3120bd9368203bccb7b563f46068b6141a20e0f2840e50ae83f0557b2d1a4a0a2c8f9665d94ef10dd15dedb3522658956803e9db89d428982dc428afdb6ccafd67d2d9a7977e4305531ab2f264c5b6bdacbca9824471ad5451572936433268a403d13ca35be9ad7990169dbce01e5ef7a20c6987c1c9eb6b7c1a657d84524b3e7ed36269adb370bb62a7fbac9f823a7a5733f88777ecb20f0c5e88ca08cdfd50c3d1bf4ddf50ac95b442521af29c5c356f55157e2043c6176bc8a1d9cdd3b49dd36622c73a8b8ca0b987841bb7d7334ed318b2e4ddde5989e8817757a80f4f4a228fda09a6cd7516e8b6821d65fd8b28045f52acfc370f9e1de9f178c7b162d8345606c8f1d2e0d2c51564ca3391fb022d4ea25ddea4dcc9a4a9d84e602de1069d16e2d1344ed8160ffde5fa415899700378dcd960d9bb05ed99b7df294ef8056bf1fef02ddd8aa377697d8f3d654ce49103987036e740ebe3787203e2f2161eb9a1220e5e50591b2b214f3d94b6981867638cafa978d3bfe7cbe4625f57c2a61bd27d04bafd8cb59e1593d515ee7462b5d40f1392fdfd23da941ff152c70796ffd6838a7343a3dd96c5ff94ee6072de17593f41df5981e53cffb5894bf85a5f2c020e745232e7e370a3a0133780bb703f46ce580eb6506314b6dac06f811531da19476b8e59fa5583dece20b9579b618ae960b3119db1a0bedd468169be838158df0f8f14b9440c44e974cdcfb9ed1e2764d4b204b4606020868175c7edb583ba550b554ec27c0af6746c4ff635c6392ff6c84d07a9878bf9c3de3bb7278a7ceab83faffa5e9897270e200d521ba0115fe8000965e34889ff794387ae8588fa6e5777b3cab45d60afd24eeb6796df4047707e557f84176566e8dd41fa4e08bc9b8db875251e3ff4f72b38dd72862563c2e3df31c2f354f24921ef1488240657ce55d42b6319e200121edfa378f69e763bb44cd8720999ea3d04f926dfca827be745684bb9b9752e82dd1c1dc4936d65b8f073cd0bfc919572701461ad5ee90983abf53e096a4ae143889a49dfc03e02c4c91bccd95a557421ef14a57256901e24616847751c8d73d0a9aa3d7fe13d055b766cb0a6d0265cc586dcd76b4d2241cfbf282c7a745faf3b9763c100c28b22d5c4323ff24013ccb185bd74dabe0b0976fa0231ba26033b7eab12ab7e2e8c1970e776ac8f0d0225f50d3fdd1b575c3db52a23b4d849b43cc6e68b552abe708203c22df0c2bb0aca7a88c9837f3eac1c8758c652de5cf91d358114c304601283e610e214289d8bbdb80c00361e75a809e4deee11ec5cf73640a9bd10eb8cd4f775595c354da8febb55ae71d4c0442f9fa48d7ce9230456b3716938a4b5f42e0e89c85347e890fc3b19765a28c60ec25256b5c9c9784e891c619ba558549f9ec1f4ea8cdf62fbe905c6529b12f1edc4c0619858c710bc6ae2da9e385feb768aa1c36022f7bd316edf38f1c25133f3b460ced19cd5f0a9dbfedcd21dc76d50855c291bfdfe47cd77c0198269dcf4c89d885c7f79208abef48e8b0c5680a1e89aed50a46e2b332472ade3d02e50bd71461257161f0e9c1a7d68c0a1e82c0f1fbdf45eb041ac505fc7e42de02d626003effbaf2c4e032d69795fd409258146cae8809bb2c9c5b62d1436f995e76603bdc5b6de01111436d324a88bb52e571ffa20d06ce20732a3d4fb622a76a8670d0911c52bd690e6a1f0f707479911fb9c639a5f8ee0c0e4e684869fa25d0bb115d40683ed93ebc81f8626775ad7899a4b7d7e38c4ddce058feb0968acf53905910e77bd3dbdf7b9a86c2ab364d21c4a131c6be63a8e1431dd72840df903e01030ef61a8c01b483e47cb7a855d41e377d70177d51d42703a437f225c7a34a21a38ad8a74880b22e23f711aa83a72e6daa39966c91b15d37e3809a58dbc7f214b94a766de8a87c450d35aeb35b3ff187f2bbfc9cc2a663dab433cbd33fd91c1617d9c51e6e58d255f4bb55c39ce1be111e63c026298d2278f7a88624b820b1cfce71c397b07dcceddecef96d977b9042af644a5f53e1a5f623e10da9d74af9a67697101a9fcd821298fde5242c00c97f121652f2e1b756933c135b43dca5a67d138ffe365a120f71d8935e89a90ef8ac4fa3532dec0c261ca7a4fae41e1f60512294dc891c66bbd071451e317f76881d5b8116d67440046cc0cd7438740fe35c1154bad72551cdac16907cb59a0d438bb0087a07b15ddf6e6945f7e038151811d02f87ac730bc8652bbb328662c7a78c6ce63f403bd337c327e115f862f70fcf4cb3037ee31710c567fc29d4a64d997555628e42fad28216eff4825d8bdb63bfd0086c126007152f28f541071c3e48d6237fa72aef290f4e61b89f0bac8d48e002e7b30f5e8532331cec8c70020c735700f868f9626a99fd085f8a509b7907c41c3e38147b7cb2b695e62247b2c28500377e9227003be8d9da9af0c689a651934e052f7438d94b8dd6ab714816e2447dc04f0fec4f920ac3f751c16a7f89cb976e2a9e174fc88509b0704127c619e069f253804e6d524b7d455aae0a38f15fe1f2b1f6d8377d45ad7703275ff7f624f36c310e1046d4f97b758515ddd392ad6c6a707a555cf2b1748ed116ba35222fb247bbaed0db76c0127f8e27a40d5f3bb05a984b36a838350f4fdd9e7ea604b2bb15bc42cb55abde17aa4ce751656535050f0192e9d73b9e218d53652cc4b190771662ae7286a0b7baca581d90ab4933fb60b5819ec7fe94db400dc9519197f0e2ff06a6702e70a1d97dc0861a9252a2ed50886df36dd393b0fc801938b566637357de13abcaa962d0308c7e13b36234bbd1b1078fa79bdc95d76406817b425b9494712b4124b9048b917fbc0f7de52fd0077a0e465538c116d0f19cdbdd8658531e10c5123b44dc86efb9fe8970d2073590c887916619bf4c80a72e8d38e98d058429f22cd0c6eaddc5b4c3fe0771399a5415a21053365c3db6c90f1d1115e06a6b034e1ee9b1faac1b33a7019932ebdcab6397d36e91386ac8665802801ce7a6fe63cefe4002075baadcb28476ce52b000b60f997dd81ce45dfeb62e6cd5c2574b4a42d68013e776f9c926096a7a47f42b55e737990a1f8a218d9d1e9af9d4663bc0764b98cb7c315af04aef1d9bef01abfa04c3d81706a17422059c581611338c0ee482440ea6940b56a82e247e93dad5225872017c84823961cd9ebc71d579e493608ac5640f8763c4cf6bee7b1382b0830a41388b5a89b46b8e5fabce576f50c385de0c2f3408987f8edb29ef17b3a8c1e3ec401e145f88566f7b3cf4cd4def9ef9e9d76b4bbb4646909fec10c8332a043e6daefe60ff7df2327f730b5c65c72d5759a975a33bf0165a0fd2f5b70f8264df78e2839da5a808618bb5abbf39ad3f88970236cc7cbabf77ef36f4c7a803a018d304e797edc313ba724a10b1a91d0ac60f20a70447895510ea3d8214465543d0f679eb33ac0c0cda3cbce3ca33039639074d28bf78caaf3bdf8ed839000a9a9e99c0348b7c16dadd474826e0862fb11a1726edddbf1ed20b6bfca52beb7769a428fbd43397e0011c98270bec576c921814afc1b78e022c62729a0082421923facfe82f919a0e3d8486229d6f3b60920173317cabd74f8845658ada5e1f2070fea13b87b1b972d7aefc625ba4d519fd57b9d4ba7ffa0bf93e884b54aaeea836c891b8e72652cf50cf05169cfe3fb4fa88bf3bb09bdf5070ae695ae09b283350f4795d927c2932b9500c700d1b7d94ac94954172f0880cc731ccb5e178894bccd96a401c3a2ce56ceda30c318db83143768b0dd6d2f895f215d7cbe1833355eb1dba1f18ab9ab98879e78e6a59e3a6cedd72ee95e9037b9fb84798a3bd724ec476c261687f6cff1be607e8175c43b3370a7e8dbb6c6a64fca7f0d4d690e01ad4df7b09b7767a071d70c07e74bd43bfa3dbf4194a51174c96d1bf190b89e30c846c53793d228069aa5c8ef34d9ea780ed0e6d1d75fa22d068300331d14d8d33bfb84da6aaa29019c30afc123ca4c3709d38b9eeecccff568e787cf5bb170f8e942f7b66f7c167d739b382f200ac1bb1c636f48b9490252afb27960af62b74866c35ddc751bde9e8843112e49e9f77515a3973012c60c9375d2ecb4e4231ba308a50b8e708afd0475a644de2f8cff613e422a4a7e1e013a51e5404ef52f89034e6a7a32a6482792a22377a4fe89d914e71ea20abbb3b0ed6ff1fcf41513939071c1789d4aada0c247f549eefebb2d9c1019d9500258b779874bfa2cff70b35964afcf7ab2d88e993dfb42a5d113250d3a644fdeecb136c6f9642aaa775b995e24b337b16a3034272f95d7165679120a7af92edb579916cc6890b95aa900a54412e142fbf80fa338528b946efc21b5a2a01c00f29f35556157845d1acd445b71df43f8b0d7fad7adebbb263615278d251b41bd4e21c411dd5d4719c0714db87def2b34dc35e4b54683b90976d736c179a0e757e08043d3e3a9763082c5eb9ff963fdb200e6cf9cd5eef910d8dfdba4a698fbe827401c6573d85d701ddf5ab0ad37346c5755d0cb6936d07fab58d976bbcdd9034013b6fb99fe394429630bea27ac3610b751521249746ec00b4a07909d26494f64c22234f4de0137fd72bc396c80c4940d1fb3eec77a162dd1b4c1e5c7f59838669c04c12f40c7aa5adc817ab7e2cb6fbcfb4f946989e353021202b2a718134e3a13b3208d24c6b789be38f664aaef49cdcf915b6e43b59593564352935ad0475402f6ae38d3618b743386daeabebb875056ade997d2ab1f4852c873677086632db69b7a3bef21a3f1de624980c7012d0f830f5d6ece5f0f304eb70889e91443a28551c82b69472880dcd6a485f5ea1d6201846e46029213ba7ac886b455e3c282d23df11fbcf7d5147981c125c1723aab8ca029e482db35a611f7e88fb4a6ef1014c0899b3c6f4cf4d7a4b8e84bc72464cea6091139a49c4f0d82350718dd45e07718b04dec8482460f1e0e140e5e3bc9e4d3e5759220f951e958f248508499d549a73882252bdbaaed2c4919fd68139492dac1453edf0bd60010f7f6f9fdc302be5f9712719b23b0f98ac6ecc135a94dad26102dde98f55d19f8f4df8a5ffa59811399ba7f921021ebc570f091597edc355433341de9a5ba2bd602d812812c66d2bc44a9419a238f12c471837c2baaa2bbd8461c3af1618ccf9b811f8bcaa28f357d8a1fa52cbd7c0c2a0b6487a8b38b222fd017046bfcde3872739b94e0baf3f258c1dc22c0f5bdff0c41415b91dc681ed2bdce7ac366596732fd1d85d0f2dfe86279c574327216ce1c102b30969e9adc847ac7c3cf6abe7caff6e6e1ef0488c9dd83a606f6b361aa46dbbf4d05138fdfb53ed219446216130324a45cda171ddc8879cc8d257e1a252d1c6c8abe2e7c71d80d9a23f272474e7506ee00be35eba08effd8b7ef928baa92618990908b1aba2855b704938020ea085d821fc599a6403dec3ce5fb88d9423367ec2f543f7296315d0db85f82763900be7206865eb0d58aaab9374388f261496832d19bf154725e72b288f5dd9c221f0571bcf55871f3c82a472cb6e47cb15d5d8e35e112edab6e02a10faf8907d2ac38d31343c8662c1c1257232c12868be0b14e802ddb14a0c3a268e35741dbc79134dbbc02dd528791b9e83902bf92114f88aea43ccb22f42e6755f32b503d39980cdb4d673d644660b3c5fa21bafe181e8077da4dbbbd15536efe7928f24922567b5df481e585df3f6fe732a451cfe6910fd3d2d49f984f65ed83235ba45ddad919e81a036c0b595fbdaa58b5e90502a7c0ef243d8600ff27c92a0af1de2832f60fcdc7d3acf2c0e36c4154c2b8ff7d0a38b58757f91cdbdb02ffec582038fadddb62da28775759a3062998713982821578d9625e8cb9ff9dc0078f2f7a284bd63744d2a2ad62a7efb7e57f8e42778e03a98aec5d63488b93884c18a45294a873d98c17d63e491efef47e13bad98dbcc41dbd2c97debca986374a62bbff8eb3a4da29b3e8172c5c2bf153f3285d2b4f744ebf8599b0bce29ede11899d4a44b6644a72f3f6e9351416c6c9ac82dff50af125534df5fe88be2deab9f6355f1cae9d3862e9ff283b088bb1392116598e2e66bd42dddedec2dc8eae77fa75847bdc8892f7a83227348a2d744930279fe5be24b7e9e4048a6d0c7a75acadd1398cd6d2eddcece7851e3b62bc81706431988b3e5e6be6639d7be32cf2f6501b16db19b28a8e48a4a8bbef4e06a5cad68035e35b99f590fd9478d5a47ad04fe43230d7518f478bf9f7eba6de6fd8abc4f2824d16255952e17e8c0c53a04eccd2be51c859b19be6b95bda60b0930f31c4477abc43c4900c6642808d2c56c0fa0722bff5ca774c39f5e80cdc88ed608cacd12acfa60b7cf36261243abaefc77c85ef3d4f4024dc95b52e98ed82c3faf5836a77d372a4706478a0464c712dbaf5142ba569043f1f9f7c906fd9f76c5a7dde87c6b4b3179289c76fff23a207a615ea763825b81ce612fb5f7482acd5df346400d8481a14def0f33d4cb845d554f7b02b89b2982dc40296af9f09d4f8a8a57d8408a821194466b376ef6e602b494dfb72850f8e887bfbee1db324289fe59d2e5d92fec4dcfec95cc10daef3de43c112a9cd89ada3f27a0a81134e5aa74e35eb25db8a9ee608e16da268fd64f28487dc4f23d2646370f22f1231ecfc6efa29aee180aa6430ecd41a11e8ee547216c1cec18aa420d6d575bc7b8fff1f9cb38868466c55336f486243fb293460e05e60b199ac7851a7936bee5e4d7105ee183e580bc0284b67992f95d26da8882e84cd7272bda9e3a5c7284b260d615cbfab27b0b7cfbcb3d4a47c02b65b351eb7f6825f19d4186dc3d033f99c7033942e1dd0515cb4ac6720b510f41255261ddb89f02e0753420154a1bf1bf10cdef3764ec04267f12d78cc6147f980529f6f241885f3be3c69286f42c9d950e84eacb2988ea0a9286ba1934d7588adb0013429a561ebe9fe5ff0bf9f0d0a7339338c89ad906fdac59c89d18cd4448cda082ff1c749930966344c7f6288c1e6e4fdba83f49deeaf75e5d52ce48173e68ce470099a25baab3da2b367988561e87e49e28759b8969a282a220ef9e865cb6977d514aeb2229c228df8a42a7a1bb59dba182d16923508eba90635398663552dee5221126e20e98858f5d84c5cc53df1c65f21c150acce6a7f3d082e044a3cc8926da6332d196c8e022586d582577480afbe9744e722788614fb58e44a827bc6184e01468326502cd45b892e1f89a96760cec606275088ac72100db90e9dab779e5606ca8d5234052950bb1486a0de7871843e582f23a2c3ec7b3b3694a698e4b7eb485546b33ff041fc91993420f4a21de5893822f0934dc95d5909e0273f1376114833cac246f97988b1fac707f10bce4e34d2871fe96d54e514a9ec779b4045f781a7ed3676957b29b0210018df4a1f44f27ce1d943a026e40c11bdfaa596b3a966724ce00c0901297ac060605647d89308a33c561be7359033ab04bb8e6db5dcf1d87e6974acafdb1b31db5b0f9107542483661fe6327d156b53ca976df2e765b1aa3fed0c192a03d9cfcaaf39985d6a08da2fc288a028da92f26efbfc1586c987e867569ded7432990e618b2aafc672ee98657bd810a70834eb8cc0973f7c9bace215d08741f18496b6c7a77f53a617a9b3e1a89e580008b3c29de3b14663924dd338c94d1480d676da6197c487e5a5e360b18f6a8f6205af3d35038c9e2c07a17353ed6a6a29c8f37b5be900b667a96acfcc390065b6633055dbb7da9b13e67df1f7b06ba94af2a43da97e2a8ed64bc47fd0ac5154ba736e2e56db95029ffe7689ff89fab980f0ad5edcb5aced63e3d5a9e6d787641e085a0b9d1e10fc2f55a17bb6548c06439cecdfe501b88d5c2475bd88ec6b367737cbf10cfc5a6da35018e2abe20264884217a6f52362e1d9def4fb2c2de938acc0a42be903c9dfea2373a80056ee463c2d63ec16d3c1eb2a123371de3cc357d0a669aa28f15be7cc632371c62b8b9a610bb6836c9ad77d39fd7138ce7cd5027fbc08bf87c1bf396d8ec06fb84dc39fa91950a7598778dcaaf53249f60973c6e371a7b1375f1790e0d203776679159f95d01572948d275713986fa004abbc3b664540a52dfb5243660a2a81823479a41635dafbcf9bd9f3f9a68c309eed955edba2b191334317bc098c6dfed268f6af8a02a9ee37be73b7086edbd2a3934ca1421bd540f9a4890b4732589265b162c454c6c8b98b493b3b074e9cb1e5ffaad870eb18bbbeb0da2c1f17389bf95356c6016851ab7ed1b9c984f42da8336daa5e71c4d96bd8198b41fe68c74c0ba68a63a21c900a2e3eccdf1ae1ae78dc3f0c3f5af69436b8d7d4328af4afbda4936dce66b72f77a40e8bab8ac4ae61c337cce640956d5913b41245d15fdbbc95b08e5942a544df79070adbdbc1839dd09830f73b6bff35651887630846397f51e221a57228bc1b801eb25418648bf85971a7bf94179152341f19b727e85ce3c43f53b344041a7538ef4e020071d744600484a9a0879e0d4c281d653c1fab5629006312a12b454f2a73c5e131eb98cc2becd9c1635d57b63f06ad1243a4d22386b51df4d40392e257def6159e761a02659f05ede1622f1490dba39b0d745e1117ef7fc99a23f71b7fcf644d2fc9c53a744125ebbc1dd3b104c997f099e6a8e94ec7759335275f6a1170201561e89450afefbf18c21a1fe8ea60907877166db8d052bb2e2bf95110463d429dbc0b4335bcdae5884d90b00aa6c6998a62626a704f06683174dbe0728e96d1add95ceb107c7091bae06f607593feebab0dfefb84b12a4c3aa601c070fd7f819a0c94591d38ecef308c741fa9d502996dc8609e830adfed6dad82e90dd2706151bc81b70d351e737b6f4592726e55fc79768441510b31f49aee196b4c5e55c5e0f1d530c1cc00e4c300cfbd764d28829349d1c38fa0316ea643bbf5c7ad455aa5ad36a9e7028ad806dff63efbb71bd462485f692e177b1e72c195e4824cbf44aed008d8e952e52dfa6f21c52d44ab80cb9293b1fb9d02cf956ab6d1adabccd7618e4dec2a38729164d34ea7d9c4802004f84c60f3212aaae9e344e28121a27e536f7b19372ffac146175823dd919029c2a94dfc3e5c7366f8159bc4c78907752ddde10390d3c54e7163aad3aa9a89d6fa1433ed602014c46d5308fed0ec75b7af464ebc908e42da7ead7d2882fc2445e2e5b250fea495e9c095dbd6ec82a99678de94b873e54d9a2e2ea5a68ac4e52b8d949f724f03e823d94557a23cfc0c7698eea4c1bc902d2f205271151aac31891c1e8eb027280433c6e8e1dbc9b817425ec513b61d0f3cd10137c9e425949c7be1ab7095bb971701493f15183f65a4107c103790fa35a35f3589b4cee91491576497905fe24ce21636cf7c692f4d48437262ef742641444804e5e6158ee66d09f89cf0ee213502d5bb525cb2b8d6cb36ae0fda1298faa3e66eb5c9e4e8dd896c62d3bfb04d80a8a1e71fd8b3448f7315b8ee36cd48d8d1c4ac2e28ea1d7d56ed37dd8fd2358f184500e958fdf7a67125ef036fd39f71772c3ae7b98901428c9016ea493e64d305770da7d32d7d20797456ce2da44479a5b20f70134632d1f589305c657799260dcfb6459a229a87f3a34fa8f21d622f87e6f6873611aedac5fb18b14efe2b55b907cd091c1542a7c42d0d605519b3e734d45bbccf9557e32facadf1c55316900c45aef6029b9e0cfecb6aaad2cef60066a687beb26adab4c0b5fe657c93ccd272550618cac26302533b4ce28635dffd417260f88e6ea9f428a627e7f83f8d6b3e1464d6c914059a0af338b9de48a022e0a86c83e97166e30a0e5a945a05953784b03d1acefda6e32cd51764bf73630f53d3e3bac60e884c8ac5e5883abf1727098d2858321d4263099cff1255a0c0026d4f7fccc77d4c77aa1b514cd16c1f61cf6af24c2dbb8a49e6b8479ef2935d5fb7d384ca7f0cf6fa08c0ab40b897a32edcddf4c3b1406cf3150f669c0b63475b7662f1ad7dcd3c148b547beb03b5a5ba0788ea0fcac453eef6448cae8c9cf844949784c06173995fb39740aa4d0c959d718a9969517ac5535e9dda7d14195cf007ec6dbe4229dcdef8130b4296fac2a62cb31346843d4fb1afbb9a1e172056f84ced4d1e4278d26eb3586750c63ca5fb4ea3ff128a9a24f692469346e4429ffe49eb1b9b86b01db40e7f710e7400b1d33b1562c0fbd2cafb20aa8894c80a327abd329cd66d26b7d7cf12adc2d84c51ac5e7d644b0fd1ecf923a89a629af2ef689339de2a82138103bbd916f55e9fb81aedb2ee2e2559427d7a3f62cbb6e370e65bc61a683e9c7b94adefe28e648fe875da66cc42f806cfb50a09fb337614239c7b49bff3a352dc1cb7a195ae9814e66f96b843af273ac78384931d6c4a90675400082a2f0c3813efaf174ca1c88c2da5af4f64f90ec66f3984ac6394d4208d83682e49a076104f5941d6a68abb656dc586659795d76563ac41f0b8332edb7409e7485f08ac0a37d81daac381243d4fbe50daef6dc51bf9778a1e2f1d3b4e011a9672437f28a19cb6a2a32733dc015afedc5f267baa1439398597aa3f565e35962b5dd2824d18b83fd62b7bd5f94af7592475216d84cf3f19e7bd7335241f795a3eeb7fc5bf06b271805188a1c3e792d1c50018a9f1312d3c64290abc4e3aaac22ce1c96bcce1f9507916ac3713856b6dc355218c0b50935f2b5f0480fcb7c18b59097de73f48c504f58c58fe5182a347821bd709590a2ce0a04f4233afaf5c3d756921ab4f0724a9433d9dce8fcdb076efc4181c234e01ba3bf1ab7ae035b26d2da8e7a816a1171d259d3789854aec90adf59207089f65ba178001f97fdec5d802234d4360e468d3e50101ac68cc2994243dbd67afddca3bb0be75ef4971f50131ff453734695dd0a7c5f473d394fcc237ed5605aa82fb4870628d3d94e737b7ef90ca332005f0cc6fc90273dcf017a9ff93e251f75f5af5fb56e69cc0d0c00c4f4daab4f5d3bb8ea4260c4d7f4ef8a59d48acdb3db06072c3d11325d1aeaf26444672ac9ea9754aeb3b798821ffc596ef53085308e6770a246fb6d9214c0060048cac54e248902f8833776a8ff60a0c26034bc334aee581b02f26cbe0b6553de0b35f00d7baabc4e5bd4046516f41cb0d8cccd8ae905dfee20347f5b6917f0a9ef8f5c2cad7ac16c5d8f5feca77ba9d3ddb47b37b47cf7e347e184f01fbd2eaf09d8ea9c8b33a4a009de5af72c2af980b96c863a85279811ef101a8d056885d53d3ec63725cf8d1295f1facec74dac812e3f83e8e583f381902c1a2cd96e1c65f734c8b4c3ac2847db88ab6f91a511502c32399fa9a0b3f3ea6fec99704b4e7e5baae255e2f4ea0b173d23af9cc26488a1fc88fa9b7b699aad14829d3707189873edc31dd50b1637447433954cfb875d24fab58803f00c114279796b5c9a29cfc6f4e9f2e3c57e3c25f982c624373eff0357970ceabc4790020eb27d5f976dfef6b14cd4ede19e77f0bd9176b1bd14b0d1e08c123de804496ec45c794dab5b037097185f8b7c3885ca219a6f0be62f382afc43cb433ecfdcbf057083f0dcb7524915822d00c2b0e16a70865e1dda2a29a99adaf9840402c4ca6b963eed017bb2a08fd59e2e7478421dc2e5eaeba639406dabd930daacda8e61504f7ed854e4ee74a023856e734563dab4a5a508cbe966228f3def1c0485b4d22b906e9943efedde85a7aa934062cab7fbd754c9e2c9c76bba4de595cf70b756c6d0763e15fa9e170a44f19727aeb213555d31fba532cff38633d6901cc5566d98154df21b89b177f22294459341eb230b612b0e5a877e8f6f11b1e5824140958d1963fce5c99b53851077b60a5e04f51ff72b511b1d455ed5485d0ee253ad28bff34b3c5f0ec76a96d6fac15e075bb08d6e844cd1f555be4c44c39af800124cea05b30a296e5fae78514d2fd189d7c329773b40287ddeea23c916f857167ebf299d7f0ae066ca171d4bc6b5309770e33ad2ed21c87e8371bd39858532f2b282b716806948f0209e415559b8e90c13fd8794d4e6e1bb56b06a3147d318e7165bbeca12b5a54df425aa37ee2b9d3f05e7587a5e93161bb1aa56317cc67d37e849102fa7ddee2ee80c478b6b262976e3e5f4fd0c4332104385d6acfb17b146f291de33e4dd6ddc55bda1b6f9a1287e9340b0f8e425e687147cc97fa71e5e6e74f0ddbbf940e600b0dec22de12622dfee4ace15daa6f59564fc09d27b6ff4be272b3a5d170ab4118669cb8ef7d162c5c1b582cb2122a2452824359c8aa893c87d422227e9da0406ff2c0b276449e066d5a44c4f893c5dd24ae2e6a376568b3d47e7451f293f21b9a154458ec9188310794ad7249fc2faff04ccee4bf62d7f019fd14e22dc725415b6ac57a463dc4ba08c231616b7ab06425c0453fa071d006185153c51b533631af1e665dac787cd86f9409ae1e905a9b75a8f151bd5852d9b7bc6085b467d4c29143db770615b5cb15035a9f00992967b5f2ccfd9ea21798ffb19fdfc27e66cdbdad8689211796e1837ce71486c943c80a435f111a306fd5e7fe9f652a4454dfa2ffec0b42097aec02a05084cfb30385d9c57e98411067b7035367e65ead2125a249f7e52558ee93782a8741329523e2c38736417278519e34ce1854392c2eddf5def35e2ba443b5806a24dfb700f4768095f9a095afd7d99bdc1157cd297977fce0a9496b0aabd0bd6b5ff4b0acd383575896cafd819949674b948af192087e7851de66ff990ce9fe0f81241866dbf082a05e3b7f4555e358ca57d5b291bd9eac49cf6921a111bdfbb3479500379285f41f47e14c4ddc682dfe4f1bb4fce1ea2259072b1c55fef56adf189c58a3b99069cbe8ad58b752f48bd2244d2ca99b1f36d08f815aa10c299fd8963298a476ec8af1c8967cc91702f6431f4ee782ca86ae8f229d894ebefa5219e2fd365e75db11473f01dfec34d89d5d9caccf9b6b9018fb150694371b86fb1b7a359bcf3a74d39d9c1d179ce59d5da032fb431729ee1b7b7fdbe14f7d5c0994fc2e26fe14d28dc9a4000ea83002165b278a5a2d09095d29c4b7d4429db7e6cc591bd68ae1291076f2c4cd95320b26a517466b3eb5ec5f51459a7895e9827142e6979054356bbd60ca56c56a3bdb16c2c83ca7974cb0efddfedad1149a9d6d6115fcb76dc834916bb6d1b57bc416ed2aeb69f15561a67fb94bbd167aec728a9f41d794f09e350db15714df9ff450f5281910ea9bea0f6625e2ec6e305210268c6e2d720a3e883924dcfb41b431b486239e4dc519a0af479f2648aaf87fa686668896d5456a22e64def6b66455a1635ca2194920e920f4dec6e7386ac10fa144a2b7aaf37477f53054183113b42125bbef48a05a77204b62163d47dfffb0e9d25d269984995585e9fc7bbbb55e488c40a3db795796f13382eea93517fe13507301aab4f97a7386a635ddb1a2b88377009fd43e0fbb45d7dd07b5b408c517513eb7da1609e3ca6a9046a381946bbc7f95c1b73c69e5663a6878f3b452ecb6bc5a9298f6640693bedade0532e398688ee7a5f0f0807f7d27354447917261e3184c1c2b6137810ac1d6d0d905bf21ebe2fa39078256a6077aaa6aa1dda513c25e1e2aa93cd43caf410c9865435a5d39a6d5f504cfb07ed9f5853c999077f6fe7286b600df521203732e63eaa748ebfaf31db7f92023552eeff625ec9b645752b7be7556f247bd6bb4af0d31e913bcc1a487a5bcce94d41e1e201b89d35d876379ce7d4ff2b9200927e9f6eec3fa422ef1dff410ed75b504112985dd4c8aad1392aa10bd70322ffb9a2340fa96f25da2261edfeca363e9a305c9dadae06b2aecedceaa52dbdf230bd8a256cd4931d17252e38eafe7f8f32e527d51d3d1216e14dd05f190090bf6d0cb2e13e318aa129fb0d01d287a0ae8d27eb35d3673709ca6ae25292a0bfa7beace836f5c34117951e01e88b89ebf8367c31f1142da43af9f901c93eecea9192aa4c60904d841c1ee84c5a01df0014e9f1ca8581e8b0a2ad58f0b1e275128207bccd73cda688197e74146bbcefba5683557683cd187b145a7d73926d38c6173ce1d1a687f3a335daca99b210713b7bb3d193556f8dedbdb3b24252f52d438637b2eab553a8fa611f3c73c0766bc8addde3d6ae6eacd1557918d09408b24cd869c03b836d9fcb3b381e111ce1fcaabc1393f099582be36aea4a47c926c675ac7162c701f362a6d078dcbcfff612a3846c77d4d5b0fcb34f13fe60a8d4d2bc4bc8a48b2bded718270a819308863b7ef208e176c94eabbcbb6bd0ae8dc6802fa65dc113523e326a276615a623e1bb5a9cc9f64496202e7b576be54c86f02ca80ab3d9c958845745ab7d7d9594373598952cc998f8dce64103fcb6e8e4a2616e653aeb9021f49a90c615385f2ef45f52adf79435911f1ab9979d3f2f3e3ab9b89666ac507eb7476a721dc4dedcd68e7face4836be92c41b07b9a6410fe0062d37848e13fb545803299e2f0600b65eb0dde448e9c8ce7a7e1b5dd66945b72cc831da9d7a4545fef3c3f161dd2dfa243df6457b2e92fc4402cc8e69a884d058283bc32cb165d8f1be8a8274ec7c17b41e389d921f7ffa220cef657df963b8700ed05f81ece683a0b411ec69d8a85d80548995c116ba0e3ae79bd29dcce6965d6da6510163477e96ee9c3a0df1d94584ee30bff9d404395d863a5e999ed8879f2718ca0a3d6a1660e80bcec594ba1020b29eec9761732954881e7ab6e53b60883913dfdc843867b1a1e45d059ad3dd1ae5b9852d6b61620ca75b88f0b2a19f5ba4cb44d7a8d28aa350232ceeff90c47e90f334e88dea3c82afab5fa3765de5e9ec52aff08389da08772211c1c2197ffce8c65d19a49a4e44c532c8b6413924b80cd0f9b786b5f53f369b57fafbf1526cce8f5231715e641e71fba6f31bb83615423c327e1d1fe968c1b7fe2abe5ea33dd87fa08490b456fe165b55fbb3986632b9084d4175630927df0e408d21c2ea96ca0989224835258e960c388196f2021f2fe7f00c3d069cefe132267d36ca5956d947bbedfe530515d784856e436555282356be16a0a1d21e85006ef6b8f96f03339e8aa8569689800ab391774db80d4d7eaa2477da153b0e9c7864e1a257e37e9c3a14f71742ea86082eda9e858606b2bbb1ea55fe1ac39f0a29c6b7950720a4edc7b35b692a1f09ef645945ec259a1ee1911076a996beda5b01a95c1a00c15d0912fa486e6cb6e2f045a9b5ea05f5c758ec092ebfc134054fd278b10a4cf4de0c9eb8edb4cf2b539e86bba98e9854726d016b966dbcd6740b5700113cb0d47c68ed9f34c4923c9abe140da3e45266db6b812130405e13585593953086aae27c043a71270e26c1addaba24b16d9f72cc56dc0ba1d92f933e65015e9a8d93e7fa297440c7d08dbcb4604903ce0e1fb110d93b466802439b75a0d0415933755e1e51605691aa493c69f52e43d60592f28d7b2ceeff16c55446d2eba9c3b6cd8b44c0491ec64eaed0a1edd99dacc1da9f19fc32f3d3acea5f6af53f9b7ac3c62a81801e96c77a62366bca9fb031f70666f1e9e64ee4d2041eab6750e3d6389a9254dcf10ae347a29dd8b41eacafa588b8f556f07b5a3c74bfcdf771d4dd3171947b598739a9847bc6e3c3915f704efe9b1cda155606d771543b642df8c5164f577ca006769ee046051fe5fee65ef14a5e1e74ea3d267e19010f3b54288e560c7f5b2a88d2ab4c63306798ee01a29e8989b94f32f72df03e0df590927410d76ece54158ea92b155602e3ad1a54d83810728d17adbeda01ee1691b8aa366252c7b7ca8ffe63da0addc2e03402a6a3c928dbc8f87eb23fbee6c33dc2e84fa245b4217dfb30b3288d8d2681dadd7df5372104aae1b047cc99f5855c136e225d29c6613ea60d3442837be2917964e387f754561219195f64ab3ba6b58eea42cdd17a3f7e76c8deab1c134cf5b19254b16e64b329b907de1b8343a260f7a0ec83c55ac74d678ce9da03afc9cf5a49cc4dd225b194798ed0bd04c94286c097af944f5bd4e496b9104fb6711b3009
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
  </entry>
  <entry>
    <title>测试</title>
    <url>/%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[测试中文 Chinese。

H1
H2
H3
H4
H5
H6
粗体 Bold
斜体 Italic

a
b
c


a
b
c

eiπ+1=0e^{\mathrm{i}\pi}+1=0eiπ+1=0
ans=114514=1919810\begin{aligned}
	ans&amp;=114514\\
	&amp;=1919810
\end{aligned}
ans​=114514=1919810​
ωn±1=cos⁡(2πn)±sin⁡(2πn)i(2,8)\omega_n^{\pm 1}=\cos\left(\cfrac{2\pi}{n}\right)\pm\sin\left(\cfrac{2\pi}{n}\right)\text{i}\tag{2,8}
ωn±1​=cos(n2π​)±sin(n2π​)i(2,8)
F(x)=Fl(x2)+xFr(x2)(3)F(x)=F_l\left(x^2\right)+xF_r\left(x^2\right)\tag{3}
F(x)=Fl​(x2)+xFr​(x2)(3)
F(ωnk)=Fl(ωn/2k)+ωnkFr(ωn/2k)F(ωnn/2+k)=Fl(ωn/2k)−ωnkFr(ωn/2k)(4,5)\begin{aligned}
F\left(\omega_n^k\right)&amp;=F_l\left(\omega_{n/2}^k\right)+\omega_n^k F_r\left(\omega_{n/2}^k\right)
\\
F\left(\omega_n^{n/2+k}\right)&amp;=F_l\left(\omega_{n/2}^k\right)-\omega_n^k F_r\left(\omega_{n/2}^k\right)
\end{aligned}\tag{4,5}
F(ωnk​)F(ωnn/2+k​)​=Fl​(ωn/2k​)+ωnk​Fr​(ωn/2k​)=Fl​(ωn/2k​)−ωnk​Fr​(ωn/2k​)​(4,5)
Yj=F(ωnj)=∑k=0n−1(ωnj)k×F[k](6)Y_j=F\left(\omega_n^j\right)=\sum_{k=0}^{n-1}\left(\omega_n^j\right)^k\times F[k]\tag{6}
Yj​=F(ωnj​)=k=0∑n−1​(ωnj​)k×F[k](6)
F[i]=1n∑j=0n−1(ωn−i)j×Yj(7)F[i]=\cfrac{1}{n}\sum_{j=0}^{n-1}\left(\omega_n^{-i}\right)^j\times Y_j\tag{7}
F[i]=n1​j=0∑n−1​(ωn−i​)j×Yj​(7)

#include &lt;iostream&gt;int main()&#123;    printf(&quot;Hello World&quot;);    return 0;&#125;
code
sout
洛谷



点击查看神秘数字
114514


[x] 114514
[ ] 1919810


[!NOTE]
Useful information that users should know, even when skimming content.


[!TIP]
Helpful advice for doing things better or more easily.


[!IMPORTANT]
Key information users need to know to achieve their goal.


[!WARNING]
Urgent info that needs immediate user attention to avoid problems.


[!CAUTION]
Advises about risks or negative outcomes of certain actions.

There is a comment below.

There is a comment above.
Here is a simple flow chart:
graph TD;    A--&gt;B;    A--&gt;C;    B--&gt;D;    C--&gt;D;]]></content>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
</search>
